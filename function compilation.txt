FUNCTION /cgdc/clrq_bdr_reject.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(IT_VBELN) TYPE  /CGDC/TT_VBELN OPTIONAL
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: BDR Reject
**********************************************************

  DATA: lv_returncode TYPE sysubrc,
        lv_invalid    TYPE flag.

  CONSTANTS:lc_status      TYPE char1 VALUE 'D'.

  IF lv_invalid IS NOT INITIAL.               "ACT Issue Fix
    PERFORM check_clrq_authorization USING  gs_clrqdoc_infocus-x-crhdr-clrqt
                             gs_clrqdoc_infocus-x-crhdr-vkorg
                             gs_clrqdoc_infocus-x-crhdr-vtweg
                             gs_clrqdoc_infocus-x-crhdr-spart
                             gc_auth_actv-change
                             space
                       CHANGING lv_invalid.
  ENDIF.

  LOOP AT  it_vbeln INTO DATA(ls_pbd).
    SELECT SINGLE * FROM /cgdc/_clrqdf INTO @DATA(lwa_clrqdf) WHERE sbqdc = @ls_pbd-vbeln.
    IF sy-subrc EQ 0.
      DO 5  TIMES.
        SELECT * FROM vbrk INTO @DATA(lwa_vbrk1)
                  UP TO 1 ROWS
                  WHERE vbeln = @lwa_clrqdf-sbqdc
                  AND   pbd_status = @lc_status.
        ENDSELECT.
        IF sy-subrc EQ 0.
          EXIT.
        ELSE.
          WAIT UP TO 5 SECONDS.

        ENDIF.
      ENDDO.
      SELECT * FROM vbrk INTO @DATA(lwa_vbrk2)
        UP TO 1 ROWS
              WHERE vbeln = @lwa_clrqdf-sbqdc
              AND   bdr_status <> @lc_status.
      ENDSELECT.
      IF sy-subrc EQ 0.
        CALL METHOD /cgdc/cl_clrq_process=>bdr_reject
          EXPORTING
            it_prebilling = it_vbeln
          IMPORTING
            cv_subrc      = lv_returncode.
      ENDIF.

    ENDIF.
  ENDLOOP.

ENDFUNCTION.

FUNCTION /cgdc/clrq_be_eval.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_ACTION) TYPE  CHAR1
*"  CHANGING
*"     REFERENCE(CT_CLRQ_DOC) TYPE  /CGDC/TT_CLRQ_DOC OPTIONAL
*"----------------------------------------------------------------------

  DATA: lt_message_be TYPE /cgdc/tt_be_msg,
        lt_log        TYPE /cgdc/t_blklog,
        lt_crit_log   TYPE /cgdc/tt_blk_crit_logs.

  CONSTANTS: lc_name_clrq_doc   TYPE abap_parmname VALUE 'CS_CLRQ_DOC',
             lc_name_return     TYPE abap_parmname VALUE 'CT_RETURN',
             lc_tabname_clrqhd  TYPE ihttpnam VALUE '/CGDC/S_CLRQHD',
             lc_tabname_clrqbi  TYPE ihttpnam VALUE '/CGDC/S_CLRQBI',
             lc_fname_clrno     TYPE ihttpnam VALUE 'CLRNO',
             lc_fname_bill_item TYPE ihttpnam VALUE 'BILL_ITEM',
             lc_fname_faksp     TYPE ihttpnam VALUE 'FAKSP'.

  IF /cgdc/cl_be_helper=>mv_parallel_process_enabled = abap_false.

    CASE iv_action.
      WHEN gc_be_eval-run_evaluation.

        LOOP AT ct_clrq_doc ASSIGNING FIELD-SYMBOL(<lwa_clrq_doc>).

          DATA(lt_params) = VALUE abap_parmbind_tab(
                            ( name  = lc_name_clrq_doc
                              kind  = cl_abap_objectdescr=>changing
                              value = REF #( <lwa_clrq_doc> ) )
                            ( name  = lc_name_return
                              kind  = cl_abap_objectdescr=>changing
                              value = REF #( lt_message_be ) )
                              ).

          /cgdc/cl_be_helper=>be_rtb_eval_execute(
            CHANGING
              ct_params = lt_params
          ).

          "" refresh globals for new CR
          CALL FUNCTION '/CGDC/BLKOBJ_CR_REFRESH'.

        ENDLOOP.

      WHEN gc_be_eval-update_logs. "" update block logs

        "Update logs and get global logs
        CALL FUNCTION '/CGDC/COMPILE_CR_LOG'
          IMPORTING
            et_log       = lt_log
            et_critm_log = lt_crit_log.

        IF lt_log IS NOT INITIAL.
****      trigger notification
          LOOP AT lt_log ASSIGNING FIELD-SYMBOL(<lfs_log>).
            CASE <lfs_log>-state.
              WHEN '3'.                     "removed
                DATA(lv_blkid_remv) = <lfs_log>-blckid.
                IF lv_blkid_remv IS NOT INITIAL.
                  "get instance
                  CALL METHOD /cgdc/cl_be_helper=>get_instance
                    EXPORTING
                      iv_blkid  = lv_blkid_remv
                      iv_blktyp = /cgdc/cl_be_helper=>gc_block_type-billing_block
                    RECEIVING
                      ro_blkobj = DATA(lo_blk_remv).

                  IF lo_blk_remv IS BOUND.
                    "set context
                    DATA(lt_add_key_data) = VALUE /cgdc/tt_ntf_addn_key_data( ( tabnm = lc_tabname_clrqbi fldnm = lc_fname_bill_item  value = <lfs_log>-billing_item )
                                                                               ( tabnm = lc_tabname_clrqbi fldnm = lc_fname_faksp      value = <lfs_log>-blkcd ) ).

                    DATA(lt_ntf_dyn)      = VALUE /cgdc/tt_ntf_dyn_fld_values( ( tabnm = lc_tabname_clrqhd fldnm = lc_fname_clrno  value = <lfs_log>-document_no
                                                                                 addn_key_data =  lt_add_key_data ) ).

                    "send
                    lo_blk_remv->trigger_notif( EXPORTING iv_situation      = /cgdc/cl_be_helper=>gc_be_sttn              "Block eng Notif for Calculation Req.
                                                          iv_situation_type = /cgdc/cl_be_helper=>gc_becr_stntp_remove
                                                          it_ntf_dyn        = lt_ntf_dyn
                                                IMPORTING et_ne_logs        = DATA(lt_ne_logs) ).   "Block removed

                    <lfs_log>-notf_guid = VALUE #( lt_ne_logs[ 1 ]-guid OPTIONAL ).
                  ENDIF.
                ENDIF.

              WHEN '2'.
                DATA(lv_blkid_set) = <lfs_log>-blckid.
                IF lv_blkid_set IS NOT INITIAL.
                  "get instance
                  CALL METHOD /cgdc/cl_be_helper=>get_instance
                    EXPORTING
                      iv_blkid  = lv_blkid_set
                      iv_blktyp = <lfs_log>-blk_typ
                    RECEIVING
                      ro_blkobj = DATA(lo_blk_set).
                  IF lo_blk_set IS BOUND.
                    "set context
                    lt_add_key_data = VALUE /cgdc/tt_ntf_addn_key_data( ( tabnm = lc_tabname_clrqbi   fldnm = lc_fname_bill_item  value = <lfs_log>-billing_item )
                                                                        ( tabnm = lc_tabname_clrqbi   fldnm = lc_fname_faksp      value = <lfs_log>-blkcd ) ).

                    lt_ntf_dyn      =  VALUE /cgdc/tt_ntf_dyn_fld_values( ( tabnm = lc_tabname_clrqhd   fldnm = lc_fname_clrno  value = <lfs_log>-document_no
                                                                            addn_key_data = lt_add_key_data ) ).

                    "send
                    lo_blk_set->trigger_notif(  EXPORTING iv_situation      = /cgdc/cl_be_helper=>gc_be_sttn                 "Block eng Notif for Calculation Req.
                                                          iv_situation_type = /cgdc/cl_be_helper=>gc_becr_stntp_set
                                                          it_ntf_dyn        = lt_ntf_dyn
                                                IMPORTING et_ne_logs        = lt_ne_logs ).   "Block set

                    <lfs_log>-notf_guid = VALUE #( lt_ne_logs[ 1 ]-guid OPTIONAL ).
                  ENDIF.
                ENDIF.

            ENDCASE.

            REFRESH lt_ne_logs.
          ENDLOOP.

          CALL FUNCTION '/CGDC/BE_CLRQIT_MASS_UPDATE'
            EXPORTING
              it_log = lt_log.

          CALL FUNCTION '/CGDC/CR_BLKLOG_DB_UPDATE'
            EXPORTING
              iv_appln       = '/0'
              it_ins_bobjlog = lt_log
              it_critm_log   = lt_crit_log.

        ENDIF.

        CALL FUNCTION '/CGDC/BLKOBJ_REFRESH'.

      WHEN OTHERS.
    ENDCASE.
  ENDIF.

ENDFUNCTION.

FUNCTION /cgdc/clrq_cond_change_upd.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IS_KONX) TYPE  V_KONX OPTIONAL
*"     REFERENCE(IS_VAKE) TYPE  VAKE OPTIONAL
*"     REFERENCE(IS_KONP_OLD) TYPE  KONPDB OPTIONAL
*"     REFERENCE(IS_KONP_NEW) TYPE  KONPDB OPTIONAL
*"     REFERENCE(IS_KONDT_OLD) TYPE  VKONDAT OPTIONAL
*"     REFERENCE(IS_KONDT_NEW) TYPE  VKONDAT OPTIONAL
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Cost Condition Change Calculation Reprice
**********************************************************



  TYPES: BEGIN OF lty_clrqhd,
           clrno  TYPE /cgdc/clrqno,
           clrit  TYPE /cgdc/clrq_itmno,
           clrsit TYPE /cgdc/clrq_sitmno,
           bstat  TYPE /cgdc/clrqi_billstat,
           istat  TYPE /cgdc/clrqi_istat,
           rtbpn  TYPE /cgdc/rtbpn,
           vgbel  TYPE vbeln_va,
         END OF lty_clrqhd.
  TYPES : BEGIN OF t_rtbpn,
            rtbpn  TYPE /cgdc/rtbpn,
            csheet TYPE aufkalsm,
          END OF t_rtbpn.
  DATA: lt_clrqhd  TYPE TABLE OF lty_clrqhd,
        lwa_clrqhd TYPE lty_clrqhd.
  DATA : lt_clrqpit TYPE TABLE OF /cgdc/s_clrqpit.
  DATA : lt_clrqpcn TYPE TABLE OF /cgdc/s_clrqpcn.

  DATA: lwa_rtbppc TYPE /cgdc/t_rtbppc.
  DATA: lt_rtbppc TYPE TABLE OF /cgdc/t_rtbppc.

  DATA : lt_rtbpn  TYPE TABLE OF t_rtbpn.
  DATA: lt_t683s TYPE TABLE OF t683s.
  DATA: lv_tabname      TYPE tabname,
        lt_dd03l        TYPE TABLE OF dd03l,
        lt_dd03l_h      TYPE TABLE OF dd03l,
        lt_dd03l_i      TYPE TABLE OF dd03l,
        lwa_dd03l       TYPE  dd03l,
        lwa_dd03l_h     TYPE  dd03l,
        lwa_dd03l_i     TYPE  dd03l,
        lt_fieldname_r  TYPE RANGE OF fieldname,
        lwa_fieldname_r LIKE LINE OF lt_fieldname_r.
  DATA: lv_h_fieldame TYPE fieldname.
  DATA: lv_i_fieldame TYPE fieldname.
  DATA: lv_rprc_code TYPE /cgdc/rtb_rprc_actn_code.

  DATA: lt_components_r TYPE abap_component_tab,
        lt_components_w TYPE abap_component_tab,
        lwa_component_w TYPE LINE OF abap_component_tab.

  DATA: lo_structdescr_r TYPE REF TO cl_abap_structdescr,
        lo_typedescr_r   TYPE REF TO cl_abap_typedescr,
        lo_data_r        TYPE REF TO data,
        lo_data          TYPE REF TO data.
  DATA : lv_where TYPE string.
  DATA : lv_where_curr TYPE string.
  DATA : lv_where_left TYPE string.
  DATA : lv_where_right TYPE string.
  FIELD-SYMBOLS <lwa_clrqpit> TYPE /cgdc/s_clrqpit.
  FIELD-SYMBOLS <lwa_clrqpcn> TYPE /cgdc/s_clrqpcn.
  FIELD-SYMBOLS <ls_search> TYPE any.
  FIELD-SYMBOLS <lt_data> TYPE table.

*Local Constants Declarations
  CONSTANTS: lc_workarea    TYPE char12 VALUE '<LS_SEARCH>-',
             lc_fname_kappl TYPE fieldname VALUE 'KAPPL',
             lc_fname_kschl TYPE fieldname VALUE 'KSCHL',
             lc_fname_kfrst TYPE fieldname VALUE 'KFRST',
             lc_fname_knumh TYPE fieldname VALUE 'KNUMH',
             lc_fname_vbeln TYPE fieldname VALUE 'VBELN',
             lc_fname_vgbel TYPE fieldname VALUE 'VGBEL',
             lc_fname_posnr TYPE fieldname VALUE 'POSNR',
             lc_fname_vgpos TYPE fieldname VALUE 'VGPOS',
             lc_where_and   TYPE char03    VALUE 'AND',
             lc_where_or    TYPE char02    VALUE 'OR'.

  lv_rprc_code = is_vake-kappl.
  "Create Action Key based on Changes
  IF is_konp_new-kbetr <> is_konp_old-kbetr.
    CONCATENATE lv_rprc_code gc_rprc_actv-amount INTO lv_rprc_code.
  ENDIF.
  IF is_konp_new-kfrst <> is_konp_old-kfrst.
    CONCATENATE lv_rprc_code gc_rprc_actv-rel_sts INTO lv_rprc_code.
  ENDIF.
  IF is_konp_new-loevm_ko <> is_konp_old-loevm_ko.
    CONCATENATE lv_rprc_code gc_rprc_actv-del_flag INTO lv_rprc_code.
  ENDIF.
  IF is_konp_new-updkz = gc_updkz_new.
    CONCATENATE lv_rprc_code gc_rprc_actv-new INTO lv_rprc_code.
  ENDIF.
  IF is_konp_new-konwa <> is_konp_old-konwa.
    CONCATENATE lv_rprc_code gc_rprc_actv-unit_value INTO lv_rprc_code.
  ENDIF.
  IF is_konp_new-kmein <> is_konp_old-kmein.
    CONCATENATE lv_rprc_code gc_rprc_actv-unit_of_meas INTO lv_rprc_code.
  ENDIF.
  IF is_konp_old-kpein <> is_konp_old-kpein.
    CONCATENATE lv_rprc_code gc_rprc_actv-per INTO lv_rprc_code.
  ENDIF.
  IF is_kondt_new-datab <> is_kondt_old-datab.
    CONCATENATE lv_rprc_code gc_rprc_actv-valid_from INTO lv_rprc_code.
  ENDIF.
  IF is_kondt_new-datbi <> is_kondt_old-datbi.
    CONCATENATE lv_rprc_code gc_rprc_actv-valid_to INTO lv_rprc_code.
  ENDIF.

  "End.
  IF is_konx IS NOT INITIAL.
    IF lv_rprc_code IS INITIAL.
      lv_rprc_code = is_konx-kappl.
    ENDIF.
    SELECT SINGLE *
      FROM konp
      INTO @DATA(lwa_konp)
      WHERE knumh = @is_konx-knumh.

    SELECT SINGLE *
      FROM konh
      INTO @DATA(lwa_konh)
      WHERE knumh = @is_konx-knumh.

    IF lwa_konp-kbetr <> is_konx-kbetr.
      CONCATENATE lv_rprc_code gc_rprc_actv-amount INTO lv_rprc_code.
    ENDIF.
    IF lwa_konh-datab <> is_konx-datab.
      CONCATENATE lv_rprc_code gc_rprc_actv-valid_from INTO lv_rprc_code.
    ENDIF.
    IF lwa_konh-datbi <> is_konx-datbi.
      CONCATENATE lv_rprc_code gc_rprc_actv-valid_to INTO lv_rprc_code.
    ENDIF.
    SELECT *
       FROM t683s
       INTO TABLE lt_t683s
       WHERE kschl = is_konx-kschl.
    IF sy-subrc = 0.
      SELECT rtbpn csheet
        FROM /cgdc/t_rtbpacs
        INTO TABLE lt_rtbpn
        FOR ALL ENTRIES IN lt_t683s
        WHERE csheet = lt_t683s-kalsm.
      IF sy-subrc = 0.
        SELECT i~clrno i~clrit i~clrsit i~istat bi~bstat h~rtbpn h~vgbel
        FROM /cgdc/_clrqhd AS h
        INNER JOIN /cgdc/_clrqit AS i ON i~clrno = h~clrno
          LEFT OUTER JOIN /cgdc/_clrqbi AS bi ON i~clrno = bi~clrno AND i~rtbbinr = bi~bill_item AND i~bityp = bi~bitype
          LEFT OUTER JOIN /cgdc/_clrqpit AS /cgdc/_clrqpit ON i~clrno = /cgdc/_clrqpit~clrno AND i~clrit = /cgdc/_clrqpit~clrit
          INTO CORRESPONDING FIELDS OF TABLE lt_clrqhd
          FOR ALL ENTRIES IN lt_rtbpn
          WHERE   h~rtbpn = lt_rtbpn-rtbpn AND   i~csheet = lt_rtbpn-csheet
          AND i~zschl = is_konx-varfld003 AND i~kokrs = is_konx-varfld001
          AND i~budat GE is_konx-datab AND i~budat LE is_konx-datbi.
        IF sy-subrc = 0.
          DELETE lt_clrqhd WHERE clrsit = '000000'.
          SELECT *
            FROM /cgdc/t_rtbppc
            INTO TABLE lt_rtbppc
            FOR ALL ENTRIES IN lt_rtbpn
            WHERE rtbpn = lt_rtbpn-rtbpn AND kschl = is_konx-kschl.
          LOOP AT lt_clrqhd INTO lwa_clrqhd.
            READ TABLE lt_rtbppc INTO lwa_rtbppc WITH KEY rtbpn = lwa_clrqhd-rtbpn.
            IF sy-subrc = 0.
              READ TABLE lt_clrqpit TRANSPORTING NO FIELDS WITH KEY clrno = lwa_clrqhd-clrno
                                                                    clrit = lwa_clrqhd-clrit
                                                                    clrsit = lwa_clrqhd-clrsit.
              IF sy-subrc <> 0 AND ( lwa_rtbppc-uclrit = gc_upd_prcess-no_update OR ( lwa_rtbppc-uclrit = gc_upd_prcess-open AND lwa_clrqhd-bstat IS NOT INITIAL )
                                     OR ( lwa_clrqhd-bstat IS INITIAL AND
                                          ( lwa_clrqhd-istat = gc_ibill_stat-open
                                         OR lwa_clrqhd-istat = gc_ibill_stat-postponed
                                         OR lwa_clrqhd-istat = gc_ibill_stat-rejected ) ) ).
                APPEND INITIAL LINE TO lt_clrqpit ASSIGNING <lwa_clrqpit>.
                <lwa_clrqpit>-clrno = lwa_clrqhd-clrno.
                <lwa_clrqpit>-clrit = lwa_clrqhd-clrit.
                <lwa_clrqpit>-clrsit = lwa_clrqhd-clrsit.
                <lwa_clrqpit>-action_cd = lv_rprc_code.
                <lwa_clrqpit>-updkz = gc_updkz_new.
              ENDIF.
              READ TABLE lt_clrqpcn TRANSPORTING NO FIELDS WITH KEY vbeln = lwa_clrqhd-vgbel.
              IF sy-subrc <> 0 AND lwa_rtbppc-ucont = abap_true.
                APPEND INITIAL LINE TO lt_clrqpcn ASSIGNING <lwa_clrqpcn>.
                <lwa_clrqpcn>-vbeln = lwa_clrqhd-vgbel.
                <lwa_clrqpcn>-updkz = gc_updkz_new.
              ENDIF.
            ENDIF.
          ENDLOOP.
        ENDIF.
      ENDIF.
    ENDIF.
    IF lt_clrqpcn IS NOT INITIAL OR lt_clrqpit IS NOT INITIAL.
      CALL FUNCTION '/CGDC/CLRQ_CLRQPRS_UPDATE_DB'
        EXPORTING
          it_clrqpit = lt_clrqpit
          it_clrqpcn = lt_clrqpcn.
      IF sy-subrc <> 0.

      ENDIF.

    ENDIF.
  ELSEIF NOT ( is_vake IS INITIAL  ).

    CONCATENATE gc_kvewe-pricing is_vake-kotabnr INTO lv_tabname.
    CONDENSE lv_tabname.
    CREATE DATA lo_data TYPE TABLE OF (lv_tabname).
    ASSIGN lo_data->* TO <lt_data>.

    SELECT *
      FROM dd03l
      INTO TABLE lt_dd03l
      WHERE tabname = lv_tabname
      OR tabname = gc_header_tabname
      OR tabname = gc_item_tabname.
    IF sy-subrc = 0.
      lt_dd03l_h = lt_dd03l[].
      lt_dd03l_i = lt_dd03l[].
      DELETE lt_dd03l WHERE tabname <> lv_tabname.
      DELETE lt_dd03l_h WHERE tabname <> gc_header_tabname.
      DELETE lt_dd03l_i WHERE tabname <> gc_item_tabname.

      lwa_fieldname_r-option = gc_operator-equal.
      lwa_fieldname_r-sign = gc_range_tbl_sign-include.

      lwa_fieldname_r-low = gc_clrqbi_field-mandt.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_kappl.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_kschl.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_kfrst.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = gc_calc_grp_rows_field-datbi.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_knumh.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      DELETE lt_dd03l WHERE fieldname IN lt_fieldname_r OR keyflag IS INITIAL.
      SORT lt_dd03l BY position.
      IF lt_dd03l IS NOT INITIAL.
        LOOP AT lt_dd03l INTO lwa_dd03l.
          CLEAR: lv_where_curr,
                 lv_h_fieldame.
          IF lwa_dd03l-fieldname = lc_fname_vbeln.
            lv_h_fieldame = lc_fname_vgbel.
          ELSE.
            lv_h_fieldame = lwa_dd03l-fieldname.
          ENDIF.
          IF lwa_dd03l-fieldname = lc_fname_posnr.
            lv_h_fieldame = lc_fname_vgpos.
          ELSE.
            lv_i_fieldame = lwa_dd03l-fieldname.
          ENDIF.

          READ TABLE lt_dd03l_h INTO lwa_dd03l_h WITH KEY fieldname = lv_h_fieldame.
          IF sy-subrc = 0.
            CONCATENATE 'h' '~' lwa_dd03l_h-fieldname INTO lv_where_left.
            CONCATENATE lc_workarea lwa_dd03l-fieldname INTO lv_where_right.
            CONDENSE lv_where_left.
            CONDENSE lv_where_right.
            CONCATENATE lv_where_left '=' lv_where_right INTO lv_where_curr SEPARATED BY space.
          ENDIF.
          .
          READ TABLE lt_dd03l_i INTO lwa_dd03l_i WITH KEY fieldname = lv_i_fieldame.
          IF sy-subrc = 0.
            CONCATENATE 'i' '~' lwa_dd03l_i-fieldname INTO lv_where_left.
            CONCATENATE lc_workarea lwa_dd03l-fieldname INTO lv_where_right.
            CONDENSE lv_where_left.
            CONDENSE lv_where_right.
            IF lv_where_curr IS INITIAL.
              CONCATENATE lv_where_left '=' lv_where_right INTO lv_where_curr SEPARATED BY space.
            ELSE.
              CONCATENATE '(' lv_where_curr lc_where_or lv_where_left '=' lv_where_right ')'
              INTO lv_where_curr SEPARATED BY space.
            ENDIF.
          ENDIF.

          lwa_component_w-name = lwa_dd03l-fieldname.
          lwa_component_w-type ?=  cl_abap_elemdescr=>describe_by_name( lwa_dd03l-rollname ).
          APPEND lwa_component_w TO lt_components_w.
          CLEAR lt_components_r.

          IF lv_where_curr IS NOT INITIAL.
            IF lv_where IS INITIAL.
              lv_where = lv_where_curr.
            ELSE.
              CONCATENATE lv_where lc_where_and lv_where_curr INTO lv_where SEPARATED BY space.
            ENDIF.
          ELSE.
            CONTINUE.
          ENDIF.
        ENDLOOP.
        lo_structdescr_r ?= cl_abap_structdescr=>create( lt_components_w ).
        CREATE DATA lo_data_r TYPE HANDLE lo_structdescr_r.
        ASSIGN  lo_data_r->* TO <ls_search>.
        IF <ls_search> IS ASSIGNED.
          <ls_search> = is_vake-vakey.
        ENDIF.
      ENDIF.
      IF <ls_search> IS NOT INITIAL.
        SELECT *
        FROM t683s
        INTO TABLE lt_t683s
        WHERE kschl = is_vake-kschl.
        IF sy-subrc = 0.
          SELECT rtbpn csheet
            FROM /cgdc/t_rtbpacs
            INTO TABLE lt_rtbpn
            FOR ALL ENTRIES IN lt_t683s
            WHERE csheet = lt_t683s-kalsm.
          IF sy-subrc = 0 OR ( sy-tcode = gc_tcodes-vk12 OR sy-tcode = gc_tcodes-vk11 ).
            IF ( NOT ( sy-tcode = gc_tcodes-vk12 OR sy-tcode = gc_tcodes-vk11 ) ).
              IF lt_rtbpn IS NOT INITIAL.
                CONCATENATE lv_where ` AND h~rtbpn = LT_RTBPN-RTBPN AND i~csheet = `
                `LT_RTBPN-CSHEET AND i~BUDAT GE IS_VAKE-DATAB AND i~BUDAT LE IS_VAKE-DATBI` INTO lv_where.
                SELECT i~clrno i~clrit i~clrsit i~istat bi~bstat h~rtbpn
                   FROM /cgdc/_clrqhd AS h
                   INNER JOIN /cgdc/_clrqit AS i ON i~clrno = h~clrno
                   LEFT OUTER JOIN /cgdc/_clrqbi AS bi ON i~clrno = bi~clrno AND i~rtbbinr = bi~bill_item AND i~bityp = bi~bitype
                   LEFT OUTER JOIN /cgdc/_clrqpit AS /cgdc/_clrqpit ON i~clrno = /cgdc/_clrqpit~clrno AND i~clrit = /cgdc/_clrqpit~clrit
                   INTO CORRESPONDING FIELDS OF TABLE lt_clrqhd
                   FOR ALL ENTRIES IN lt_rtbpn
                   WHERE (lv_where).
              ENDIF.
            ELSE.
              SELECT i~clrno i~clrit i~clrsit i~istat bi~bstat h~rtbpn
             FROM /cgdc/_clrqhd AS h
             INNER JOIN /cgdc/_clrqit AS i ON i~clrno = h~clrno
             LEFT OUTER JOIN /cgdc/_clrqbi AS bi ON i~clrno = bi~clrno
                              AND i~rtbbinr = bi~bill_item AND i~bityp = bi~bitype
             LEFT OUTER JOIN /cgdc/_clrqpit AS /cgdc/_clrqpit ON i~clrno = /cgdc/_clrqpit~clrno
                              AND i~clrit = /cgdc/_clrqpit~clrit
             INTO CORRESPONDING FIELDS OF TABLE lt_clrqhd
             WHERE (lv_where).
            ENDIF.

            IF lt_clrqhd IS NOT INITIAL.
              DELETE lt_clrqhd WHERE clrsit = '000000'.
              SELECT *
                FROM /cgdc/t_rtbppc
                INTO TABLE lt_rtbppc
                FOR ALL ENTRIES IN lt_clrqhd
                WHERE rtbpn = lt_clrqhd-rtbpn AND kschl = is_vake-kschl.
              LOOP AT lt_clrqhd INTO lwa_clrqhd.
                READ TABLE lt_rtbppc INTO lwa_rtbppc WITH KEY rtbpn = lwa_clrqhd-rtbpn.
                IF sy-subrc = 0.
                  READ TABLE lt_clrqpit TRANSPORTING NO FIELDS WITH KEY clrno = lwa_clrqhd-clrno
                                                                        clrit = lwa_clrqhd-clrit
                                                                        clrsit = lwa_clrqhd-clrsit.
                  IF sy-subrc <> 0 AND ( lwa_rtbppc-uclrit = gc_upd_prcess-no_update OR ( lwa_rtbppc-uclrit = gc_upd_prcess-open
                                   AND lwa_clrqhd-bstat IS NOT INITIAL )
                                   OR   ( lwa_clrqhd-bstat IS INITIAL AND
                                        ( lwa_clrqhd-istat = gc_ibill_stat-open
                                          OR lwa_clrqhd-istat = gc_ibill_stat-postponed
                                          OR lwa_clrqhd-istat = gc_ibill_stat-rejected ) ) ).
                    APPEND INITIAL LINE TO lt_clrqpit ASSIGNING <lwa_clrqpit>.
                    <lwa_clrqpit>-clrno = lwa_clrqhd-clrno.
                    <lwa_clrqpit>-clrit = lwa_clrqhd-clrit.
                    <lwa_clrqpit>-clrsit = lwa_clrqhd-clrsit.
                    <lwa_clrqpit>-action_cd = lv_rprc_code.
                    <lwa_clrqpit>-updkz = gc_updkz_new.
                  ENDIF.
                  READ TABLE lt_clrqpcn TRANSPORTING NO FIELDS WITH KEY vbeln = lwa_clrqhd-vgbel.
                  IF sy-subrc <> 0 AND lwa_rtbppc-ucont = abap_true.
                    APPEND INITIAL LINE TO lt_clrqpcn ASSIGNING <lwa_clrqpcn>.
                    <lwa_clrqpcn>-vbeln = lwa_clrqhd-vgbel.
                    <lwa_clrqpcn>-updkz = gc_updkz_new.
                  ENDIF.
                ENDIF.
              ENDLOOP.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    IF lt_clrqpcn IS NOT INITIAL OR lt_clrqpit IS NOT INITIAL.
      CALL FUNCTION '/CGDC/CLRQ_CLRQPRS_UPDATE_DB' IN UPDATE TASK
        EXPORTING
          it_clrqpit = lt_clrqpit
          it_clrqpcn = lt_clrqpcn.
    ENDIF.
  ENDIF.
ENDFUNCTION.

FUNCTION /cgdc/clrq_cost_sheet_prepare.
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Create realtime overhead document in memory
**********************************************************


*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IT_COEP) TYPE  TT_COEP
*"     REFERENCE(IT_COEP_ADD) TYPE  TT_COEP_ADD OPTIONAL
*"     REFERENCE(IT_COEP_EXT) TYPE  TT_COEP_EXT OPTIONAL
*"     REFERENCE(IV_ORIGINAL_VALDT) TYPE  CO_VALDT OPTIONAL
*"     REFERENCE(IV_ORIGINAL_BUDAT) TYPE  CO_BUDAT OPTIONAL
*"  EXPORTING
*"     REFERENCE(E_NO_RTOHC) TYPE  FLAG
*"     REFERENCE(ET_COEP) TYPE  TT_COEP
*"  CHANGING
*"     REFERENCE(CS_COBK) TYPE  COBK
*"  EXCEPTIONS
*"      VALIDATION_ERROR
*"      CALCULATION_ERROR
*"----------------------------------------------------------------------
* Calculate realtime overhead costs for a reference document and store
* in memory in preparation for call to RTOHC_OVERHEAD_POST.
  DATA: lv_rtohc_active TYPE boole,
        ls_tksvd        TYPE tksvd,
        lv_ovrhd_date   TYPE co_valdt,
        ls_tka01        TYPE tka01,
        lv_val_perio    TYPE co_perio,
        lv_val_gjahr    TYPE gjahr.

* Local Constants Declarations
  CONSTANTS: lc_orgvg_trbb TYPE co_orgvg VALUE 'TBRR', "Transaction Based Revenue Recognition
             lc_orgvg_tbcs TYPE co_orgvg VALUE 'TBCS',  "Transaction Based COGS Split
             lc_orgvg_ebwp TYPE co_orgvg VALUE 'EBWP'.  "Event Based WIP

* Clear global variables:
  CLEAR  g_max_error_severity.

* Clear export parameters:
  CLEAR: e_no_rtohc,
         et_coep.

* Check that COEP_ADD and COEP_EXT are not both supplied:
  IF  it_coep_add[] IS NOT INITIAL
  AND it_coep_ext[] IS NOT INITIAL.
    RAISE validation_error.
  ENDIF.

* loop over all items and see if there is something that we should log
  LOOP AT it_coep INTO DATA(lwa_line_item).
*   will pass if right type of order and if marked for EB posting
    IF cl_fco_msg_collector_factory=>get_common_msg_collector( )->check_eb_conditions( line_item = lwa_line_item ) = abap_true.
      cl_fco_msg_collector_factory=>get_common_msg_collector( )->set_logging_conds_flag( abap_true ).
      EXIT.
    ENDIF.
  ENDLOOP.
  IF cl_fco_msg_collector_factory=>get_common_msg_collector( )->are_logging_conditions_met( ) = abap_true AND
      cl_fco_msg_collector_factory=>get_common_msg_collector( )->is_msg_handler_set( ) = abap_false.

    cl_fco_msg_collector_factory=>get_common_msg_collector( )->set_message_handler( NEW cl_fins_co_msg_handler_util( ) ).
    TRY.
        cl_fco_msg_collector_factory=>get_common_msg_collector( )->get_msg_handler_inst( )->init_message_handler( ).
      CATCH cm_fins_t100.
    ENDTRY.
  ENDIF.

  lv_rtohc_active = abap_true.

* Keep COEP buffer per VRGNG/ORGVT/PERAB                                  "sFIN3.0
* add particular doc level due to split in posting from MIGO with >1000 lines
* (Example: Travel Expenses RMRP are reposted with RKU1
*  -> two overhead calculations in the same LUW)
  READ TABLE gt_coep_buffer ASSIGNING FIELD-SYMBOL(<ls_coep_buffer>)
       WITH TABLE KEY vrgng = cs_cobk-vrgng orgvg = cs_cobk-orgvg perab = cs_cobk-perab
                      kokrs = cs_cobk-kokrs belnr = cs_cobk-belnr.
  IF sy-subrc = 0.
    CLEAR: <ls_coep_buffer>-t_coep,
           <ls_coep_buffer>-t_coep_add.
  ELSEIF cs_cobk-orgvg = lc_orgvg_trbb OR            "Transaction Based Revenue Recognition
         cs_cobk-orgvg = lc_orgvg_tbcs OR            "Transaction Based COGS Split
         cs_cobk-orgvg = lc_orgvg_ebwp OR            "Event Based WIP
         cs_cobk-belnr_sender IS NOT INITIAL. "CFin
    e_no_rtohc = con_on.
    EXIT.
  ELSE.
    INSERT VALUE #( vrgng = cs_cobk-vrgng orgvg = cs_cobk-orgvg perab = cs_cobk-perab
                    kokrs = cs_cobk-kokrs belnr = cs_cobk-belnr )
           INTO TABLE gt_coep_buffer ASSIGNING <ls_coep_buffer>.
  ENDIF.
* Same for COIOB ...
  READ TABLE gt_coiob_buffer ASSIGNING FIELD-SYMBOL(<ls_coiob_buffer>)  "sFIN3.0
       WITH TABLE KEY vrgng = cs_cobk-vrgng orgvg = cs_cobk-orgvg perab = cs_cobk-perab
                      kokrs = cs_cobk-kokrs belnr = cs_cobk-belnr.
  IF sy-subrc = 0.
    CLEAR <ls_coiob_buffer>-t_coiob.
  ELSEIF cs_cobk-orgvg = lc_orgvg_trbb OR           "Transaction Based Revenue Recognition
         cs_cobk-orgvg = lc_orgvg_tbcs OR            "Transaction Based COGS Split
         cs_cobk-orgvg = lc_orgvg_ebwp OR            "Event Based WIP
         cs_cobk-belnr_sender IS NOT INITIAL. "CFin
    e_no_rtohc = con_on.
    EXIT.
  ELSE.
    INSERT VALUE #( vrgng = cs_cobk-vrgng orgvg = cs_cobk-orgvg perab = cs_cobk-perab
                    kokrs = cs_cobk-kokrs belnr = cs_cobk-belnr )
           INTO TABLE gt_coiob_buffer ASSIGNING <ls_coiob_buffer>.
  ENDIF.

* Determine which date is used as the basis for overhead calculations:
  CALL METHOD cl_k_ksvd_config=>profile_determine
    EXPORTING
      i_kokrs   = cs_cobk-kokrs
      i_vorgang = cs_cobk-vrgng
    IMPORTING
      e_tksvd   = ls_tksvd.
  IF sy-subrc = 0.
  ENDIF.

* If configured to use special valuation date, and this date is filled,
* use valuation date.  Otherwise use posting date.
  IF ls_tksvd-for_overhead = con_on.

* If doing a KB61 or KB65 reposting, the valuation date of the original
* allocation document is passed and we use that date.  Dates are looked
* at in the following priority sequence and the first non-blank date is used:
* - original valdt (s/b filled if called for a reposting)
* - original budat (original valdt may be empty if orig was before TKSVD activated)
* - current valdt  (normal date to use for non-reposting)
* - current budat  (in case valdt not filled for some reason)
    IF iv_original_valdt IS INITIAL.
      IF iv_original_budat IS INITIAL.
        IF cs_cobk-valdt IS INITIAL.
          lv_ovrhd_date = cs_cobk-budat.
        ELSE.
          lv_ovrhd_date = cs_cobk-valdt.
        ENDIF.
      ELSE.
        lv_ovrhd_date = iv_original_budat.
      ENDIF.
    ELSE.
      lv_ovrhd_date = iv_original_valdt.
    ENDIF.
  ELSE.
    IF iv_original_budat IS INITIAL.
      lv_ovrhd_date = cs_cobk-budat.
    ELSE.
      lv_ovrhd_date = iv_original_budat.
    ENDIF.
  ENDIF.

* Confirm that we have a non-blank date to use:
  ASSERT FIELDS cs_cobk-belnr cs_cobk-budat cs_cobk-valdt
         CONDITION NOT lv_ovrhd_date IS INITIAL.

* If overhead valuation date is different from posting date,
* determine the period that the overhead date falls in:
  IF lv_ovrhd_date = cs_cobk-budat.
    lv_val_gjahr  = cs_cobk-gjahr.
    lv_val_perio  = cs_cobk-perab.
  ELSE.
    CALL FUNCTION 'K_KOKRS_READ'
      EXPORTING
        kokrs   = cs_cobk-kokrs
      IMPORTING
        e_tka01 = ls_tka01.
    IF sy-subrc <> 0.
    ENDIF.

    CALL FUNCTION 'DATE_TO_PERIOD_CONVERT'
      EXPORTING
        i_date  = lv_ovrhd_date
        i_periv = ls_tka01-lmona
      IMPORTING
        e_buper = lv_val_perio
        e_gjahr = lv_val_gjahr.
    IF sy-subrc <> 0.
    ENDIF.
  ENDIF.

* Process each object for actual items that has a costing sheet assigned:
  IF it_coep_ext[] IS INITIAL.
    DATA(lt_coep_ext) = cl_fins_rtohc_doc=>move_coep_to_coep_ext(
      EXPORTING
        it_coep     = it_coep
        it_coep_add = it_coep_add ).
  ELSE.
    lt_coep_ext = it_coep_ext.
  ENDIF.
* Adjust for ledger-specific processing
  IF cs_cobk-ldgrp IS NOT INITIAL.
    DATA ls_coep_ext TYPE coep_ext.
    ls_coep_ext-lednr = cs_cobk-ldgrp.
    CLEAR ls_coep_ext-versn.      "Version is set in K_SURCHARGE_CALCULATE
    MODIFY lt_coep_ext FROM ls_coep_ext TRANSPORTING lednr versn WHERE lednr = '00'.
  ENDIF.

  PERFORM calculate_overhead_for_doc USING    cs_cobk
                                              lt_coep_ext
                                              lv_ovrhd_date
                                              lv_val_perio
                                     CHANGING <ls_coep_buffer>-t_coep
                                              <ls_coep_buffer>-t_coep_add.

  IF cl_fco_msg_collector_factory=>get_common_msg_collector( )->is_msg_handler_set( ) = abap_true.
    cl_fco_msg_collector_factory=>get_common_msg_collector( )->reset_and_deallocate_handler( ).
  ENDIF.

  IF g_max_error_severity > con_msg_severity-warning.
    RAISE calculation_error.
  ENDIF.

  IF <ls_coep_buffer>-t_coep IS INITIAL.
    e_no_rtohc = con_on.
    EXIT.
  ENDIF.

  IF g_max_error_severity > con_msg_severity-warning.
    RAISE validation_error.
  ENDIF.

  et_coep = <ls_coep_buffer>-t_coep.

ENDFUNCTION.

FUNCTION /cgdc/clrq_data_get.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  EXPORTING
*"     REFERENCE(ES_CLRHD) TYPE  /CGDC/S_CLRQHD
*"     REFERENCE(ES_CLRIT) TYPE  /CGDC/S_CLRQIT
*"     REFERENCE(ES_CRGRR) TYPE  /CGDC/S_CLRQGRR
*"     REFERENCE(ET_CRGRRF) TYPE  /CGDC/TT_CLRQGRRF
*"     REFERENCE(ET_CLGRP_ITM_BUFFER) TYPE  /CGDC/TT_CLRQIT
*"     REFERENCE(ET_CLGRP_CND_BUFFER) TYPE  /CGDC/TT_CLRQCN
*"     REFERENCE(ET_PBD_CONDS) TYPE  BAPIEBDRREQUESTCOND_T
*"     REFERENCE(ET_CLRQIT_GRP_CONDS) TYPE  ANY
*"     REFERENCE(ET_CRGRR_KOMV) TYPE  KOMV_TAB
*"     REFERENCE(ET_CLGRP_ITM) TYPE  /CGDC/TT_CLRQIT
*"     REFERENCE(ET_CLGRP_CND) TYPE  /CGDC/TT_CLRQCN
*"     REFERENCE(EV_CONSTR_DT) TYPE  SY-DATUM
*"     REFERENCE(ET_CLRBI) TYPE  /CGDC/TT_CLRQBI_FCAT
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Get Current header and item data
**********************************************************


  es_clrhd = gs_clrhd.
  es_clrit = gs_clrit.
  es_crgrr = gs_crgrr.
  et_crgrrf = gt_crgrrf.
  et_clgrp_itm_buffer = gt_clgrp_itm_buffer.
  et_clgrp_cnd_buffer = gt_clgrp_cnd_buffer.
  et_pbd_conds = gt_pbd_conds.
  et_crgrr_komv = gt_cgrcon_final.
  ev_constr_dt = gs_variables-rel_constr_dt.
  et_clrbi  = gt_bill_pre_data.
  "++SOC DCLM 6655 - Consider CGrp release for condition records
  " consider new Calc grp release or other relevant items
  LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING FIELD-SYMBOL(<lfs_item>)
                                     WHERE updkz = gc_updkz_new
                                     AND   clrsit <> '000000'.

    READ TABLE et_clgrp_itm WITH KEY clrno  = <lfs_item>-clrno
                                            clrit  = <lfs_item>-clrit
                                            clrsit = <lfs_item>-clrsit
                                            clrdit = <lfs_item>-clrdit
                                   TRANSPORTING NO FIELDS.
    IF sy-subrc <> 0.
      APPEND <lfs_item> TO et_clgrp_itm.

      DATA(lt_itm_cond) = VALUE /cgdc/tt_clrqcn( FOR ls_item_cond IN gs_clrqdoc_infocus-x-crcon
                                                                  WHERE ( clrit  = <lfs_item>-clrit  AND
                                                                          clrsit = <lfs_item>-clrsit AND
                                                                          clrdit = <lfs_item>-clrdit )
                                                                  ( ls_item_cond ) ).
      APPEND LINES OF lt_itm_cond TO et_clgrp_cnd.
    ENDIF.
  ENDLOOP.
  "++EOC DCLM 6655 - Consider CGrp release for condition records

ENDFUNCTION.

FUNCTION /cgdc/clrq_get_manu_itm_data.
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Fetch Manual Item Data
**********************************************************

*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IS_DATA) TYPE  ANY
*"----------------------------------------------------------------------

  MOVE-CORRESPONDING is_data TO gs_man_itm.



ENDFUNCTION.

FUNCTION /cgdc/clrq_get_ui_data.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_CLRQNO) TYPE  /CGDC/CLRQNO
*"     REFERENCE(IV_CLRIT) TYPE  /CGDC/CLRQ_ITMNO OPTIONAL
*"     REFERENCE(IV_CLRSIT) TYPE  /CGDC/CLRQ_SITMNO OPTIONAL
*"     REFERENCE(IV_PROCESS) TYPE  /CGDC/CLRQ_UIPROCESS
*"     REFERENCE(IV_FROM_TABIX) TYPE  NUMC10 OPTIONAL
*"     REFERENCE(IV_TO_TABIX) TYPE  NUMC10 OPTIONAL
*"     REFERENCE(IV_MATNR) TYPE  MATNR OPTIONAL
*"     REFERENCE(IV_SRNO) TYPE  NUMC10 OPTIONAL
*"     REFERENCE(IV_FNAME) TYPE  LVC_FNAME OPTIONAL
*"     REFERENCE(IV_CLRDIT) TYPE  /CGDC/CLRQ_DELTA_ITEM OPTIONAL
*"     REFERENCE(IV_KNUMH) TYPE  KNUMH OPTIONAL
*"     VALUE(IS_ACTION_VARIABLES) TYPE  /CGDC/S_CLRQ_ITM_ACTION_VAR
*"       OPTIONAL
*"     VALUE(IS_MAN_ITM) TYPE  /CGDC/S_CLRQIT_FCAT OPTIONAL
*"     VALUE(IV_NO_COMMIT) TYPE  FLAG OPTIONAL
*"     VALUE(IS_CREATE_MAN_BILL_ITM) TYPE  /CGDC/S_CLRQBI OPTIONAL
*"     VALUE(IS_CALC_GRR) TYPE  /CGDC/S_CLRQGRR OPTIONAL
*"  EXPORTING
*"     REFERENCE(ET_XKOMV_UI) TYPE  KOMV_UI_T
*"     REFERENCE(ET_BILL_HIST) TYPE  /CGDC/TT_CLRQ_BILL_HIST_FCAT
*"     REFERENCE(ET_CALC_ITEMS) TYPE  /CGDC/TT_CLRQIT_FCAT
*"     REFERENCE(ES_CLRQ_DOC) TYPE  /CGDC/S_CLRQ_DOC
*"     REFERENCE(ET_BILL_PRVW) TYPE  /CGDC/TT_CLRQIT_FCAT
*"     REFERENCE(ET_ITEM_VALUES) TYPE  /CGDC/TT_CLRQ_ITEMVALUES
*"     REFERENCE(ET_CALCGRP_ITEMS) TYPE  /CGDC/TT_CALC_CALCGROUP
*"     REFERENCE(ER_CALCGRP_ITEMS) TYPE REF TO  DATA
*"     REFERENCE(ET_CALCGRP_FCAT) TYPE  LVC_T_FCAT
*"     REFERENCE(ET_WBSLIST) TYPE  /CGDC/TT_CALC_WBS
*"     REFERENCE(ET_POSTPONE) TYPE  /CGDC/TT_CLRQ_POSTPONE
*"     REFERENCE(ET_MESSAGES) TYPE  /CGDC/T_MESSAGE
*"     REFERENCE(ET_CLRQGRRF) TYPE  /CGDC/TT_CLRQGRRF
*"  CHANGING
*"     VALUE(CT_ITM_POSTPONE_REJ) TYPE  /CGDC/TT_CLRQSTG OPTIONAL
*"     VALUE(CT_CALCREQ_ITM) TYPE  /CGDC/TT_CLRQIT OPTIONAL
*"     VALUE(CT_COND) TYPE  /CGDC/TT_CLRQCN OPTIONAL
*"     VALUE(CT_STAGE) TYPE  /CGDC/TT_CLRQSTG OPTIONAL
*"     VALUE(CT_ITVALUES) TYPE  /CGDC/TT_CLRQ_ITEMVALUES OPTIONAL
*"     VALUE(CT_POSTPONE) TYPE  /CGDC/TT_CLRQ_POSTPONE OPTIONAL
*"     VALUE(CT_REASSIGN_BILLITEM) TYPE  /CGDC/TT_CLRQ_REASSIGN
*"       OPTIONAL
*"     VALUE(CT_BILL) TYPE  /CGDC/TT_CLRQBIS OPTIONAL
*"     VALUE(CT_RELEASECALCGROUP) TYPE  /CGDC/TT_CLRQGRR OPTIONAL
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Get Ui Data
**********************************************************


*    Data declarations
  DATA: lt_results        TYPE komv_ui_t,
        lt_bill_hist      TYPE /cgdc/tt_clrq_bill_hist_fcat,
        lt_fcat           TYPE lvc_t_fcat,
        lt_critm_key      TYPE  /cgdc/tt_clrqit_key,
        lwa_itemkey       TYPE /cgdc/s_clrqit_key,
        lt_critm          TYPE /cgdc/tt_clrqit,
        lt_clrqno         TYPE /cgdc/tt_clrqno,
        ls_clrqno         TYPE /cgdc/s_clrqno,
        ls_row_id         TYPE lvc_s_row,
        ls_column_id      TYPE lvc_s_col,
        lt_prps           TYPE TABLE OF s_prps,
        ls_calgrp         TYPE /cgdc/s_calc_calcgroup,
        lt_komv           TYPE STANDARD TABLE OF komv,
        lt_itemkey        TYPE /cgdc/tt_clrqit_key,
        ls_man_itm        TYPE /cgdc/s_clrqit_fcat,
        ls_clrit_old      TYPE /cgdc/s_clrqit,
        lwa_postpone_fcat TYPE /cgdc/s_clrq_postpone,
        lwa_calc_req_itm  TYPE /cgdc/s_clrqit_fcat,
        lt_items          TYPE STANDARD TABLE OF /cgdc/_clrqits,
        lt_stage          TYPE STANDARD TABLE OF /cgdc/_clrqstg,
        ls_stage          TYPE /cgdc/_clrqstg,
        lt_values         TYPE STANDARD TABLE OF /cgdc/_clrqitv,
        ls_values         TYPE /cgdc/_clrqitv,
        lt_bill           TYPE STANDARD TABLE OF /cgdc/_clrqbis,
        ls_bill           TYPE /cgdc/_clrqbis,
        lt_cond           TYPE STANDARD TABLE OF /cgdc/_clrqcns,
        ls_messages       TYPE /cgdc/s_message.

  DATA: lwa_calc_req_items_api TYPE /cgdc/s_clrqit_fcat,
        ls_clrqit              TYPE /cgdc/s_clrqit,
        lv_invalid             TYPE flag,
        lv_tabname             TYPE tabname,
        lcl_clrq_util          TYPE REF TO /cgdc/cl_clrq_utility.
  DATA: ls_link_data TYPE /cgdc/s_crlink.   "Link tab update row
  CONSTANTS:lc_122             TYPE msgnr VALUE '122',
            lc_x               TYPE char1 VALUE 'X',
            lc_p               TYPE /cgdc/clrq_uiprocess VALUE 'P',    "  Pricing / Condition data
            lc_bh              TYPE /cgdc/clrq_uiprocess VALUE 'BH',   "  Billing History
            lc_bp              TYPE /cgdc/clrq_uiprocess VALUE 'BP',   "  Billing Preview
            lc_i               TYPE /cgdc/clrq_uiprocess VALUE 'I',    "  Items
            lc_edit            TYPE /cgdc/clrq_uiprocess VALUE 'EDIT', "  Edit
            lc_save            TYPE /cgdc/clrq_uiprocess VALUE 'SAVE', "  Save Calculation req data
            lc_wbs             TYPE /cgdc/clrq_uiprocess VALUE 'WBS',  "  WBS Dropdown
            lc_mn              TYPE /cgdc/clrq_uiprocess VALUE 'MN',   "  Add Manual Item
            lc_crbi            TYPE /cgdc/clrq_uiprocess VALUE 'CRBI', "  Create Manual Bill Item
            lc_rcg             TYPE /cgdc/clrq_uiprocess VALUE 'RCG',  "  Release calc. group
            lc_rb              TYPE /cgdc/clrq_uiprocess VALUE 'RB',   "  Release for billing
            lc_assn            TYPE /cgdc/clrq_uiprocess VALUE 'ASSN', "  For Assign/Reassign
            lc_fb              TYPE /cgdc/clrq_uiprocess VALUE 'FB',   "  Fast Billing Change
            lc_rr              TYPE /cgdc/clrq_uiprocess VALUE 'RR',   "  Reverse Rejection
            lc_rj              TYPE /cgdc/clrq_uiprocess VALUE 'RJ',   "  Reject
            lc_pp              TYPE /cgdc/clrq_uiprocess VALUE 'PP',   " Postpone
            lc_cg              TYPE /cgdc/clrq_uiprocess VALUE 'CG',
            lc_cp              TYPE /cgdc/clrq_uiprocess VALUE 'CP',
            lc_rs              TYPE /cgdc/clrq_uiprocess VALUE 'RS',   "  Request for billing - with scheduler
            lc_tabname_clrqstg TYPE tabname VALUE '/CGDC/_CLRQSTG',
            lc_tabname_clrqits TYPE tabname VALUE '/CGDC/_CLRQITS',
            lc_tabname_clrqbis TYPE tabname VALUE '/CGDC/_CLRQBIS',
            lc_tabname_clrqcns TYPE tabname VALUE '/CGDC/_CLRQCNS',
            lc_rsncd_rcm1      TYPE /cgdc/rtb_rsncd VALUE 'RCM1'.

  CLEAR gs_clrqdoc_infocus.
  PERFORM select_clrqhd USING ' ' iv_clrqno.
  PERFORM select_contract_data USING gs_clrqdoc_infocus-x-crhdr-vgbel.
  gs_variables-call_from_ui = abap_true.
  CASE  iv_process.

*    Condition / Pricing data
    WHEN lc_p.

      PERFORM get_price_data_ui USING  iv_clrqno iv_clrit iv_clrsit iv_clrdit CHANGING lt_results.
      et_xkomv_ui  = lt_results.

*   Billing history
    WHEN lc_bh.

      PERFORM get_bill_hist_data USING  iv_clrqno CHANGING lt_bill_hist.
      et_bill_hist = lt_bill_hist.

    WHEN lc_bp.

      gs_clrqdoc_infocus-x-crhdr-clrno =  gs_variables-selected_vbeln = iv_clrqno.
      gs_variables-key_only = lc_x.
      gs_calc_req_type-psize = 1.
      gs_variables-item_from_tabix = iv_from_tabix.
      gs_variables-item_to_tabix = iv_to_tabix.

      PERFORM prepare_field_catalog USING gc_structure-billing_items
                              CHANGING lt_fcat.
      CHECK lt_fcat IS NOT INITIAL.

      PERFORM read_bill_pre_data.
      IF gt_bill_pre_data IS NOT INITIAL .
        et_bill_prvw = CORRESPONDING #( gt_bill_pre_data ).
      ENDIF.

    WHEN lc_cp.
      CLEAR: gs_komk,
             gwa_komp.
      REFRESH gt_komv[].
      gs_variables-calc_grp_knumh = iv_knumh.
      gs_contract_hdr-vbeln = gs_clrqdoc_infocus-x-crhdr-vgbel.
      PERFORM prep_calc_grp_row_data USING abap_false
                             CHANGING lt_fcat.

      READ TABLE gs_clrqdoc_infocus-x-crgrr   INTO DATA(lwa_crgrr) WITH KEY clgrp_knumh = iv_knumh
                                                                            clgrn       = is_calc_grr-clgrn.
      IF sy-subrc EQ 0.
        gs_variables-clcgrp_indx_infocus = lwa_crgrr-rowid.
      ENDIF.
      PERFORM set_calc_grp_pricing_data.

      CALL FUNCTION 'PRICING_SUBSCREEN_GET_UI_DATA'
        EXPORTING
          is_komk     = gs_komk
          it_tkomv    = gt_komv[]
        IMPORTING
          et_xkomv_ui = lt_results
        CHANGING
          cs_komp     = gwa_komp
        EXCEPTIONS
          error       = 1
          OTHERS      = 2.
      IF sy-subrc EQ 0.
        et_xkomv_ui  = lt_results.
      ELSE.
        CLEAR ls_messages.
        ls_messages-msgid = gc_clrq_msg_cls.
        ls_messages-msgty = gc_message_type-error.
        ls_messages-msgnr = '021'.
        ls_messages-msgv1 = TEXT-110."'Error fetching pricing data'(110).
        APPEND ls_messages TO et_messages.
      ENDIF.
    WHEN lc_i OR  lc_edit.
      gt_item_postponed = CORRESPONDING #( ct_stage ).
      gs_clrqdoc_infocus-x-crhdr-clrno =  gs_variables-selected_vbeln = iv_clrqno.
      gs_variables-key_only = lc_x.
      gs_calc_req_type-psize = 1.
      gs_variables-item_from_tabix = iv_from_tabix.
      gs_variables-item_to_tabix = iv_to_tabix.


      IF iv_matnr IS NOT INITIAL.

        PERFORM prepare_field_catalog USING gc_structure-billing_items
                               CHANGING lt_fcat.
        CHECK lt_fcat IS NOT INITIAL.
        PERFORM read_bill_pre_data.
        ls_row_id-index = iv_srno.
        ls_column_id-fieldname = iv_fname.
        PERFORM on_bill_pre_hotspot_click USING ls_row_id ls_column_id.
      ELSEIF iv_clrit  IS NOT INITIAL.
        ls_clrqno-clrno =  lwa_itemkey-clrno = iv_clrqno.
        lwa_itemkey-clrit = iv_clrit.
        APPEND lwa_itemkey TO lt_itemkey.
        CLEAR gs_calc_req_type-psize.
        gs_clrqdoc_infocus-x-critm_key = lt_itemkey.
      ELSE.
        CLEAR gs_calc_req_type-psize.
        CALL METHOD /cgdc/cl_amdp_calreq_data=>get_clrq_keys
          EXPORTING
            iv_client  = sy-mandt
            iv_clrqno  = iv_clrqno
          IMPORTING
            et_itemkey = lt_itemkey.  "Giving Dump Need to IV_WHERE
        IF sy-subrc <> 0.
        ENDIF.
        SORT lt_itemkey BY clrno clrit.
        gs_clrqdoc_infocus-x-critm_key = lt_itemkey.
      ENDIF.

      gs_variables-item_from_tabix = iv_from_tabix.
      gs_variables-item_to_tabix = iv_to_tabix.
      PERFORM prep_calc_req_itms_grid_data.
      et_item_values = gt_item_values.
      et_calc_items = gt_calc_req_items_fcat.
      es_clrq_doc = gs_clrqdoc_infocus.
      et_postpone =  CORRESPONDING #( gt_item_postponed ).
    WHEN lc_cg.
      gs_contract_hdr-vbeln = gs_clrqdoc_infocus-x-crhdr-vgbel.
      PERFORM prep_calc_grp_row_data USING abap_false
                             CHANGING lt_fcat.
      ASSIGN go_calc_grp_data->* TO <gt_calc_grp_data>.

      IF <gt_calc_grp_data> IS ASSIGNED.
        GET REFERENCE OF <gt_calc_grp_data> INTO er_calcgrp_items.
        et_calcgrp_fcat[] = lt_fcat[].
        et_clrqgrrf[]     = gs_clrqdoc_infocus-x-crgrrf[].

        LOOP AT <gt_calc_grp_data> ASSIGNING FIELD-SYMBOL(<lfs_data>).

          ASSIGN COMPONENT gc_clrqbi_field-clrno OF STRUCTURE <lfs_data> TO FIELD-SYMBOL(<lfs_data1>).
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clrno = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.

          ASSIGN COMPONENT gc_fieldname-vkorg OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-vkorg = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.

          ASSIGN COMPONENT gc_calc_grp_rows_field-clgrn OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clgrn = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-clgrp_knumh OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clgrp_knumh = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-clgrp_kolnr OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clgrp_kolnr = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-clgrp_kotabnr OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clgrp_kotabnr = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-clgrp_kschl OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clgrp_kschl = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_clrit_link_field-clrit OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-clrit = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-descr OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-descr = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-datab OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-datab = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-datbi OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-datbi = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_fieldname-bsamt OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-bsamt = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_fieldname-srcam OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-srcam = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_clrqbi_field-waerk OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-waerk = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_fieldname-vbeln OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-vbeln = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_fieldname-cntit OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-/cgdc/orgi = <lfs_data1>.
            ls_calgrp-cntit = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-burd_ovr OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-burd_ovr = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-cost_base_fee OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-cost_base_fee = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-cost_excess OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-cost_excess = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-cost_funding OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-cost_funding = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-cost_plus_burdens OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-cost_plus_burdens = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-fee OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-fee = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-fee_excs OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-fee_excs = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-fee_funding OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-fee_funding = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-prev_billed_fee OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-prev_billed_fee = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-burd_cel OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-burd_cel = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-burd_poc OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-burd_poc = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          ASSIGN COMPONENT gc_calc_grp_rows_field-burd_tlt OF STRUCTURE <lfs_data> TO <lfs_data1>.
          IF <lfs_data1> IS ASSIGNED.
            ls_calgrp-burd_tlt = <lfs_data1>.
            UNASSIGN <lfs_data1>.
          ENDIF.
          APPEND ls_calgrp TO et_calcgrp_items.
          CLEAR ls_calgrp.
        ENDLOOP.

      ENDIF.
    WHEN lc_rj OR lc_pp. "Reject or Postpone

      gt_item_postponed = CORRESPONDING #( ct_stage ).

      gt_item_values = CORRESPONDING #( ct_itvalues ).
      gs_contract_hdr-vbeln = gs_clrqdoc_infocus-x-crhdr-vgbel.
      gs_variables-key_only = lc_x.

      DATA(ls_itm_pprj) = VALUE #( ct_itm_postpone_rej[ 1 ] OPTIONAL ).

      PERFORM read_contract_details USING gs_contract_hdr-vbeln.
      IF iv_clrit  IS NOT INITIAL.
        ls_clrqno-clrno =  lwa_itemkey-clrno = iv_clrqno.
        lwa_itemkey-clrit = iv_clrit.
        APPEND lwa_itemkey TO lt_itemkey.
        CLEAR gs_calc_req_type-psize.
        gs_clrqdoc_infocus-x-critm_key = lt_itemkey.
      ENDIF.

      PERFORM prep_calc_req_itms_grid_data.

      IF NOT lt_itemkey IS INITIAL.
        CALL FUNCTION '/CGDC/CLRQ_ITM_READ'
          EXPORTING
            i_clrno                = gs_clrqdoc_infocus-x-crhdr-clrno
            it_clrit               = lt_itemkey
          IMPORTING
            et_critm               = gs_clrqdoc_infocus-x-critm
          EXCEPTIONS
            reached_max_char_limit = 1.
        IF sy-subrc <> 0.
        ENDIF.

      ENDIF.

      IF gs_clrqdoc_infocus-x-critm IS NOT INITIAL.
        SELECT *
          FROM t006
          INTO TABLE @DATA(lt_t006)
           FOR ALL ENTRIES IN @gs_clrqdoc_infocus-x-critm
          WHERE msehi = @gs_clrqdoc_infocus-x-critm-zieme.

        "Copy action variables to global variable
        MOVE-CORRESPONDING is_action_variables TO gs_variables.
        LOOP AT ct_itm_postpone_rej INTO ls_itm_pprj.

          READ TABLE gs_clrqdoc_infocus-x-critm INTO DATA(ls_calcreq_itm) WITH KEY clrno = iv_clrqno
                                                                       clrit = ls_itm_pprj-clrit.
          IF sy-subrc EQ 0.
            IF ls_itm_pprj-postp_qty IS NOT INITIAL.
              DATA(lv_temp_qty) = ls_itm_pprj-postp_qty.
              READ TABLE lt_t006 INTO DATA(lwa_t006) WITH KEY msehi = ls_calcreq_itm-zieme BINARY SEARCH.
              IF sy-subrc = 0.
                CALL FUNCTION 'ROUND'
                  EXPORTING
                    decimals      = lwa_t006-decan
                    input         = ls_itm_pprj-postp_qty
*                   SIGN          = ' '
                  IMPORTING
                    output        = ls_itm_pprj-postp_qty
                  EXCEPTIONS
                    input_invalid = 1
                    overflow      = 2
                    type_invalid  = 3
                    OTHERS        = 4.
                IF sy-subrc <> 0.
                  CLEAR ls_messages.
                  ls_messages-msgid = gc_clrq_msg_cls.
                  ls_messages-msgty = gc_message_type-error.
                  ls_messages-msgnr = '021'.
                  ls_messages-msgv1 = TEXT-113."'Error while rounding quantity'(113).
                  APPEND ls_messages TO et_messages.
                  EXIT.
                ENDIF.
                DATA(lv_diff_qty) = ls_itm_pprj-postp_qty - lv_temp_qty.
              ENDIF.
            ENDIF.
          ENDIF.
          MOVE-CORRESPONDING: ls_itm_pprj TO lwa_postpone_fcat,
                              ls_calcreq_itm TO lwa_calc_req_itm.

          PERFORM create_post_rej_line3 CHANGING lwa_calc_req_itm
                                                  lwa_postpone_fcat.
          IF gs_variables-itm_post_quan IS NOT INITIAL OR gs_variables-itm_post_quan_un IS NOT INITIAL.
            lwa_postpone_fcat-postp_qty = lwa_postpone_fcat-postp_qty + lv_temp_qty.
          ENDIF.
          CLEAR lv_temp_qty.

        ENDLOOP.
      ENDIF.
      IF et_messages IS INITIAL.
        lt_items = CORRESPONDING #( gs_clrqdoc_infocus-x-critm ).
        lt_cond = CORRESPONDING #( gs_clrqdoc_infocus-x-crcon ).
        LOOP AT gt_item_values INTO DATA(ls_item_values).

          ls_values = CORRESPONDING #( ls_item_values ).
          ls_values-clrno =  iv_clrqno.
          APPEND ls_values TO lt_values.
        ENDLOOP.
        LOOP AT gt_item_postponed INTO DATA(ls_postpone).
          ls_stage = CORRESPONDING #( ls_postpone ).
          ls_stage-clrno = iv_clrqno.
          APPEND ls_stage TO lt_stage.
        ENDLOOP.

        IF iv_no_commit IS INITIAL.
*      Update staging tables
          IF lt_stage IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqstg FROM TABLE lt_stage.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = '021'.
                ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
          IF lt_items IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqits FROM TABLE lt_items.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = '021'.
                ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
          IF lt_cond IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqcns FROM TABLE lt_cond.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = '021'.
                ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
          IF lt_values IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqitv FROM TABLE lt_values.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = '021'.
                ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
        ENDIF.
      ENDIF.
    WHEN lc_rr. "Reverse Rejection
      FIELD-SYMBOLS: <lwa_critm>     TYPE /cgdc/s_clrqit,
                     <lwa_itm_value> TYPE s_item_val,
                     <ls_critm>      TYPE /cgdc/s_clrqit,
                     <lv_rtbbinr>    TYPE /cgdc/billitem_guid,
                     <lv_srvc_dt>    TYPE /cgdc/srvc_date,
                     <lv_lclrsit>    TYPE /cgdc/clrq_sitmno.
      REFRESH gt_messages.
      IF iv_clrit  IS NOT INITIAL.
        lwa_itemkey-clrno = iv_clrqno.
        lwa_itemkey-clrit = iv_clrit.
        APPEND lwa_itemkey TO lt_itemkey.
        gs_clrqdoc_infocus-x-critm_key = lt_itemkey.
      ELSEIF ct_calcreq_itm IS NOT INITIAL.
        LOOP AT ct_calcreq_itm INTO DATA(ls_rr_itm).
          CLEAR lwa_itemkey.
          lwa_itemkey-clrno = ls_rr_itm-clrno.
          lwa_itemkey-clrit = ls_rr_itm-clrit.
          APPEND lwa_itemkey TO lt_itemkey.
        ENDLOOP.
        gs_clrqdoc_infocus-x-critm_key = lt_itemkey.
      ENDIF.
      IF NOT lt_itemkey IS INITIAL.
        gs_variables-key_only = abap_true.
        gs_calc_req_type-psize = 0.
        PERFORM prep_calc_req_itms_grid_data.
      ENDIF.

      IF gs_clrqdoc_infocus-x-critm IS INITIAL.
        CALL FUNCTION '/CGDC/CLRQ_ITM_READ'
          EXPORTING
            i_clrno   = iv_clrqno
            it_clrit  = lt_itemkey
          IMPORTING
            et_critm  = gs_clrqdoc_infocus-x-critm
            et_clrqbi = gs_clrqdoc_infocus-x-crbinr.
        IF sy-subrc <> 0.
        ENDIF.

      ENDIF.
      IF NOT gs_clrqdoc_infocus-x-critm IS INITIAL.
        LOOP AT ct_calcreq_itm INTO ls_rr_itm.
          READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_critm>
          WITH KEY clrno  = ls_rr_itm-clrno
                   clrit  = ls_rr_itm-clrit
                   clrsit = ls_rr_itm-clrsit
                   clrdit = ls_rr_itm-clrdit.

          <lwa_critm>-istat = gc_ibill_stat-open.
          gs_variables-bit_num_gen = lc_x.


          READ TABLE gt_item_values ASSIGNING <lwa_itm_value>
          WITH KEY clrit = ls_rr_itm-clrit.

          IF sy-subrc = 0 .
            <lwa_itm_value>-open_quan = <lwa_itm_value>-open_quan + ls_rr_itm-zmeng.
            <lwa_itm_value>-rej_quan  = <lwa_itm_value>-rej_quan  - ls_rr_itm-zmeng.

            CLEAR <lwa_itm_value>-rej_amt.
            <lwa_itm_value>-open_amt = <lwa_itm_value>-tot_amt.

          ENDIF.

          PERFORM create_billing_item CHANGING <lwa_critm>.
          READ TABLE gs_clrqdoc_infocus-x-crbinr INTO DATA(ls_crbinr) WITH KEY clrno = iv_clrqno
                                                                     bill_item = ls_rr_itm-rtbbinr
                                                                     bitype = ls_rr_itm-bityp.
          IF sy-subrc = 0.
            ls_bill = CORRESPONDING #( ls_crbinr ).
            APPEND ls_bill TO lt_bill.
            CLEAR ls_bill.
          ENDIF.
          CLEAR gs_variables-bit_num_gen.
          IF <lwa_critm>-updkz <> gc_updkz_new.
            <lwa_critm>-updkz = gc_updkz_update.
          ENDIF.

        ENDLOOP.
        IF gt_messages IS INITIAL.
          lt_items = CORRESPONDING #( gs_clrqdoc_infocus-x-critm ).
          LOOP AT gt_item_values INTO ls_item_values.
            ls_values = CORRESPONDING #( ls_item_values ).
            ls_values-clrno =  iv_clrqno.
            APPEND ls_values TO lt_values.
          ENDLOOP.

          IF lt_items IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqits FROM TABLE lt_items.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = lc_122.
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
          IF lt_values IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqitv FROM TABLE lt_values.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = '021'.
                ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
          IF lt_bill IS NOT INITIAL.
            TRY.
                MODIFY /cgdc/_clrqbis FROM TABLE lt_bill.
              CATCH cx_sy_open_sql_db.
                CLEAR ls_messages.
                ls_messages-msgid = gc_clrq_msg_cls.
                ls_messages-msgty = gc_message_type-error.
                ls_messages-msgnr = lc_122.
                APPEND ls_messages TO et_messages.
            ENDTRY.
          ENDIF.
        ENDIF.
      ENDIF.
    WHEN lc_fb. "Fast Billing Change
      DATA: lv_changed_date  TYPE /cgdc/_clrqbi-bldat,
            lv_changed_faksp TYPE /cgdc/_clrqbi-faksp,
            lt_clrqbi        TYPE /cgdc/tt_clrqbi_db,
            lt_critm_bi      TYPE /cgdc/tt_clrqit.

      IF NOT ct_bill IS INITIAL.
        "Fetch corresponding request items info
        SELECT *
          FROM /cgdc/_clrqit
          INTO CORRESPONDING FIELDS OF TABLE @lt_critm_bi
          FOR ALL ENTRIES IN @ct_bill
          WHERE clrno   = @ct_bill-clrno
            AND rtbbinr = @ct_bill-bill_item.

        "Fetch CLRQBI Info
        SELECT *
          FROM /cgdc/_clrqbi
          FOR ALL ENTRIES IN @ct_bill
          WHERE clrno = @ct_bill-clrno
            AND bill_item = @ct_bill-bill_item
          INTO CORRESPONDING FIELDS OF TABLE @lt_clrqbi.

        LOOP AT ct_bill INTO DATA(ls_bill_fb).
          IF NOT ls_bill_fb-bldat IS INITIAL.
            lv_changed_date = ls_bill_fb-bldat.
          ENDIF.

          lv_changed_faksp = ls_bill_fb-faksp.

          READ TABLE lt_clrqbi ASSIGNING FIELD-SYMBOL(<fs_clrqbi>) WITH KEY clrno = ls_bill_fb-clrno
                                                                            bill_item = ls_bill_fb-bill_item.
          IF sy-subrc EQ 0.
            <fs_clrqbi>-bldat = lv_changed_date.
            <fs_clrqbi>-faksp = lv_changed_faksp.
            <fs_clrqbi>-updkz = gc_updkz_update.
            ls_bill = CORRESPONDING #( <fs_clrqbi> ).
            APPEND ls_bill TO lt_bill.
          ENDIF.

          LOOP AT lt_critm_bi ASSIGNING FIELD-SYMBOL(<fs_critm>) WHERE clrno   = ls_bill_fb-clrno
                                                                   AND rtbbinr = ls_bill_fb-bill_item.
            <fs_critm>-bldat_bi = lv_changed_date.
            <fs_critm>-faksp = lv_changed_faksp.
            <fs_critm>-updkz = gc_updkz_update.
          ENDLOOP.

          CLEAR: lv_changed_date,
                 lv_changed_faksp,
                 ls_bill_fb.
        ENDLOOP.

        lt_items = CORRESPONDING #( lt_critm_bi ).
        lt_bill  = CORRESPONDING #( lt_clrqbi ).

        "Update staging tables
        IF lt_items IS NOT INITIAL.
          TRY.
              MODIFY /cgdc/_clrqits FROM TABLE lt_items.
            CATCH cx_sy_open_sql_db.
              CLEAR ls_messages.
              ls_messages-msgid = gc_clrq_msg_cls.
              ls_messages-msgty = gc_message_type-error.
              ls_messages-msgnr = lc_122.
              APPEND ls_messages TO et_messages.
          ENDTRY.
        ENDIF.
        IF lt_bill IS NOT INITIAL.
          TRY.
              MODIFY /cgdc/_clrqbis FROM TABLE lt_bill.
            CATCH cx_sy_open_sql_db.
              CLEAR ls_messages.
              ls_messages-msgid = gc_clrq_msg_cls.
              ls_messages-msgty = gc_message_type-error.
              ls_messages-msgnr = lc_122.
              APPEND ls_messages TO et_messages.
          ENDTRY.
        ENDIF.
      ENDIF.

**For Assign/Reassign

    WHEN lc_assn.

      DATA(lv_clrit) = iv_clrit.        " remove it later
      IF iv_clrit  IS NOT INITIAL.
        lwa_itemkey-clrno = iv_clrqno.
        lwa_itemkey-clrit = iv_clrit.
        APPEND lwa_itemkey TO lt_itemkey.
        gs_clrqdoc_infocus-x-critm_key = lt_itemkey.
      ENDIF.

      CALL FUNCTION '/CGDC/CLRQ_ITM_READ'
        EXPORTING
          i_clrno   = gs_clrqdoc_infocus-x-crhdr-clrno
          it_clrit  = lt_itemkey
        IMPORTING
          et_critm  = gs_clrqdoc_infocus-x-critm
          et_clrqbi = gs_clrqdoc_infocus-x-crbinr.
      IF sy-subrc <> 0.
      ENDIF.

      IF ct_bill IS  NOT INITIAL.
        gs_clrqdoc_infocus-x-crbinr = CORRESPONDING #( ct_bill ).
      ENDIF.

      "Get the configuration for bill item types
      CLEAR gt_bilitty.
      SELECT * FROM /cgdc/t_bilitty
               INTO TABLE gt_bilitty.

      CLEAR:ls_itm_pprj, ls_clrqit.
      READ TABLE gs_clrqdoc_infocus-x-critm INTO ls_clrqit
                                              WITH KEY
                                              clrno  = iv_clrqno
                                              clrit  = lv_clrit
                                              clrsit = '000000'.
      IF sy-subrc EQ 0.
        MOVE-CORRESPONDING ls_clrqit TO lwa_calc_req_items_api.
      ENDIF.

      PERFORM check_clrq_authorization USING  gs_clrqdoc_infocus-x-crhdr-clrqt
                    gs_clrqdoc_infocus-x-crhdr-vkorg
                    gs_clrqdoc_infocus-x-crhdr-vtweg
                    gs_clrqdoc_infocus-x-crhdr-spart
                    gc_auth_actv-reassign_request_item
                    ''
                     CHANGING lv_invalid.
      IF lv_invalid IS NOT INITIAL.
        IF gs_variables-call_from_ui IS INITIAL.
          MESSAGE i099(/cgdc/clrq) WITH gs_clrqdoc_infocus-x-crhdr-clrqt
                                                gs_clrqdoc_infocus-x-crhdr-vkorg
                                                gs_clrqdoc_infocus-x-crhdr-vtweg
                                                gs_clrqdoc_infocus-x-crhdr-spart.
        ELSE.
          ls_messages-msgid = gc_clrq_msg_cls.
          ls_messages-msgnr = '099'.
          ls_messages-msgv1 = gs_clrqdoc_infocus-x-crhdr-clrqt.
          ls_messages-msgv2 = gs_clrqdoc_infocus-x-crhdr-vkorg.
          ls_messages-msgv3 = gs_clrqdoc_infocus-x-crhdr-vtweg.
          ls_messages-msgv4 = gs_clrqdoc_infocus-x-crhdr-spart.
          ls_messages-msgty = gc_message_type-information.
          APPEND ls_messages TO et_messages.
          CLEAR ls_messages.
        ENDIF.
        RETURN.
      ENDIF.

      IF lwa_calc_req_items_api IS NOT INITIAL.
        IF lwa_calc_req_items_api-rtbbinr IS INITIAL.       " Check CIS-AD: Billing Item GUID
**Create manual Bill Item number from API
          PERFORM create_manual_bill_item_num CHANGING lwa_calc_req_items_api.
          LOOP AT gt_messages INTO DATA(ls_msg).
            CLEAR ls_messages.
            MOVE-CORRESPONDING ls_msg TO ls_messages.
            APPEND ls_messages TO et_messages.
          ENDLOOP.
        ELSE.
**check and reassign Bill Item number from API
          PERFORM reassign_bill_item USING ct_reassign_billitem
                                     CHANGING lwa_calc_req_items_api et_messages.

        ENDIF.
        IF et_messages IS INITIAL.
          lt_items = CORRESPONDING #( gs_clrqdoc_infocus-x-critm ).
          READ TABLE gs_clrqdoc_infocus-x-crbinr INTO ls_crbinr WITH KEY clrno = iv_clrqno
                                                                         bill_item = lwa_calc_req_items_api-rtbbinr
                                                                         bitype = lwa_calc_req_items_api-bityp.
          IF sy-subrc = 0.
            ls_bill = CORRESPONDING #( ls_crbinr ).
            APPEND ls_bill TO lt_bill.
            CLEAR ls_bill.
          ENDIF.
          IF ct_stage IS NOT INITIAL.
            lt_stage = CORRESPONDING #( ct_stage ).
          ELSE.
            ls_stage-clrno = iv_clrqno.
            ls_stage-clrit = iv_clrit.
            ls_stage-assn_reassn = abap_true.
            APPEND ls_stage TO lt_stage.
            CLEAR:ls_stage.
          ENDIF.
          IF iv_no_commit IS INITIAL.
*      Update staging tables
            IF lt_stage IS NOT INITIAL.
              TRY.
                  MODIFY /cgdc/_clrqstg FROM TABLE lt_stage.
                CATCH cx_sy_open_sql_db.
                  CLEAR ls_messages.
                  ls_messages-msgid = gc_clrq_msg_cls.
                  ls_messages-msgty = gc_message_type-error.
                  ls_messages-msgnr = lc_122.                   "Error during the update of staging table &1.
                  APPEND ls_messages TO et_messages.
              ENDTRY.
            ENDIF.
            IF lt_items IS NOT INITIAL.
              TRY.
                  MODIFY /cgdc/_clrqits FROM TABLE lt_items.
                CATCH cx_sy_open_sql_db.
                  CLEAR ls_messages.
                  ls_messages-msgid = gc_clrq_msg_cls.
                  ls_messages-msgty = gc_message_type-error.
                  ls_messages-msgnr = lc_122.
                  APPEND ls_messages TO et_messages.
              ENDTRY.
            ENDIF.
            IF lt_bill IS NOT INITIAL.
              TRY.
                  MODIFY /cgdc/_clrqbis FROM TABLE lt_bill.
                CATCH cx_sy_open_sql_db.
                  CLEAR ls_messages.
                  ls_messages-msgid = gc_clrq_msg_cls.
                  ls_messages-msgty = gc_message_type-error.
                  ls_messages-msgnr = lc_122.
                  APPEND ls_messages TO et_messages.
              ENDTRY.
            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.

    WHEN lc_save.

      DATA: lt_clrq_doc TYPE  /cgdc/tt_clrq_doc,
            ls_clrq_doc TYPE /cgdc/s_clrq_doc.
      ls_clrq_doc-x-crhdr = gs_clrqdoc_infocus-x-crhdr.
      SELECT * FROM /cgdc/_clrqits INTO TABLE lt_items WHERE clrno = iv_clrqno.
      IF sy-subrc IS INITIAL.
        SELECT * FROM /cgdc/_clrqstg INTO TABLE lt_stage WHERE clrno = iv_clrqno.

        ls_clrq_doc-x-critm = CORRESPONDING #( lt_items ).

        SELECT * FROM /cgdc/_clrqbis INTO TABLE lt_bill WHERE clrno = iv_clrqno.
        IF sy-subrc = 0.
          ls_clrq_doc-x-crbinr = CORRESPONDING #( lt_bill ).
        ENDIF.

        SELECT * FROM /cgdc/_clrqcns INTO TABLE lt_cond WHERE clrno = iv_clrqno.
        IF sy-subrc IS INITIAL.
          ls_clrq_doc-x-crcon = CORRESPONDING #( lt_cond ).
        ENDIF.
        ls_clrq_doc-clrno         = iv_clrqno.
        ls_clrq_doc-x-crhdr-updkz = lc_x.
        APPEND ls_clrq_doc TO lt_clrq_doc.
      ELSE.
        "Check for manual billing item - ITS table will not have an entry in this case
        SELECT COUNT(*)
          FROM /cgdc/_clrqstg
          INTO @DATA(lv_stg_count)
          WHERE clrno = @iv_clrqno
            AND add_billitem_flag = @abap_true.
        IF sy-subrc EQ 0.
          SELECT * FROM /cgdc/_clrqstg INTO TABLE lt_stage WHERE clrno = iv_clrqno.

          SELECT * FROM /cgdc/_clrqbis INTO TABLE lt_bill WHERE clrno = iv_clrqno.
          IF sy-subrc = 0.
            ls_clrq_doc-x-crbinr = CORRESPONDING #( lt_bill ).
            ls_clrq_doc-clrno         = iv_clrqno.
            ls_clrq_doc-x-crhdr-updkz = lc_x.
            APPEND ls_clrq_doc TO lt_clrq_doc.
          ENDIF.
        ENDIF.
      ENDIF.

      CALL FUNCTION '/CGDC/CLRQ_SAVE'
        EXPORTING
          i_commit_work = abap_true
        CHANGING
          ct_clrq_doc   = lt_clrq_doc
        EXCEPTIONS
          no_change     = 1
          OTHERS        = 2.
      IF sy-subrc = 0.

        lcl_clrq_util = NEW #( ).
        lv_tabname = lc_tabname_clrqstg.

        IF NOT lt_stage IS INITIAL.
          CALL METHOD lcl_clrq_util->delete_clrq_stg_tables
            EXPORTING
              it_clrqstg          = lt_stage
            EXCEPTIONS
              tablename_not_found = 1
              OTHERS              = 2.
          IF sy-subrc <> 0.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
          ENDIF.

        ENDIF.

        IF NOT lt_items IS INITIAL.
          CALL METHOD lcl_clrq_util->delete_clrq_stg_tables
            EXPORTING
              it_clrqits          = lt_items
            EXCEPTIONS
              tablename_not_found = 1
              OTHERS              = 2.
          IF sy-subrc <> 0.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
          ENDIF.

        ENDIF.

*BOC DCLM 4700
        IF NOT lt_bill IS INITIAL.
          CALL METHOD lcl_clrq_util->delete_clrq_stg_tables
            EXPORTING
              it_clrqbis          = lt_bill
            EXCEPTIONS
              tablename_not_found = 1
              OTHERS              = 2.
          IF sy-subrc <> 0.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
          ENDIF.
        ENDIF.

        IF NOT lt_cond IS INITIAL.
          CALL METHOD lcl_clrq_util->delete_clrq_stg_tables
            EXPORTING
              it_clrqcns          = lt_cond
            EXCEPTIONS
              tablename_not_found = 1
              OTHERS              = 2.
          IF sy-subrc <> 0.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
          ENDIF.
        ENDIF.


*-Dequeue staging tables
        CALL METHOD lcl_clrq_util->dequeue_clrq_stg
          EXPORTING
            iv_table_name = lv_tabname
            iv_clrno      = iv_clrqno
          EXCEPTIONS
            OTHERS        = 3.
        IF sy-subrc <> 0.
          CLEAR ls_messages.
          ls_messages-msgid = gc_clrq_msg_cls.
          ls_messages-msgty = gc_message_type-error.
          ls_messages-msgnr = '021'.
          ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
          APPEND ls_messages TO et_messages.
        ENDIF.

        lv_tabname = lc_tabname_clrqits.
        CALL METHOD lcl_clrq_util->dequeue_clrq_stg
          EXPORTING
            iv_table_name = lv_tabname
            iv_clrno      = iv_clrqno
          EXCEPTIONS
            OTHERS        = 3.
        IF sy-subrc <> 0.
          CLEAR ls_messages.
          ls_messages-msgid = gc_clrq_msg_cls.
          ls_messages-msgty = gc_message_type-error.
          ls_messages-msgnr = '021'.
          ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
          APPEND ls_messages TO et_messages.
        ENDIF.

        lv_tabname = lc_tabname_clrqbis.
        CALL METHOD lcl_clrq_util->dequeue_clrq_stg
          EXPORTING
            iv_table_name = lv_tabname
            iv_clrno      = iv_clrqno
          EXCEPTIONS
            OTHERS        = 3.
        IF sy-subrc <> 0.
          CLEAR ls_messages.
          ls_messages-msgid = gc_clrq_msg_cls.
          ls_messages-msgty = gc_message_type-error.
          ls_messages-msgnr = '021'.
          ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
          APPEND ls_messages TO et_messages.
        ENDIF.

        lv_tabname = lc_tabname_clrqcns.
        CALL METHOD lcl_clrq_util->dequeue_clrq_stg
          EXPORTING
            iv_table_name = lv_tabname
            iv_clrno      = iv_clrqno
          EXCEPTIONS
            OTHERS        = 3.
        IF sy-subrc <> 0.
          CLEAR ls_messages.
          ls_messages-msgid = gc_clrq_msg_cls.
          ls_messages-msgty = gc_message_type-error.
          ls_messages-msgnr = '021'.
          ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
          APPEND ls_messages TO et_messages.
        ENDIF.
      ELSE.
        CLEAR ls_messages.
        ls_messages-msgid = gc_clrq_msg_cls.
        ls_messages-msgty = gc_message_type-error.
        ls_messages-msgnr = '021'.
        ls_messages-msgv1 = TEXT-112."'Error while saving the calculation request'(112).
        APPEND ls_messages TO et_messages.
      ENDIF.
**To update the condition pricing

    WHEN lc_rs. "Request billing - with scheduler
      REFRESH gt_messages.
      gs_variables-call_from_ui = abap_true.
      CALL FUNCTION '/CGDC/CLRQ_RTBC_PROCESS'
        EXPORTING
          i_vbeln         = gs_clrqdoc_infocus-x-crhdr-vgbel
          i_process       = 'S'
          i_commit_work   = abap_true
        EXCEPTIONS
          calc_req_locked = 1.
      et_messages[] = gt_messages[].

    WHEN lc_rb. "Release for billing
      REFRESH gt_messages.
      DATA lv_vbeln TYPE vbak-vbeln.
      PERFORM read_calc_request_document USING iv_clrqno
                                         CHANGING gs_clrqdoc_infocus.
      lv_vbeln = gs_clrqdoc_infocus-x-crhdr-vgbel.
      gs_variables-call_from_ui = abap_true.
      PERFORM read_contract_details USING lv_vbeln.
      CLEAR gs_calc_req_type-psize.
*      CALL METHOD /cgdc/cl_amdp_calreq_data=>get_clrq_keys
*        EXPORTING
*          iv_client  = sy-mandt
*          iv_clrqno  = iv_clrqno
*        IMPORTING
*          et_itemkey = lt_itemkey.  "Dump Need to IV_WHERE
      DATA:lwa_clrqno  TYPE /cgdc/s_clrqno.

      lwa_clrqno-clrno = iv_clrqno.
      APPEND lwa_clrqno TO lt_clrqno.

      CALL FUNCTION '/CGDC/CLRQ_READ'
        EXPORTING
          i_key_only   = abap_true
          it_clrqno    = lt_clrqno
        IMPORTING
          et_critm_key = lt_itemkey.

      IF sy-subrc <> 0.
      ENDIF.

      CALL FUNCTION '/CGDC/CLRQ_ITM_READ'
        EXPORTING
          i_clrno     = iv_clrqno
          it_clrit    = lt_itemkey
        IMPORTING
          et_critm    = gs_clrqdoc_infocus-x-critm
          et_crcon    = gs_clrqdoc_infocus-x-crcon
          et_clrqcost = gs_clrqdoc_infocus-x-crcost
          et_clrqblpl = gs_clrqdoc_infocus-x-crblpl
          et_clrqbi   = gs_clrqdoc_infocus-x-crbinr
          et_critm_ic = gs_clrqdoc_infocus-x-critm_ic
          et_cscon    = gs_clrqdoc_infocus-x-cscon.
      gs_variables-bit_num_gen = abap_false.
      CLEAR gs_variables-bit_num_gen.
      PERFORM create_ebdr USING abap_true.
      et_messages[] = gt_messages[].

    WHEN lc_rcg. "Release calc. group
      DATA: ls_komp             TYPE komp,
            lv_call_for_runtime TYPE boolean,
            ls_komv             TYPE komv.

      FIELD-SYMBOLS: <ls_crgrr> TYPE /cgdc/s_clrqgrr.
      PERFORM select_calc_group_data USING gs_clrqdoc_infocus-x-crhdr-rtbpn.
      PERFORM read_contract_items USING gs_clrqdoc_infocus-x-crhdr-vgbel.
      gs_contract_hdr-vbeln = gs_clrqdoc_infocus-x-crhdr-vgbel.
      PERFORM prep_calc_grp_row_data USING abap_false
                             CHANGING lt_fcat.

      DATA: lwa_selected_row TYPE lvc_s_row.
      LOOP AT ct_releasecalcgroup ASSIGNING FIELD-SYMBOL(<fs_rel_calc_grp>).
        lwa_selected_row-index = <fs_rel_calc_grp>-rowid.
        PERFORM release_calc_group USING abap_true "--AMISHARMA abap_false
                                 lwa_selected_row.

      ENDLOOP.
*-Update Staging tables - /cgdc/_clrqits, /cgdc/_clrqcns
      lt_items = CORRESPONDING #( gs_clrqdoc_infocus-x-critm ).
      lt_cond = CORRESPONDING #( gs_clrqdoc_infocus-x-crcon ).
      lt_bill = CORRESPONDING #( gs_clrqdoc_infocus-x-crbinr ).
      et_messages[] = gt_messages[].
      IF lt_items IS NOT INITIAL.
        TRY.
            MODIFY /cgdc/_clrqits FROM TABLE lt_items.
          CATCH cx_sy_open_sql_db.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
        ENDTRY.
      ENDIF.
      IF lt_cond IS NOT INITIAL.
        TRY.
            MODIFY /cgdc/_clrqcns FROM TABLE lt_cond.
          CATCH cx_sy_open_sql_db.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
        ENDTRY.
      ENDIF.
      IF lt_bill IS NOT INITIAL.
        TRY.
            MODIFY /cgdc/_clrqbis FROM TABLE lt_bill.
          CATCH cx_sy_open_sql_db.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = lc_122.
            APPEND ls_messages TO et_messages.
        ENDTRY.
      ENDIF.
    WHEN lc_crbi. "Create Manual Bill Item
      DATA: ls_clrqbi  TYPE /cgdc/s_clrqbi,
            ls_bilitty TYPE /cgdc/t_bilitty,
            lt_bilitty TYPE tt_bilitty,
            lr_data    TYPE REF TO data.
      FIELD-SYMBOLS: <ls_clrq> TYPE any.
      IF NOT is_create_man_bill_itm IS INITIAL.
        CLEAR ls_clrqbi.
        ls_clrqbi-updkz     = gc_updkz_new.
        ls_clrqbi-clrno     = iv_clrqno.
        ls_clrqbi-waerk     = gs_clrqdoc_infocus-x-crhdr-waerk.
        ls_clrqbi-bitype    = is_create_man_bill_itm-bitype.
        ls_clrqbi-pop_stdt  = is_create_man_bill_itm-pop_stdt.
        ls_clrqbi-pop_enddt = is_create_man_bill_itm-pop_enddt.
        ls_clrqbi-bldat     = is_create_man_bill_itm-bldat.
        ls_clrqbi-rcode     = is_create_man_bill_itm-rcode.
        ls_clrqbi-bstat     = space.
        TRY.
            cl_system_uuid=>if_system_uuid_static~create_uuid_c22(
              RECEIVING
                uuid = ls_clrqbi-bill_item ).
          CATCH cx_uuid_error INTO DATA(lo_expn).
        ENDTRY.
        ls_clrqbi-vgbel     = gs_clrqdoc_infocus-x-crhdr-vgbel.
        READ TABLE gs_clrqdoc_infocus-x-critm INTO DATA(ls_critm) WITH KEY clrno = iv_clrqno.
        IF sy-subrc EQ 0.
          ls_clrqbi-vgpos    = ls_critm-vgpos.
        ENDIF.
        SELECT * FROM /cgdc/t_bilitty
                 INTO TABLE lt_bilitty.
        IF sy-subrc EQ 0.
          CLEAR ls_bilitty.
          READ TABLE lt_bilitty INTO ls_bilitty
                                WITH KEY bilitmtyp = is_create_man_bill_itm-bitype.
          IF sy-subrc EQ 0.
            ls_clrqbi-bilmatnr = ls_bilitty-bilmatnr.
            ls_clrqbi-fkrel    = ls_bilitty-fkrel.
          ENDIF.
        ENDIF.

        APPEND ls_clrqbi TO gs_clrqdoc_infocus-x-crbinr.

        ls_bill = CORRESPONDING #( ls_clrqbi ).
        APPEND ls_bill TO lt_bill.
        CLEAR ls_bill.
      ENDIF.

*      Update staging tables
      IF lt_bill IS NOT INITIAL.
        TRY.
            MODIFY /cgdc/_clrqbis FROM TABLE lt_bill.
          CATCH cx_sy_open_sql_db.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
        ENDTRY.

        ls_stage-clrno = iv_clrqno.
        TRY.
            cl_system_uuid=>if_system_uuid_static~create_uuid_c22(
              RECEIVING
                uuid = ls_stage-clrit ).
          CATCH cx_uuid_error INTO lo_expn.
        ENDTRY.
        ls_stage-add_billitem_flag = abap_true.
        APPEND ls_stage TO lt_stage.
        CLEAR:ls_stage.

        IF lt_stage IS NOT INITIAL.
          TRY.
              MODIFY /cgdc/_clrqstg FROM TABLE lt_stage.
            CATCH cx_sy_open_sql_db.
              CLEAR ls_messages.
              ls_messages-msgid = gc_clrq_msg_cls.
              ls_messages-msgty = gc_message_type-error.
              ls_messages-msgnr = '021'.
              ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
              APPEND ls_messages TO et_messages.
          ENDTRY.
        ENDIF.
      ELSE.
        CLEAR ls_messages.
        ls_messages-msgid = gc_clrq_msg_cls.
        ls_messages-msgty = gc_message_type-error.
        ls_messages-msgnr = '021'.
        ls_messages-msgv1 = TEXT-131."'Error adding the bill item'.
        APPEND ls_messages TO et_messages.
      ENDIF.

    WHEN lc_mn. "Add Manual Item

      ls_man_itm = CORRESPONDING #( is_man_itm ).
      IF ls_man_itm-matnr IS NOT INITIAL
        AND ls_man_itm-fkdat IS NOT INITIAL
        AND ls_man_itm-kwmeng IS NOT INITIAL
        AND ls_man_itm-vrkme IS NOT INITIAL
        AND ls_man_itm-waerk IS NOT  INITIAL
        AND ls_man_itm-ps_psp_pnr IS NOT INITIAL
        AND ls_man_itm-kbetr1 IS NOT INITIAL
        AND ls_man_itm-mityp IS NOT INITIAL.
        IF ls_man_itm-rsncd IS INITIAL.
          ls_man_itm-rsncd = lc_rsncd_rcm1.
        ENDIF.
        ls_man_itm-itmty = gc_clrq_itmty-manual_line.
        ls_man_itm-budat = ls_man_itm-fkdat.

        PERFORM update_clrq_item01 USING space
                                          ls_link_data
                                           ls_clrit_old
                                       CHANGING ls_man_itm.
      ENDIF.

      lt_items = CORRESPONDING #( gs_clrqdoc_infocus-x-critm ).
      lt_cond = CORRESPONDING #( gs_clrqdoc_infocus-x-crcon ).
*      Update staging tables
      IF lt_items IS NOT INITIAL.
        TRY.
            MODIFY /cgdc/_clrqits FROM TABLE lt_items.
          CATCH cx_sy_open_sql_db.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
        ENDTRY.
      ENDIF.
      IF lt_cond IS NOT INITIAL.
        TRY.
            MODIFY /cgdc/_clrqcns FROM TABLE lt_cond.
          CATCH cx_sy_open_sql_db.
            CLEAR ls_messages.
            ls_messages-msgid = gc_clrq_msg_cls.
            ls_messages-msgty = gc_message_type-error.
            ls_messages-msgnr = '021'.
            ls_messages-msgv1 = TEXT-111."'Error during staging table update'(111).
            APPEND ls_messages TO et_messages.
        ENDTRY.
      ENDIF.

    WHEN lc_wbs. "WBS Dropdown
      SELECT * FROM vbap INTO TABLE @gt_contract_itm WHERE vbeln = @gs_clrqdoc_infocus-x-crhdr-vgbel.
      PERFORM select_prps CHANGING lt_prps.
      DELETE lt_prps WHERE fakkz IS INITIAL.
      et_wbslist = CORRESPONDING #( lt_prps ).
  ENDCASE.

ENDFUNCTION.

FUNCTION /cgdc/clrq_price_chng_key_upd.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(KOMG_OLD) TYPE  KOMG
*"     REFERENCE(KOMG_NEW) TYPE  KOMG
*"     REFERENCE(VAKE_OLD) TYPE  VAKE
*"     REFERENCE(VAKE_NEW) TYPE  VAKE
*"  EXPORTING
*"     REFERENCE(TRANSITION_FORBIDDEN) TYPE  XFELD
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Contract Reprice Process
**********************************************************

  TYPES: BEGIN OF lty_clrqhd,
           clrno  TYPE /cgdc/clrqno,
           clrit  TYPE /cgdc/clrq_itmno,
           clrsit TYPE /cgdc/clrq_sitmno,
           bstat  TYPE /cgdc/clrqi_billstat,
           istat  TYPE /cgdc/clrqi_istat,
           rtbpn  TYPE /cgdc/rtbpn,
           vgbel  TYPE vbeln_va,
         END OF lty_clrqhd.
  TYPES: BEGIN OF s_wherefields,
           fieldname TYPE fieldname,
         END OF s_wherefields.

  TYPES : BEGIN OF t_rtbpn,
            rtbpn TYPE /cgdc/rtbpn,
          END OF t_rtbpn.
  DATA: lt_wherefield TYPE TABLE OF s_wherefields.
  FIELD-SYMBOLS <lwa_field> TYPE s_wherefields.
  DATA lt_clrno_r TYPE RANGE OF /cgdc/_clrqit-clrno.


  DATA: lv_tabname      TYPE tabname,
        lv_fieldname    TYPE fieldname,
        lt_dd03l        TYPE TABLE OF dd03l,
        lt_dd03l_h      TYPE TABLE OF dd03l,
        lt_dd03l_i      TYPE TABLE OF dd03l,
        lwa_dd03l       TYPE  dd03l,
        lwa_dd03l_h     TYPE  dd03l,
        lwa_dd03l_i     TYPE  dd03l,
        lt_fieldname_r  TYPE RANGE OF fieldname,
        lwa_fieldname_r LIKE LINE OF lt_fieldname_r.
  DATA: lv_h_fieldame TYPE fieldname.

  DATA: lt_components_r TYPE abap_component_tab,
        lwa_component_r TYPE LINE OF abap_component_tab,
        lt_components_w TYPE abap_component_tab,
        lwa_component_w TYPE LINE OF abap_component_tab.

  DATA: lo_tabledescr_r  TYPE REF TO cl_abap_tabledescr,
        lo_structdescr_r TYPE REF TO cl_abap_structdescr,
        lo_datadescr_r   TYPE REF TO cl_abap_datadescr,
        lo_typedescr_r   TYPE REF TO cl_abap_typedescr,
        lo_data_r        TYPE REF TO data,
        lo_data_w        TYPE REF TO data,
        lo_data          TYPE REF TO data.
  DATA : lv_where TYPE string.
  DATA : lv_where_curr TYPE string.
  DATA : lv_where_left TYPE string.
  DATA : lv_where_right TYPE string.
  DATA: lt_clrqhd  TYPE TABLE OF lty_clrqhd,
        lwa_clrqhd TYPE lty_clrqhd.
  DATA : lt_clrqpit TYPE TABLE OF /cgdc/s_clrqpit.
  DATA : lt_clrqpcn TYPE TABLE OF /cgdc/s_clrqpcn.
  DATA: lwa_rtbppc TYPE /cgdc/t_rtbppc.
  DATA: lt_rtbppc TYPE TABLE OF /cgdc/t_rtbppc.
  DATA: lv_append TYPE flag.
  DATA: lv_open TYPE flag.


  DATA : lt_t683s  TYPE TABLE OF t683s,
         lwa_t683s TYPE t683s.
  DATA : lt_rtbpn  TYPE TABLE OF t_rtbpn,
         lwa_rtbpn TYPE t_rtbpn.


  FIELD-SYMBOLS <lt_tab_r> TYPE table.
  FIELD-SYMBOLS <ls_search> TYPE any.
  FIELD-SYMBOLS <lt_data> TYPE table.
  FIELD-SYMBOLS <lwa_data> TYPE any.
  FIELD-SYMBOLS <lt_range> TYPE table.
  FIELD-SYMBOLS <lwa_range> TYPE any.
  FIELD-SYMBOLS <lv_value> TYPE any.
  FIELD-SYMBOLS <lv_data_value> TYPE any.
  FIELD-SYMBOLS <lwa_clrqpit> TYPE /cgdc/s_clrqpit.
  FIELD-SYMBOLS <lwa_clrqpcn> TYPE /cgdc/s_clrqpcn.

*Local Constants Declarations
  CONSTANTS: lc_workarea    TYPE char12 VALUE '<LS_SEARCH>-',
             lc_ucomm_sich  TYPE sy-ucomm  VALUE 'SICH',
             lc_fname_mandt TYPE fieldname VALUE 'MANDT',
             lc_fname_kappl TYPE fieldname VALUE 'KAPPL',
             lc_fname_kschl TYPE fieldname VALUE 'KSCHL',
             lc_fname_kfrst TYPE fieldname VALUE 'KFRST',
             lc_fname_datbi TYPE fieldname VALUE 'DATBI',
             lc_fname_vbeln TYPE fieldname VALUE 'VBELN',
             lc_fname_knumh TYPE fieldname VALUE 'KNUMH',
             lc_fname_vgbel TYPE fieldname VALUE 'VGBEL',
             lc_where_and   TYPE char03    VALUE 'AND',
             lc_where_or    TYPE char02    VALUE 'OR',
             lc_cnd_vk      TYPE char03    VALUE 'VK*'.
*******************************************************************************************************************

  IF  sy-ucomm = lc_ucomm_sich.
    CONCATENATE gc_kvewe-pricing vake_new-kotabnr INTO lv_tabname.
    CONDENSE lv_tabname.
    CREATE DATA lo_data TYPE TABLE OF (lv_tabname).
    ASSIGN lo_data->* TO <lt_data>.

    SELECT *
      FROM dd03l
      INTO TABLE lt_dd03l
      WHERE tabname = lv_tabname
      OR tabname = gc_header_tabname
      OR tabname = gc_item_tabname.
    IF sy-subrc = 0.
      lt_dd03l_h = lt_dd03l[].
      lt_dd03l_i = lt_dd03l[].
      DELETE lt_dd03l WHERE tabname <> lv_tabname.
      DELETE lt_dd03l_h WHERE tabname <> gc_header_tabname.
      DELETE lt_dd03l_i WHERE tabname <> gc_item_tabname.

      lwa_fieldname_r-option = gc_operator-equal.
      lwa_fieldname_r-sign = gc_range_tbl_sign-include.

      lwa_fieldname_r-low = lc_fname_mandt.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_kappl.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_kschl.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_kfrst.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_datbi.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      lwa_fieldname_r-low = lc_fname_knumh.
      APPEND lwa_fieldname_r TO lt_fieldname_r.

      DELETE lt_dd03l WHERE fieldname IN lt_fieldname_r OR keyflag IS INITIAL.
      SORT lt_dd03l BY position.
      IF lt_dd03l IS NOT INITIAL.
        LOOP AT lt_dd03l INTO lwa_dd03l.
          CLEAR: lv_where_curr,
                 lv_h_fieldame.
          IF lwa_dd03l-fieldname = lc_fname_vbeln.
            lv_h_fieldame = lc_fname_vgbel.
          ELSE.
            lv_h_fieldame = lwa_dd03l-fieldname.
          ENDIF.
          READ TABLE lt_dd03l_h INTO lwa_dd03l_h WITH KEY fieldname = lv_h_fieldame.
          IF sy-subrc = 0.
            CONCATENATE 'h' '~' lwa_dd03l_h-fieldname INTO lv_where_left.
            CONCATENATE lc_workarea lwa_dd03l-fieldname INTO lv_where_right.
            CONDENSE lv_where_left.
            CONDENSE lv_where_right.
            CONCATENATE lv_where_left '=' lv_where_right INTO lv_where_curr SEPARATED BY space.
          ENDIF.
          .
          READ TABLE lt_dd03l_i INTO lwa_dd03l_i WITH KEY fieldname = lwa_dd03l-fieldname.
          IF sy-subrc = 0.
            CONCATENATE 'i' '~' lwa_dd03l_i-fieldname INTO lv_where_left.
            CONCATENATE lc_workarea lwa_dd03l-fieldname INTO lv_where_right.
            CONDENSE lv_where_left.
            CONDENSE lv_where_right.
            IF lv_where_curr IS INITIAL.
              CONCATENATE lv_where_left '=' lv_where_right INTO lv_where_curr SEPARATED BY space.
            ELSE.
              CONCATENATE '(' lv_where_curr lc_where_or lv_where_left '=' lv_where_right ')' INTO lv_where_curr SEPARATED BY space.
            ENDIF.
          ENDIF.

          lwa_component_w-name = lwa_dd03l-fieldname.
          lwa_component_w-type ?=  cl_abap_elemdescr=>describe_by_name( lwa_dd03l-rollname ).
          APPEND lwa_component_w TO lt_components_w.
          CLEAR lt_components_r.

          IF lv_where_curr IS NOT INITIAL.
            IF lv_where IS INITIAL.
              lv_where = lv_where_curr.
            ELSE.
              CONCATENATE lv_where lc_where_and lv_where_curr INTO lv_where SEPARATED BY space.
            ENDIF.
          ELSE.
            CONTINUE.
          ENDIF.
        ENDLOOP.
        lo_structdescr_r ?= cl_abap_structdescr=>create( lt_components_w ).
        CREATE DATA lo_data_r TYPE HANDLE lo_structdescr_r.
        ASSIGN  lo_data_r->* TO <ls_search>.
        IF <ls_search> IS ASSIGNED.
          <ls_search> = vake_new-vakey.
        ENDIF.

        IF <ls_search> IS NOT INITIAL.
          IF sy-tcode CP lc_cnd_vk.
            SELECT i~clrno i~clrit i~clrsit i~istat bi~bstat h~rtbpn
              FROM /cgdc/_clrqhd AS h
              INNER JOIN /cgdc/_clrqit AS i ON i~clrno = h~clrno
              LEFT OUTER JOIN /cgdc/_clrqbi AS bi ON i~clrno = bi~clrno AND i~rtbbinr = bi~bill_item AND i~bityp = bi~bitype
              LEFT OUTER JOIN /cgdc/_clrqpit AS /cgdc/_clrqpit ON i~clrno = /cgdc/_clrqpit~clrno AND i~clrit = /cgdc/_clrqpit~clrit
              INTO CORRESPONDING FIELDS OF TABLE lt_clrqhd
              WHERE (lv_where).

            IF sy-subrc = 0.
              READ TABLE lt_clrqhd INTO lwa_clrqhd INDEX 1.
              SELECT  SINGLE *
                FROM /cgdc/t_rtbppc
                INTO lwa_rtbppc
                WHERE rtbpn = lwa_clrqhd-rtbpn
                AND kschl = vake_new-kschl.
              IF sy-subrc = 0.
                SORT lt_clrqhd BY clrit clrsit.
                DELETE lt_clrqhd WHERE clrsit = '000000'.
                LOOP AT lt_clrqhd INTO lwa_clrqhd.
                  AT NEW clrsit.
                    CLEAR : lv_append,
                             lv_open.
                  ENDAT.
                  IF lwa_rtbppc-uclrit = gc_upd_prcess-no_update.
                    lv_append = abap_true.
                    CONTINUE.
                  ELSEIF lwa_rtbppc-uclrit = gc_upd_prcess-open AND lwa_clrqhd-bstat IS NOT INITIAL.
                    lv_append = abap_true.
                    CONTINUE.
                  ENDIF.
                  IF lwa_clrqhd-istat = gc_ibill_stat-open OR lwa_clrqhd-istat = gc_ibill_stat-postponed OR lwa_clrqhd-istat = gc_ibill_stat-rejected. "Only Add Open Items
                    lv_open = abap_true.
                  ENDIF.
                  AT END OF clrsit.
                    IF lv_append IS INITIAL AND lv_open IS NOT INITIAL.
                      APPEND INITIAL LINE TO lt_clrqpit ASSIGNING <lwa_clrqpit>.
                      <lwa_clrqpit>-clrno = lwa_clrqhd-clrno.
                      <lwa_clrqpit>-clrit = lwa_clrqhd-clrit.
                      <lwa_clrqpit>-clrsit = lwa_clrqhd-clrsit.
                      <lwa_clrqpit>-updkz = gc_updkz_new.
                    ENDIF.
                  ENDAT.
                ENDLOOP.
              ENDIF.
            ENDIF.
            IF lwa_rtbppc-ucont = abap_true.
              SELECT h~vgbel AS vbeln
                FROM /cgdc/_clrqhd AS h
                LEFT OUTER JOIN /cgdc/_clrqpcn AS /cgdc/_clrqpcn ON h~vgbel = /cgdc/_clrqpcn~vbeln
                INTO CORRESPONDING FIELDS OF TABLE lt_clrqpcn
                WHERE h~vgbel = komg_new-vbeln.
              IF sy-subrc = 0.
                LOOP AT lt_clrqpcn ASSIGNING <lwa_clrqpcn>.
                  <lwa_clrqpcn>-updkz = gc_updkz_new.
                ENDLOOP.
              ENDIF.

            ENDIF.
          ENDIF.
        ENDIF.
      ENDIF.
    ENDIF.
    CALL FUNCTION '/CGDC/CLRQ_CLRQPRS_UPDATE_DB' IN UPDATE TASK
      EXPORTING
        it_clrqpit = lt_clrqpit
        it_clrqpcn = lt_clrqpcn.
    IF sy-subrc <> 0.
    ENDIF.
  ENDIF.
ENDFUNCTION.


FUNCTION /cgdc/clrq_process.
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Process Calculation Request
**********************************************************

*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(I_ACTION) TYPE  CHAR2
*"     REFERENCE(I_VALUE) TYPE  /CGDC/CLRQNO OPTIONAL
*"  CHANGING
*"     REFERENCE(CS_VBAK) TYPE  VBAKKOM OPTIONAL
*"----------------------------------------------------------------------
  DATA: lt_clrq_doc TYPE /cgdc/tt_clrq_doc,
        lt_clrqno   TYPE /cgdc/tt_clrqno,
        lwa_search_calc_req TYPE /cgdc/s_clrq_wl,
        lwa_calc_req_type_text TYPE /cgdc/t_clrtypet,
        lwa_clrqno  TYPE /cgdc/s_clrqno.

  gs_variables-external_call = abap_true.

  CASE i_action.
    WHEN gc_actions-navigation_to_calc_req.
      IF gs_clrqdoc_infocus IS NOT INITIAL.
        CLEAR:gs_clrqdoc_infocus,
        gt_search_calc_req,
        gt_wl_calc_req.
      ENDIF.
      IF NOT i_value IS INITIAL.

        IF gs_clrqdoc_infocus IS INITIAL.
          CLEAR gs_variables-worklist_is_visible.
          gs_variables-overview_mode = gc_mode_display.
          gs_variables-document_mode = gc_mode_display.
          PERFORM set_calc_request_doc_infocus USING i_value.

          IF  NOT gs_clrqdoc_infocus-x-crhdr IS INITIAL.

            MOVE-CORRESPONDING gs_clrqdoc_infocus-x-crhdr to lwa_search_calc_req.
              IF gt_calc_req_type_text IS INITIAL.
                PERFORM select_calc_req_type_txt.
              ENDIF.

            READ TABLE gt_calc_req_type_text
            INTO lwa_calc_req_type_text
            WITH KEY clrqt = lwa_search_calc_req-clrqt.

            IF sy-subrc EQ 0.
              lwa_search_calc_req-cttxt = lwa_calc_req_type_text-descr.
            endif.
            APPEND lwa_search_calc_req to gt_search_calc_req.
            APPEND lwa_search_calc_req to gt_wl_calc_req.
            CALL SCREEN 100.
          ENDIF.

        ENDIF.

      ENDIF.

      CLEAR: gs_variables-external_call, gs_variables-external_fcode.

    WHEN gc_actions-set_calc_req_no_in_dmr.

    WHEN OTHERS.
  ENDCASE.

ENDFUNCTION.

**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2025] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-231COINCGDC (CIS-AD S/4 Hana 2023)
*
* DESCRIPTION: Calculation Request Reprice Update
**********************************************************
FUNCTION /cgdc/clrq_reprice_update.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_RP_FLAG) TYPE  CHAR1
*"     REFERENCE(I_VBELN) TYPE  VBELN_VA
*"     REFERENCE(IS_PARALLEL_PROCESS) TYPE  /CGDC/S_PARALLEL_PROCESS
*"     REFERENCE(IT_RTBCLNMS) TYPE  /CGDC/TT_RTBCLNMCS OPTIONAL
*"     REFERENCE(IT_RTBWBSMCS) TYPE  /CGDC/TT_WBSMCS OPTIONAL
*"  EXPORTING
*"     REFERENCE(ET_RETURN) TYPE  /CGDC/T_MESSAGE
*"----------------------------------------------------------------------

  DATA : lt_clritkey      TYPE TABLE OF /cgdc/s_clrqit_key,
         lt_clritkey_t    TYPE TABLE OF /cgdc/s_clrqit_key,
         lt_clritkey_temp TYPE TABLE OF /cgdc/s_clrqit_key,
         lwa_clritkey     TYPE /cgdc/s_clrqit_key.
  DATA : lwa_clrqhd TYPE /cgdc/s_clrqhd.
  DATA: lwa_clrq_itm_new TYPE /cgdc/s_clrqit_fcat.
  DATA: lwa_clrq_itm_new2 TYPE /cgdc/s_clrqit_fcat.
  DATA: lt_clrqit TYPE TABLE OF /cgdc/s_clrqit.
  DATA: lt_clrqit_last_billed TYPE TABLE OF /cgdc/s_clrqit.

  DATA: lt_clrqit_it TYPE TABLE OF /cgdc/s_clrqit.
  DATA: lwa_clrqit TYPE /cgdc/s_clrqit.
  DATA: lwa_critm2 TYPE /cgdc/s_clrqit.
  DATA: lt_rtbppc_swap TYPE TABLE OF /cgdc/t_rtbppc.
  DATA: lwa_clrqpit TYPE /cgdc/s_clrqpit,
        lt_clrqpit  TYPE TABLE OF /cgdc/s_clrqpit.

  DATA: lt_clrqcost TYPE TABLE OF /cgdc/s_clrqcost.
  DATA: lt_crptr TYPE TABLE OF /cgdc/s_clrqpt.
  DATA: lwa_item_old TYPE /cgdc/s_clrqit.

  DATA: lt_dd03l_it TYPE TABLE OF dd03l,
        lt_dd03l_cn TYPE TABLE OF dd03l,
        lwa_dd03l   TYPE dd03l.
  DATA: lt_crcon TYPE TABLE OF /cgdc/_clrqcn.
  DATA: lwa_crcon         TYPE  /cgdc/_clrqcn,
        lwa_crcon_delta   TYPE  /cgdc/_clrqcn,
        lwa_crcon_new     TYPE  /cgdc/_clrqcn,

        lwa_crconcs_delta TYPE  /cgdc/_clrqcscn,
        lwa_crconcs_new   TYPE  /cgdc/_clrqcscn,
        lwa_crconcs_new_t TYPE  /cgdc/_clrqcscn,
        lwa_crcon_new_t   TYPE  /cgdc/_clrqcn,
        lt_coep_ori       TYPE  /cgdc/tt_coep_ori,
        ls_coep_ori       TYPE  /cgdc/s_coep_ori,
        ls_clrqit         TYPE  /cgdc/s_clrqit,
        ls_clrqbi         TYPE  /cgdc/s_clrqbi,
        ls_clrqdoc        TYPE  /cgdc/s_clrq_doc.

  FIELD-SYMBOLS : <lwa_wa1> TYPE any,
                  <lwa_wa2> TYPE any,
                  <lv_val1> TYPE any,
                  <lv_val2> TYPE any,
                  <lv_val3> TYPE any.

  FIELD-SYMBOLS : <lwa_clrit_sub>          TYPE /cgdc/s_clrqit.
  FIELD-SYMBOLS : <lwa_clrit_item>         TYPE /cgdc/s_clrqit.
  FIELD-SYMBOLS : <lwa_clrit_delta>        TYPE /cgdc/s_clrqit.
  FIELD-SYMBOLS : <lwa_clrcn_old>          TYPE /cgdc/s_clrqcn.
  FIELD-SYMBOLS : <lwa_clrcn_delta>        TYPE /cgdc/s_clrqcn.
  FIELD-SYMBOLS : <lwa_crcon_copied>       TYPE /cgdc/s_clrqcn.
  FIELD-SYMBOLS : <lwa_crconcs_copied>       TYPE /cgdc/s_clrqcscn.
  FIELD-SYMBOLS : <lwa_critm_copied>       TYPE /cgdc/s_clrqit.
  FIELD-SYMBOLS : <lwa_clrqit_last_copied> TYPE /cgdc/s_clrqit.
  FIELD-SYMBOLS : <lwa_clrqbi>             TYPE /cgdc/s_clrqbi.
  DATA: lwa_clrqpcn TYPE  /cgdc/_clrqpcn.
  DATA: lt_clrno TYPE TABLE OF /cgdc/s_clrqno.
  DATA: lwa_clrno TYPE /cgdc/s_clrqno.
  DATA: lwa_return TYPE /cgdc/s_message."bapiret2.
  DATA: lv_lock TYPE sysubrc.
  DATA: lt_clrqdoc TYPE TABLE OF /cgdc/s_clrq_doc.
  DATA lwa_rtbp TYPE /cgdc/t_rtbp.
  DATA: lv_one_qty_amt TYPE netwr_ap.
  DATA: lv_copied_item_line    TYPE i,
        lv_no_attempt          TYPE num4,
        lv_max_attempt_failure TYPE c,
        lv_row_count           TYPE sy-tabix.
  DATA: lt_crcon_copied_c TYPE /cgdc/tt_clrqcn,
        lt_crcon_copied   TYPE /cgdc/tt_clrqcn,
        lt_crcon_copied_t TYPE /cgdc/tt_clrqcn.
  DATA: lt_clrqcs_copied_c TYPE /cgdc/tt_clrqcscn,
        lt_clrqcs_copied   TYPE /cgdc/tt_clrqcscn,
        lt_clrqcs_copied_t TYPE /cgdc/tt_clrqcscn.
  DATA: lwa_last_billed TYPE /cgdc/s_clrqit.
  DATA: lwa_crbinr TYPE /cgdc/s_clrqbi.
  DATA: lv_invalid TYPE flag.
  DATA : lt_clrqpit_key TYPE TABLE OF /cgdc/_clrqpit.
  DATA : lt_clrqpit_temp TYPE TABLE OF /cgdc/_clrqpit.
  DATA : lwa_clrqpit_key TYPE /cgdc/_clrqpit,
         lwa_clrqpit_new TYPE /cgdc/_clrqpit.
  DATA: lwa_clnmcs  TYPE /cgdc/s_rtbclnmcs.
  DATA: lv_action_cd TYPE /cgdc/rtb_rprc_actn_code.
  DATA: lt_prps      TYPE TABLE OF prps,
        lwa_prps     TYPE prps,
        lwa_wbsmcs   TYPE /cgdc/s_wbsmcs,
        lv_actvty_r3 TYPE activ_auth VALUE 'R3'.
*******************************************************

  gs_variables-collect_message = abap_true.
  gt_rtbclnmcs = it_rtbclnms[].
  gt_rtbwbsmcs = it_rtbwbsmcs[].
  IF it_rtbwbsmcs IS NOT INITIAL.
    SELECT *
      FROM prps
      INTO TABLE lt_prps
      FOR ALL ENTRIES IN it_rtbwbsmcs
      WHERE objnr = it_rtbwbsmcs-objnr.
  ENDIF.
  SELECT clrno
    FROM /cgdc/_clrqhd
    INTO TABLE lt_clrno
    WHERE vgbel = i_vbeln.
*  IF sy-subrc = 0.
*    TRY.
*        SELECT c~* FROM
*             v_coep_ori AS c INNER JOIN /cgdc/_clrqcost AS s
*             ON    c~belnr = s~cbelnr
*             AND   c~buzei = s~cbuzei
*             AND   c~gjahr = s~cgjahr
*             AND   c~bukrs = s~crbukrs
*             INTO CORRESPONDING FIELDS OF TABLE @gt_coep
*             FOR ALL ENTRIES IN @lt_clrno
*             WHERE s~clrno = @lt_clrno-clrno.
*        IF  sy-subrc = 0.
*          SORT gt_coep.
*        ENDIF.
*      CATCH cx_sy_open_sql_db.
*
*    ENDTRY.
*
*  ENDIF. "Instead Of COEP KBETR now onwards CLRQIT-KBETR1 will be used

  "SOC - Multipayer Scenario - select additional cost collectors for repricing
  PERFORM select_add_cost_collectors.
  "EOC - Multipayer Scenario - select additional cost collectors for repricing

  IF iv_rp_flag IS INITIAL.
    SELECT *
      FROM /cgdc/_clrqpit
      INTO TABLE lt_clrqpit_key
      FOR ALL ENTRIES IN lt_clrno
      WHERE clrno = lt_clrno-clrno.
    IF sy-subrc = 0 OR gt_clrqpit[] IS NOT INITIAL.
      IF lt_clrqpit_key[] IS INITIAL.
        lt_clrqpit_key[] = CORRESPONDING #( gt_clrqpit[] ).
        CLEAR ls_clrqdoc.
        ls_clrqdoc = gs_clrqdoc_infocus.
      ELSE.
        REFRESH gt_clrqpit[].
      ENDIF.
      gs_variables-overview_mode = gc_mode_change.
      LOOP AT lt_clrno INTO lwa_clrno.
        CLEAR : gs_clrqdoc_infocus,
                lt_clritkey_t.
        LOOP AT lt_clrqpit_key INTO lwa_clrqpit_key WHERE clrno = lwa_clrno-clrno.
          MOVE-CORRESPONDING lwa_clrqpit_key TO lwa_clritkey.
          APPEND lwa_clritkey TO lt_clritkey_t.
        ENDLOOP.
        PERFORM set_calc_req_item_doc_infocus USING lt_clritkey_t
                                               CHANGING lv_lock.
        IF lv_lock = 0.
          CLEAR lwa_clritkey.
          FREE ls_clrqdoc.

          PERFORM select_realtime_billprf_data USING gs_clrqdoc_infocus-x-crhdr-rtbpn.

          SELECT SINGLE *
           FROM /cgdc/_clrqpcn
            INTO  lwa_clrqpcn
             WHERE vbeln = gs_clrqdoc_infocus-x-crhdr-vgbel.
          IF sy-subrc <> 0 OR gs_rtbp-pnptb IS INITIAL.

            gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
            PERFORM read_contract_details USING gs_clrqdoc_infocus-x-crhdr-vgbel.
            PERFORM check_clrq_authorization USING  gs_clrqdoc_infocus-x-crhdr-clrqt
                             gs_clrqdoc_infocus-x-crhdr-vkorg
                             gs_clrqdoc_infocus-x-crhdr-vtweg
                             gs_clrqdoc_infocus-x-crhdr-spart
                             lv_actvty_r3
                             ''
                       CHANGING lv_invalid.
            IF lv_invalid IS NOT INITIAL .
              gs_messages-msgid = gc_clrq_msg_cls.
              gs_messages-msgnr = gc_msg_cls_msgnr-090.
              gs_messages-msgv1 = gs_clrqdoc_infocus-x-crhdr-clrqt.
              gs_messages-msgv2 = gs_clrqdoc_infocus-x-crhdr-vkorg.
              gs_messages-msgv3 = gs_clrqdoc_infocus-x-crhdr-vtweg.
              gs_messages-msgv4 = gs_clrqdoc_infocus-x-crhdr-spart.
              gs_messages-msgty = gc_message_type-information.
              APPEND gs_messages TO gt_messages.
              CLEAR gs_messages.
              PERFORM initialize_document_data .
              EXIT.
            ENDIF.
            PERFORM select_calc_req_typ USING gs_clrqdoc_infocus-x-crhdr-clrqt.
            PERFORM select_item_catgs USING gs_clrqdoc_infocus-x-crhdr-clrqt.
            SORT gs_clrqdoc_infocus-x-crcon BY clrdit DESCENDING.
            DELETE lt_clritkey_t WHERE clrsit = '000000'.
            DELETE lt_clrqpit_key WHERE clrsit = '000000'.
            ""LOGIC ABCD MOVED From HERE
            "PARALLEL PROCESSING
            IF NOT is_parallel_process-parallel IS INITIAL
               AND is_parallel_process-background_job IS INITIAL.

              EXPORT gs_variables TO DATABASE /cgdc/_clrq_indx(cr) ID 'VARIABLES'.

              DO.
                gs_parallel_porcess-total_session_count = gs_parallel_porcess-total_session_count + 1.
                CLEAR lv_no_attempt.
                IF lt_clrqpit_key IS INITIAL.
                  EXIT.
                ENDIF.

                DO.
                  CLEAR lv_row_count.
                  SORT lt_clrqpit_key BY clrit clrsit.
                  DELETE ADJACENT DUPLICATES FROM lt_clrqpit_key COMPARING clrit clrsit.
                  LOOP AT lt_clrqpit_key INTO lwa_clrqpit_key.
                    lv_row_count = lv_row_count + 1.
                    IF lv_row_count  GT gs_variables-cmfrq .
                      EXIT.
                    ENDIF.

                    APPEND lwa_clrqpit_key TO lt_clrqpit_temp.
                    DELETE lt_clrqpit_key.
                  ENDLOOP.

                  CALL FUNCTION '/CGDC/CLRQ_RTB_PRL_REPRICE'
                    STARTING NEW TASK gs_parallel_porcess-total_session_count
                    DESTINATION IN GROUP is_parallel_process-server_group
                    PERFORMING post_prl_reprice_calc_item
                    ON END OF TASK
                    EXPORTING
                      i_vbeln               = i_vbeln
                      it_clrqpitkey_t       = lt_clrqpit_temp
                      it_coep_ori           = lt_coep_ori
                      is_rtbp               = gs_rtbp
                      it_rtbclnms           = it_rtbclnms
                      it_rtbwbsmcs          = it_rtbwbsmcs
                    TABLES
                      et_return_tab         = et_return
                    EXCEPTIONS
                      communication_failure = 1
                      system_failure        = 2
                      resource_failure      = 3
                      OTHERS                = 4.
                  IF sy-subrc <> 0.

                    CLEAR gs_messages.
                    gs_messages-msgid = gc_rtbp_msg_cls.
                    gs_messages-msgnr = '012'.
                    gs_messages-msgty = gc_message_type-succes.
                    gs_messages-msgv1 = gs_parallel_porcess-total_session_count.
                    gs_messages-msgv2 = lv_no_attempt.
                    APPEND gs_messages TO gt_messages.
                    lv_no_attempt = lv_no_attempt + 1.

                    IF lv_no_attempt GE is_parallel_process-retrie.
                      lv_max_attempt_failure = abap_true.
                      EXIT.
                    ELSE.
                      WAIT UP TO is_parallel_process-max_wait SECONDS.
                    ENDIF.

                  ELSE.
                    gs_parallel_porcess-active_session_count = gs_parallel_porcess-active_session_count + 1.
                    CLEAR gs_messages.
                    gs_messages-msgid = gc_rtbp_msg_cls.
                    gs_messages-msgnr = gc_msg_cls_msgnr-013.
                    gs_messages-msgty = gc_message_type-succes.
                    gs_messages-msgv1 = gs_parallel_porcess-total_session_count.
                    APPEND gs_messages TO gt_messages.
                    EXIT.
                  ENDIF.
                ENDDO.

                IF NOT lv_max_attempt_failure IS INITIAL.
                  CLEAR gs_messages.
                  gs_messages-msgid = gc_rtbp_msg_cls.
                  gs_messages-msgnr = '011'.
                  gs_messages-msgty = gc_message_type-succes.
                  APPEND gs_messages TO gt_messages.
                  EXIT.
                ENDIF.

                WAIT UNTIL gs_parallel_porcess-active_session_count LT is_parallel_process-max_process.
              ENDDO.
              WAIT UNTIL gs_parallel_porcess-active_session_count EQ 0.
              et_return = gt_msg_return.
            ELSE.
              SORT lt_clrqpit_key BY clrit clrsit.
              DELETE ADJACENT DUPLICATES FROM lt_clrqpit_key COMPARING clrit clrsit.
              LOOP AT lt_clrqpit_key INTO lwa_clrqpit_key.
                "LOGIC ABCD MOVED HERE
                LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item>
                                                   WHERE clrno = lwa_clrqpit_key-clrno
                                                   AND   clrit = lwa_clrqpit_key-clrit.

                  CLEAR ls_clrqit.
                  READ TABLE ls_clrqdoc-x-critm INTO ls_clrqit
                  WITH KEY clrno  = <lwa_clrit_item>-clrno
                           clrit  = <lwa_clrit_item>-clrit
                           clrsit = <lwa_clrit_item>-clrsit
                           clrdit = <lwa_clrit_item>-clrdit.
                  IF sy-subrc = 0.
                    <lwa_clrit_item>-exdat     = ls_clrqit-exdat.
                    <lwa_clrit_item>-bldat_bi  = ls_clrqit-bldat_bi.
                    <lwa_clrit_item>-pop_stdt  = ls_clrqit-pop_stdt.
                    <lwa_clrit_item>-pop_enddt = ls_clrqit-pop_enddt.
                    <lwa_clrit_item>-updkz     = ls_clrqit-updkz.
                  ENDIF.
                ENDLOOP.

                READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item>
                WITH KEY clrno = lwa_clrqpit_key-clrno
                         clrit = lwa_clrqpit_key-clrit.
                IF sy-subrc = 0.
                  READ TABLE gs_clrqdoc_infocus-x-crbinr ASSIGNING <lwa_clrqbi>
                  WITH KEY clrno     = <lwa_clrit_item>-clrno
                           bill_item = <lwa_clrit_item>-rtbbinr.
                  IF sy-subrc = 0.
                    CLEAR: <lwa_clrqbi>-netwr, <lwa_clrqbi>-wavwr,
                           <lwa_clrqbi>-kzwi1, <lwa_clrqbi>-kzwi2,
                           <lwa_clrqbi>-kzwi3, <lwa_clrqbi>-kzwi4,
                           <lwa_clrqbi>-kzwi5, <lwa_clrqbi>-kzwi6,
                           "++SOC - decimal precision fields
                           <lwa_clrqbi>-netwr24,
                           <lwa_clrqbi>-kzwi1_24, <lwa_clrqbi>-kzwi2_24,
                           <lwa_clrqbi>-kzwi3_24, <lwa_clrqbi>-kzwi4_24,
                           <lwa_clrqbi>-kzwi5_24, <lwa_clrqbi>-kzwi6_24.
                    "++EOC - decimal precision fields

                    CLEAR ls_clrqbi.
                    READ TABLE ls_clrqdoc-x-crbinr INTO ls_clrqbi
                    WITH KEY clrno     = <lwa_clrqbi>-clrno
                             bill_item = <lwa_clrqbi>-bill_item.
                    IF sy-subrc = 0.
                      <lwa_clrqbi>-exdat = ls_clrqbi-exdat.
                      <lwa_clrqbi>-updkz = ls_clrqbi-updkz.
                    ENDIF.
                  ENDIF.
                ENDIF.

                CLEAR gs_clrit_org.
                READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item> WITH KEY clrit = lwa_clrqpit_key-clrit
                                                                                          clrsit = '000000'.
                IF sy-subrc = 0.
                  READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_sub> WITH KEY clrit = lwa_clrqpit_key-clrit
                                                                                             clrsit = lwa_clrqpit_key-clrsit
                                                                                             clrdit = '000000'.
                  IF sy-subrc = 0.
                    READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_delta> WITH KEY clrno = <lwa_clrit_sub>-clrno
                                                                                             clrit = <lwa_clrit_sub>-clrit
                                                                                             clrsit = <lwa_clrit_sub>-clrsit
                                                                                             clrdit = <lwa_clrit_sub>-ldetla.
                    IF <lwa_clrit_delta> IS ASSIGNED.
                      MOVE-CORRESPONDING lwa_clrqpit_key TO lwa_clrqpit.
                      lwa_clrqpit-updkz = gc_updkz_new.
                      APPEND lwa_clrqpit TO lt_clrqpit.
                      IF <lwa_clrit_delta>-istat EQ gc_ibill_stat-copied OR <lwa_clrit_delta>-istat EQ gc_ibill_stat-delta
                        OR <lwa_clrit_delta>-istat EQ gc_ibill_stat-copied_to_subitems OR <lwa_clrit_delta>-reversed IS NOT INITIAL OR
                         <lwa_clrit_delta>-itmty = gc_clrq_itmty-bill_plan_line.
                        CONTINUE.
                      ENDIF.
                      IF <lwa_clrit_item>-no_price EQ abap_false.
                        READ TABLE gs_clrqdoc_infocus-x-crcon INTO lwa_crcon WITH KEY clrit = <lwa_clrit_delta>-clrit
                                                                  clrsit = <lwa_clrit_delta>-clrsit
                                                                  clrdit = <lwa_clrit_delta>-clrdit
                                                                  kschl = gs_rtbp-ccond.
                        IF sy-subrc <> 0.
                          CLEAR lwa_crcon.
                        ENDIF.
                      ENDIF.

*                      READ TABLE gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WITH KEY clrno = <lwa_clrit_delta>-clrno
*                                                                                      bill_item = <lwa_clrit_delta>-rtbbinr
*                                                                                      bitype = <lwa_clrit_delta>-bityp .
*                      IF sy-subrc = 0 AND lwa_crbinr-bstat IS NOT INITIAL.
*                        gs_variables-billed_item = abap_true.
*                      ELSE.
*                        CLEAR gs_variables-billed_item.
*                      ENDIF.
                      CLEAR gs_variables-billed_item.
                      LOOP AT gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WHERE bstat IS NOT INITIAL.
                        READ TABLE gs_clrqdoc_infocus-x-critm TRANSPORTING NO FIELDS WITH KEY clrno = <lwa_clrit_delta>-clrno
                                                                                              clrit = <lwa_clrit_delta>-clrit
                                                                                              rtbbinr = lwa_crbinr-bill_item.
                        IF sy-subrc = 0.
                          gs_variables-billed_item = 'X'.
                          EXIT.
                        ENDIF.
                      ENDLOOP.


                      CLEAR:lwa_clrq_itm_new.
                      PERFORM move_itm_to_itm_fcat USING <lwa_clrit_delta>
                                      CHANGING lwa_clrq_itm_new.
                      lwa_clrq_itm_new-duepos = <lwa_clrit_delta>-clrdit.
                      gs_variables-process_type = gc_updkz_update.

                      <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla + 1.
                      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                        EXPORTING
                          input  = <lwa_clrit_sub>-ldetla
                        IMPORTING
                          output = <lwa_clrit_sub>-ldetla.
                      IF sy-subrc <> 0.
                      ENDIF.
                      IF gs_variables-billed_item IS NOT INITIAL.
                        lwa_clrq_itm_new-istat = gc_ibill_stat-copied.
                      ENDIF.

                      gs_clrit_org-clrno = <lwa_clrit_delta>-clrno.
                      gs_clrit_org-clrit = <lwa_clrit_delta>-clrit.
                      gs_clrit_org-clrsit = <lwa_clrit_delta>-clrsit.
                      gs_clrit_org-item_delta = <lwa_clrit_sub>-ldetla.
                      gs_variables-process_type = gc_updkz_update.

                      IF <lwa_clrit_item>-no_price EQ abap_true.
                        lwa_clrq_itm_new-kbetr1 = <lwa_clrit_item>-kbetr1.
                        <lwa_clrit_item>-no_price = abap_false.
                        gs_clrit_org-istat = gc_ibill_stat-open.
                        .
                      ELSE.
                        IF gs_variables-billed_item IS NOT INITIAL.
                          "last billed status
                          LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WHERE clrno = <lwa_clrit_delta>-clrno
                                                                                        AND clrit = <lwa_clrit_delta>-clrit
                                                                                        AND istat = gc_ibill_stat-copied.
                          ENDLOOP.

                          IF <lwa_clrqit_last_copied> IS ASSIGNED.
*                            READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = lwa_last_billed-clrno
*                                                                                                            clrit = lwa_last_billed-clrit
*                                                                                                            clrsit = lwa_last_billed-cuepos
*                                                                                                            clrdit = lwa_last_billed-duepos.
*                            IF sy-subrc <> 0.

                            IF lwa_last_billed-cuepos IS NOT INITIAL AND lwa_last_billed-duepos IS NOT INITIAL.
                              READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = lwa_last_billed-clrno
                                                                                                              clrit = lwa_last_billed-clrit
                                                                                                              clrsit = lwa_last_billed-cuepos
                                                                                                              clrdit = lwa_last_billed-duepos.
                            ENDIF.
                            IF <lwa_clrqit_last_copied> IS ASSIGNED.
                              READ TABLE gs_clrqdoc_infocus-x-crcon INTO lwa_crcon WITH KEY clrit = <lwa_clrqit_last_copied>-clrit
                                                                clrsit = <lwa_clrqit_last_copied>-clrsit
                                                                clrdit = <lwa_clrqit_last_copied>-clrdit
                                                                kschl = gs_rtbp-ccond.
                              IF sy-subrc <> 0.
                                CLEAR lwa_crcon.
                              ENDIF.
                            ENDIF.
*                          ENDIF.
*                            ENDIF.
                          ENDIF.
                        ENDIF.
                        IF lwa_crcon-kbetr IS NOT INITIAL.
                          "Check additonal cost coll and set Alloc %
                          DATA(ls_src_wbs) = VALUE #( gt_add_cost_collector[ vbeln =  lwa_clrq_itm_new-vgbel
                                                                              wbs_cost_col = lwa_clrq_itm_new-cc_pspnr
                                                                              wbsel = lwa_clrq_itm_new-ps_psp_pnr ]
                                                                              OPTIONAL ).
                          IF ls_src_wbs-multi_payer_ind = abap_false.
                            lwa_clrq_itm_new-kbetr1 = lwa_crcon-kbetr.
                          ELSE.
                            lwa_clrq_itm_new-kbetr1 = <lwa_clrit_item>-kbetr1.
                          ENDIF.
*                          ELSE.
*                            lwa_clrq_itm_new-kbetr1 = lwa_crcon-kbetr.
*                          ENDIF.
                        ELSE.
                          lwa_clrq_itm_new-kbetr1 = <lwa_clrit_delta>-netwr.
                        ENDIF.
                      ENDIF.
                      IF gs_variables-billed_item IS NOT INITIAL AND <lwa_clrqit_last_copied> IS ASSIGNED.
                        lwa_clrq_itm_new-cuepos = <lwa_clrqit_last_copied>-clrsit.
                        lwa_clrq_itm_new-duepos = <lwa_clrqit_last_copied>-clrdit.
                      ELSE.
                        lwa_clrq_itm_new-cuepos = <lwa_clrit_delta>-clrsit.
                        lwa_clrq_itm_new-duepos = <lwa_clrit_delta>-clrdit.
                      ENDIF.
                      gs_variables-bit_num_gen = abap_true.

                      CLEAR : lwa_clrq_itm_new-rtbbinr.

                      IF it_rtbclnms IS NOT INITIAL OR it_rtbwbsmcs IS NOT INITIAL.
                        LOOP AT it_rtbclnms INTO lwa_clnmcs WHERE ( begdat LE lwa_clrq_itm_new-budat
                                                              AND enddat GE lwa_clrq_itm_new-budat )
                                                              AND posnr = lwa_clrq_itm_new-/cgdc/orgi.
                          lv_action_cd = lwa_clnmcs-action_cd.
                          EXIT.
                        ENDLOOP.

                        IF it_rtbwbsmcs IS NOT INITIAL AND lv_action_cd IS INITIAL.
                          READ TABLE lt_prps INTO lwa_prps WITH KEY pspnr = lwa_clrq_itm_new-cc_pspnr.
                          IF sy-subrc = 0.
                            LOOP AT it_rtbwbsmcs INTO lwa_wbsmcs WHERE ( begdat LE lwa_clrq_itm_new-budat
                                                                      AND enddat GE lwa_clrq_itm_new-budat )
                                                                    AND objnr = lwa_prps-objnr.
                              lv_action_cd = lwa_wbsmcs-action_cd.
                            ENDLOOP.
                          ENDIF.
                        ENDIF.
                      ELSE.
                        lv_action_cd = lwa_clrqpit-action_cd.
                      ENDIF.
                      PERFORM assign_reprice_code USING lv_action_cd
                                                  CHANGING lwa_clrq_itm_new.
                      PERFORM repricing USING  lwa_item_old
                                                     CHANGING lwa_clrq_itm_new.
                      IF gs_clrit_org-istat IS INITIAL.

                        <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla - 1.
                        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                          EXPORTING
                            input  = <lwa_clrit_sub>-ldetla
                          IMPORTING
                            output = <lwa_clrit_sub>-ldetla.
                        CONTINUE.
*                      ELSEIF gs_clrit_org-istat <> gc_ibill_stat-copied.
*                        CONTINUE.
                      ENDIF.
                      <lwa_clrit_delta>-istat = gc_csist-acv_incomp_map.
*                      IF gs_variables-billed_item IS INITIAL.
                      READ TABLE gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WITH KEY bill_item = <lwa_clrit_delta>-rtbbinr.
                      IF sy-subrc = 0 AND lwa_crbinr-bstat IS INITIAL.
                        CLEAR <lwa_clrit_delta>-rtbbinr.
                      ENDIF.
*                      ENDIF.
                      <lwa_clrit_delta>-updkz = gc_updkz_update.
                      <lwa_clrit_sub>-updkz = gc_updkz_update.
                      IF <lwa_clrit_delta>-cuepos IS INITIAL .
                        <lwa_clrit_delta>-cuepos = <lwa_clrit_delta>-clrsit.
                      ENDIF.
                      gs_clrqdoc_infocus-x-crhdr-netwr = <lwa_clrit_delta>-netwr.
                      "++SOC - Decimal Precision fields
                      gs_clrqdoc_infocus-x-crhdr-netwr24 = <lwa_clrit_delta>-netwr24.
                      "++EOC - Decimal precision fields

                      IF gs_variables-billed_item IS NOT INITIAL..

                        IF <lwa_clrqit_last_copied> IS NOT ASSIGNED.

                          READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = <lwa_clrit_delta>-clrno
                                                                                                          clrit = <lwa_clrit_delta>-clrit
                                                                                                          clrsit = <lwa_clrit_delta>-clrsit
                                                                                                          istat = gc_ibill_stat-copied.
                          IF <lwa_clrqit_last_copied> IS ASSIGNED.
                            IF <lwa_clrqit_last_copied>-updkz <> gc_updkz_new.
                              <lwa_clrqit_last_copied>-istat = gc_ibill_stat-delta.
                              <lwa_clrqit_last_copied>-updkz = gc_updkz_update.
                            ENDIF.
                          ELSE.
                            CONTINUE.
                          ENDIF.
                        ENDIF.
                        IF <lwa_clrqit_last_copied> IS ASSIGNED.
                          IF <lwa_clrqit_last_copied>-updkz <> gc_updkz_new.
                            <lwa_clrqit_last_copied>-istat = gc_ibill_stat-delta.
                            <lwa_clrqit_last_copied>-updkz = gc_updkz_update.
                          ENDIF.
                        ENDIF.

                        APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_critm_copied>.

                        MOVE-CORRESPONDING lwa_clrq_itm_new TO <lwa_critm_copied>.
                        <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla + 1.
                        CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                          EXPORTING
                            input  = <lwa_clrit_sub>-ldetla
                          IMPORTING
                            output = <lwa_clrit_sub>-ldetla.
                        <lwa_critm_copied>-clrsit = <lwa_clrit_sub>-clrsit.
                        <lwa_critm_copied>-clrit = <lwa_clrit_item>-clrit.
                        <lwa_critm_copied>-clrdit = <lwa_clrit_sub>-ldetla.
                        <lwa_critm_copied>-ldetla = '000000'.
                        <lwa_critm_copied>-rtbbinr = lwa_clrq_itm_new-rtbbinr.
                        <lwa_critm_copied>-cuepos = lwa_clrq_itm_new-clrsit.
                        <lwa_critm_copied>-duepos = lwa_clrq_itm_new-clrdit.
                        IF  <lwa_clrqit_last_copied> IS ASSIGNED AND <lwa_clrqit_last_copied>-clrdit <> lwa_clrq_itm_new-clrdit.
*                        <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - <lwa_clrqit_last_copied>-netwr .
                          <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - ( <lwa_clrqit_last_copied>-netwr - <lwa_clrit_delta>-netwr ) .
                          "++SOC - Decimal precision field
*                        <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - <lwa_clrqit_last_copied>-netwr24 .
                          <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - ( <lwa_clrqit_last_copied>-netwr24 - <lwa_clrit_delta>-netwr24 ).
                          "++EOC - decimal precision field
                        ELSE.
                          <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - <lwa_clrit_delta>-netwr .
                          "++SOC - Decimal precision field
                          <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - <lwa_clrit_delta>-netwr24 .
                          "++EOC - decimal precision field
                        ENDIF.
                        gs_clrqdoc_infocus-x-crhdr-netwr = gs_clrqdoc_infocus-x-crhdr-netwr + <lwa_critm_copied>-netwr.
                        "++SOC - decimal Precision field
                        gs_clrqdoc_infocus-x-crhdr-netwr24 = gs_clrqdoc_infocus-x-crhdr-netwr24 + <lwa_critm_copied>-netwr24.
                        "++EOC - decimal precision field
                        <lwa_critm_copied>-updkz = gc_updkz_new.
                        <lwa_critm_copied>-istat = gc_ibill_stat-open.
                        PERFORM create_billing_item CHANGING <lwa_critm_copied>.
                        CLEAR <lwa_critm_copied>-bstat.
                        lt_crcon_copied = gs_clrqdoc_infocus-x-crcon.
                        lt_clrqcs_copied = gs_clrqdoc_infocus-x-cscon.

                        IF <lwa_clrqit_last_copied> IS ASSIGNED AND <lwa_clrqit_last_copied>-clrdit <> lwa_clrq_itm_new-clrdit.
                          lt_crcon_copied_c = gs_clrqdoc_infocus-x-crcon.
                          lt_clrqcs_copied_c = gs_clrqdoc_infocus-x-cscon.
                          DELETE lt_crcon_copied_c WHERE clrit <> <lwa_clrqit_last_copied>-clrit OR
                                                       clrsit <> <lwa_clrqit_last_copied>-clrsit OR
                                                       clrdit <> <lwa_clrqit_last_copied>-clrdit.

                          DELETE lt_clrqcs_copied_c WHERE clrit <> <lwa_clrqit_last_copied>-clrit OR
                                                       clrsit <> <lwa_clrqit_last_copied>-clrsit OR
                                                       clrdit <> <lwa_clrqit_last_copied>-clrdit.
                        ENDIF.
                        DELETE lt_crcon_copied WHERE clrit <> <lwa_clrit_delta>-clrit OR
                                                     clrsit <> <lwa_clrit_delta>-clrsit OR
                                                     clrdit  <> <lwa_clrit_delta>-clrdit.
                        DELETE lt_clrqcs_copied WHERE clrit <> <lwa_clrit_delta>-clrit OR
                                                     clrsit <> <lwa_clrit_delta>-clrsit OR
                                                     clrdit  <> <lwa_clrit_delta>-clrdit.
*                        ENDIF.
                        lt_crcon_copied_t = lt_crcon_copied[].
                        lt_clrqcs_copied_t = lt_clrqcs_copied[].


                        READ TABLE gs_clrqdoc_infocus-x-crcon TRANSPORTING NO FIELDS WITH KEY clrit = lwa_clrq_itm_new-clrit
                                                                                        clrsit = lwa_clrq_itm_new-clrsit
                                                                                        clrdit = lwa_clrq_itm_new-clrdit.
                        IF sy-subrc = 0.
                          LOOP AT gs_clrqdoc_infocus-x-crcon INTO lwa_crcon_new FROM sy-tabix.
                            IF lwa_crcon_new-clrno <> lwa_clrq_itm_new-clrno
                              OR lwa_crcon_new-clrit <> lwa_clrq_itm_new-clrit
                              OR lwa_crcon_new-clrsit <> lwa_clrq_itm_new-clrsit
                              OR lwa_crcon_new-clrdit <> lwa_clrq_itm_new-clrdit.
                              EXIT.
                            ELSE.
                              lwa_crcon_new_t = lwa_crcon_new.
                              READ TABLE lt_crcon_copied INTO lwa_crcon_delta WITH KEY kschl = lwa_crcon_new-kschl.
                              IF sy-subrc = 0.
                                DELETE lt_crcon_copied_t WHERE kschl = lwa_crcon_new-kschl.
                                CLEAR : lwa_crcon_delta-clrit,
                                        lwa_crcon_delta-clrdit,
                                        lwa_crcon_delta-clrsit,
                                        lwa_crcon_delta-stunr,
                                        lwa_crcon_delta-zaehk,
                                        lwa_crcon_new-clrit,
                                        lwa_crcon_new-clrdit,
                                        lwa_crcon_new-clrsit,
                                        lwa_crcon_new-stunr,
                                        lwa_crcon_new-zaehk.
                                IF lwa_crcon_delta <> lwa_crcon_new.
                                  APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.

                                  MOVE-CORRESPONDING lwa_crcon_new_t TO <lwa_crcon_copied>.
                                  READ TABLE lt_crcon_copied_c INTO DATA(lwa_crcon_c) WITH KEY kschl = lwa_crcon_delta-kschl.
                                  IF sy-subrc <> 0.
                                    <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                    <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                    <lwa_crcon_copied>-kbetr =  lwa_crcon_new-kbetr - lwa_crcon_delta-kbetr .
                                    <lwa_crcon_copied>-kawrt =  lwa_crcon_new-kawrt - lwa_crcon_delta-kawrt.
                                    <lwa_crcon_copied>-kwert =  lwa_crcon_new-kwert - lwa_crcon_delta-kwert.

                                    <lwa_crcon_copied>-kbetr24 =  lwa_crcon_new-kbetr24 - lwa_crcon_delta-kbetr24 .
                                    <lwa_crcon_copied>-kawrt24 =  lwa_crcon_new-kawrt24 - lwa_crcon_delta-kawrt24.
                                    <lwa_crcon_copied>-kwert24 =  lwa_crcon_new-kwert24 - lwa_crcon_delta-kwert24.
                                    <lwa_crcon_copied>-updkz = gc_updkz_new.
                                  ELSE.
                                    <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                    <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                    <lwa_crcon_copied>-kbetr =  lwa_crcon_new-kbetr + lwa_crcon_delta-kbetr - lwa_crcon_c-kbetr .
                                    <lwa_crcon_copied>-kawrt =  lwa_crcon_new-kawrt + lwa_crcon_delta-kawrt - lwa_crcon_c-kawrt.
                                    <lwa_crcon_copied>-kwert =  lwa_crcon_new-kwert + lwa_crcon_delta-kwert - lwa_crcon_c-kwert.

                                    <lwa_crcon_copied>-kbetr24 =  lwa_crcon_new-kbetr24 + lwa_crcon_delta-kbetr24  - lwa_crcon_c-kbetr24.
                                    <lwa_crcon_copied>-kawrt24 =  lwa_crcon_new-kawrt24 + lwa_crcon_delta-kawrt24 - lwa_crcon_c-kawrt24.
                                    <lwa_crcon_copied>-kwert24 =  lwa_crcon_new-kwert24 + lwa_crcon_delta-kwert24 - lwa_crcon_c-kwert24.
                                    <lwa_crcon_copied>-updkz = gc_updkz_new.
                                  ENDIF.

                                ENDIF.
                              ELSE.
                                APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                                MOVE-CORRESPONDING lwa_crcon_new_t TO <lwa_crcon_copied>.
                                <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                <lwa_crcon_copied>-updkz = gc_updkz_new.
                              ENDIF.
                            ENDIF.
                          ENDLOOP.
                          IF lt_crcon_copied_t IS NOT INITIAL.
                            LOOP AT lt_crcon_copied_t INTO lwa_crcon_delta.
                              APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                              MOVE-CORRESPONDING lwa_crcon_delta TO <lwa_crcon_copied>.
                              <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                              <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                              <lwa_crcon_copied>-kbetr =  0 - lwa_crcon_delta-kbetr .
                              <lwa_crcon_copied>-kawrt =  0 - lwa_crcon_delta-kawrt.
                              <lwa_crcon_copied>-kwert =  0 - lwa_crcon_delta-kwert.

                              <lwa_crcon_copied>-kbetr24 =  0 - lwa_crcon_delta-kbetr24 .
                              <lwa_crcon_copied>-kawrt24 =  0 - lwa_crcon_delta-kawrt24.
                              <lwa_crcon_copied>-kwert24 =  0 - lwa_crcon_delta-kwert24.
                              <lwa_crcon_copied>-updkz = gc_updkz_new.
                            ENDLOOP.
                          ENDIF.
                        ENDIF.
                        ""COSTING SHEET 7142
                        READ TABLE gs_clrqdoc_infocus-x-cscon TRANSPORTING NO FIELDS WITH KEY clrit = lwa_clrq_itm_new-clrit
                                                                clrsit = lwa_clrq_itm_new-clrsit
                                                                clrdit = lwa_clrq_itm_new-clrdit.
                        IF sy-subrc = 0.
                          LOOP AT gs_clrqdoc_infocus-x-cscon INTO lwa_crconcs_new FROM sy-tabix.
                            IF lwa_crconcs_new-clrno <> lwa_clrq_itm_new-clrno
                              OR lwa_crconcs_new-clrit <> lwa_clrq_itm_new-clrit
                              OR lwa_crconcs_new-clrsit <> lwa_clrq_itm_new-clrsit
                              OR lwa_crconcs_new-clrdit <> lwa_clrq_itm_new-clrdit.
                              EXIT.
                            ELSE.
                              lwa_crconcs_new_t = lwa_crconcs_new.
                              READ TABLE lt_clrqcs_copied INTO lwa_crconcs_delta WITH KEY kschl = lwa_crconcs_new-kschl.
                              IF sy-subrc = 0.
                                DELETE lt_clrqcs_copied_t WHERE kschl = lwa_crconcs_new-kschl.
                                CLEAR : lwa_crconcs_delta-clrit,
                                        lwa_crconcs_delta-clrdit,
                                        lwa_crconcs_delta-clrsit,
                                        lwa_crconcs_delta-stunr,
                                        lwa_crconcs_delta-zaehk,
                                        lwa_crconcs_new-clrit,
                                        lwa_crconcs_new-clrdit,
                                        lwa_crconcs_new-clrsit,
                                        lwa_crconcs_new-stunr,
                                        lwa_crconcs_new-zaehk.
                                IF lwa_crconcs_delta <> lwa_crconcs_new.
                                  APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-cscon ASSIGNING <lwa_crconcs_copied>.

                                  MOVE-CORRESPONDING lwa_crconcs_new_t TO <lwa_crconcs_copied>.
                                  READ TABLE lt_clrqcs_copied_c INTO DATA(lwa_crconcs_c) WITH KEY kschl = lwa_crcon_delta-kschl.
                                  IF sy-subrc <> 0.
                                    <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                    <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                    <lwa_crconcs_copied>-kbetr =  lwa_crconcs_new-kbetr - lwa_crconcs_delta-kbetr .
                                    <lwa_crconcs_copied>-kawrt =  lwa_crconcs_new-kawrt - lwa_crconcs_delta-kawrt.
                                    <lwa_crconcs_copied>-kwert =  lwa_crconcs_new-kwert - lwa_crconcs_delta-kwert.

                                    <lwa_crconcs_copied>-kbetr24 =  lwa_crconcs_new-kbetr24 - lwa_crconcs_delta-kbetr24 .
                                    <lwa_crconcs_copied>-kawrt24 =  lwa_crconcs_new-kawrt24 - lwa_crconcs_delta-kawrt24.
                                    <lwa_crconcs_copied>-kwert24 =  lwa_crconcs_new-kwert24 - lwa_crconcs_delta-kwert24.
                                    <lwa_crconcs_copied>-updkz = gc_updkz_new.
                                  ELSE.
                                    <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                    <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                    <lwa_crconcs_copied>-kbetr =  lwa_crconcs_new-kbetr + lwa_crconcs_delta-kbetr - lwa_crconcs_c-kbetr .
                                    <lwa_crconcs_copied>-kawrt =  lwa_crconcs_new-kawrt + lwa_crconcs_delta-kawrt - lwa_crconcs_c-kawrt.
                                    <lwa_crconcs_copied>-kwert =  lwa_crconcs_new-kwert + lwa_crconcs_delta-kwert - lwa_crconcs_c-kwert.

                                    <lwa_crconcs_copied>-kbetr24 =  lwa_crconcs_new-kbetr24 + lwa_crconcs_delta-kbetr24  - lwa_crconcs_c-kbetr24.
                                    <lwa_crconcs_copied>-kawrt24 =  lwa_crconcs_new-kawrt24 + lwa_crconcs_delta-kawrt24 - lwa_crconcs_c-kawrt24.
                                    <lwa_crconcs_copied>-kwert24 =  lwa_crconcs_new-kwert24 + lwa_crconcs_delta-kwert24 - lwa_crconcs_c-kwert24.
                                    <lwa_crconcs_copied>-updkz = gc_updkz_new.
                                  ENDIF.

                                ENDIF.
                              ELSE.
                                APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-cscon ASSIGNING <lwa_crconcs_copied>.
                                MOVE-CORRESPONDING lwa_crconcs_new_t TO <lwa_crconcs_copied>.
                                <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                <lwa_crconcs_copied>-updkz = gc_updkz_new.
                              ENDIF.
                            ENDIF.
                          ENDLOOP.
                          IF lt_clrqcs_copied_t IS NOT INITIAL.
                            LOOP AT lt_clrqcs_copied_t INTO lwa_crconcs_delta.
                              APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-cscon ASSIGNING <lwa_crconcs_copied>.
                              MOVE-CORRESPONDING lwa_crcon_delta TO <lwa_crconcs_copied>.
                              <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                              <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                              <lwa_crconcs_copied>-kbetr =  0 - lwa_crconcs_delta-kbetr .
                              <lwa_crconcs_copied>-kawrt =  0 - lwa_crconcs_delta-kawrt.
                              <lwa_crconcs_copied>-kwert =  0 - lwa_crconcs_delta-kwert.

                              <lwa_crconcs_copied>-kbetr24 =  0 - lwa_crconcs_delta-kbetr24 .
                              <lwa_crconcs_copied>-kawrt24 =  0 - lwa_crconcs_delta-kawrt24.
                              <lwa_crconcs_copied>-kwert24 =  0 - lwa_crconcs_delta-kwert24.
                              <lwa_crconcs_copied>-updkz = gc_updkz_new.
                            ENDLOOP.
                          ENDIF.
                        ENDIF.
                      ENDIF.

                      IF gs_clrit_org-istat <> gc_ibill_stat-copied.
                        <lwa_clrit_item>-netwr = ( <lwa_clrit_item>-netwr - <lwa_clrit_delta>-netwr ) + lwa_clrq_itm_new-netwr.

                        "++SOC - DCLM 6423 subtotal not populated
                        <lwa_clrit_item>-kzwi1 = ( <lwa_clrit_item>-kzwi1 - <lwa_clrit_delta>-kzwi1 ) + lwa_clrq_itm_new-kzwi1.
                        <lwa_clrit_item>-kzwi2 = ( <lwa_clrit_item>-kzwi2 - <lwa_clrit_delta>-kzwi2 ) + lwa_clrq_itm_new-kzwi2.
                        <lwa_clrit_item>-kzwi3 = ( <lwa_clrit_item>-kzwi3 - <lwa_clrit_delta>-kzwi3 ) + lwa_clrq_itm_new-kzwi3.
                        <lwa_clrit_item>-kzwi4 = ( <lwa_clrit_item>-kzwi4 - <lwa_clrit_delta>-kzwi4 ) + lwa_clrq_itm_new-kzwi4.
                        <lwa_clrit_item>-kzwi5 = ( <lwa_clrit_item>-kzwi5 - <lwa_clrit_delta>-kzwi5 ) + lwa_clrq_itm_new-kzwi5.
                        <lwa_clrit_item>-kzwi6 = ( <lwa_clrit_item>-kzwi6 - <lwa_clrit_delta>-kzwi6 ) + lwa_clrq_itm_new-kzwi6.
                        "++EOC - DCLM 6423 subtotal not populated
                        <lwa_clrit_item>-wbs_allocation = lwa_clrq_itm_new-wbs_allocation.

                        "++SOC - Decimal precision fields
                        <lwa_clrit_item>-netwr24  = ( <lwa_clrit_item>-netwr24 - <lwa_clrit_delta>-netwr24 ) + lwa_clrq_itm_new-netwr24.
                        <lwa_clrit_item>-kzwi1_24 = ( <lwa_clrit_item>-kzwi1_24 - <lwa_clrit_delta>-kzwi1_24 ) + lwa_clrq_itm_new-kzwi1_24.
                        <lwa_clrit_item>-kzwi2_24 = ( <lwa_clrit_item>-kzwi2_24 - <lwa_clrit_delta>-kzwi2_24 ) + lwa_clrq_itm_new-kzwi2_24.
                        <lwa_clrit_item>-kzwi3_24 = ( <lwa_clrit_item>-kzwi3_24 - <lwa_clrit_delta>-kzwi3_24 ) + lwa_clrq_itm_new-kzwi3_24.
                        <lwa_clrit_item>-kzwi4_24 = ( <lwa_clrit_item>-kzwi4_24 - <lwa_clrit_delta>-kzwi4_24 ) + lwa_clrq_itm_new-kzwi4_24.
                        <lwa_clrit_item>-kzwi5_24 = ( <lwa_clrit_item>-kzwi5_24 - <lwa_clrit_delta>-kzwi5_24 ) + lwa_clrq_itm_new-kzwi5_24.
                        <lwa_clrit_item>-kzwi6_24 = ( <lwa_clrit_item>-kzwi6_24 - <lwa_clrit_delta>-kzwi6_24 ) + lwa_clrq_itm_new-kzwi6_24.
                        "++EOC - Decimal precision fields

                        gs_clrqdoc_infocus-x-crhdr-netwr = ( gs_clrqdoc_infocus-x-crhdr-netwr - <lwa_clrit_delta>-netwr ) + lwa_clrq_itm_new-netwr.
                        "++SOC decimal precision field
                        gs_clrqdoc_infocus-x-crhdr-netwr24 = ( gs_clrqdoc_infocus-x-crhdr-netwr24 - <lwa_clrit_delta>-netwr24 ) + lwa_clrq_itm_new-netwr24.
                        "++EOC decimal precision field
                        gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
                      ELSE.
                        <lwa_clrit_item>-netwr = <lwa_clrit_item>-netwr  + <lwa_critm_copied>-netwr - <lwa_clrit_delta>-netwr.

                        "++SOC - DCLM 6423 subtotal not populated
                        <lwa_clrit_item>-kzwi1 = <lwa_clrit_item>-kzwi1 + <lwa_critm_copied>-kzwi1 - <lwa_clrit_delta>-kzwi1.
                        <lwa_clrit_item>-kzwi2 = <lwa_clrit_item>-kzwi2 + <lwa_critm_copied>-kzwi2 - <lwa_clrit_delta>-kzwi2.
                        <lwa_clrit_item>-kzwi3 = <lwa_clrit_item>-kzwi3 + <lwa_critm_copied>-kzwi3 - <lwa_clrit_delta>-kzwi3.
                        <lwa_clrit_item>-kzwi4 = <lwa_clrit_item>-kzwi4 + <lwa_critm_copied>-kzwi4 - <lwa_clrit_delta>-kzwi4.
                        <lwa_clrit_item>-kzwi5 = <lwa_clrit_item>-kzwi5 + <lwa_critm_copied>-kzwi5 - <lwa_clrit_delta>-kzwi5.
                        <lwa_clrit_item>-kzwi6 = <lwa_clrit_item>-kzwi6 + <lwa_critm_copied>-kzwi6 - <lwa_clrit_delta>-kzwi6.
                        "++EOC - DCLM 6423 subtotal not populated

                        "++SOC - Decimal precision fields
                        <lwa_clrit_item>-netwr24  = <lwa_clrit_item>-netwr24  + <lwa_critm_copied>-netwr24 - <lwa_clrit_delta>-netwr24.
                        <lwa_clrit_item>-kzwi1_24 = <lwa_clrit_item>-kzwi1_24 + <lwa_critm_copied>-kzwi1_24  - <lwa_clrit_delta>-kzwi1_24.
                        <lwa_clrit_item>-kzwi2_24 = <lwa_clrit_item>-kzwi2_24 + <lwa_critm_copied>-kzwi2_24 - <lwa_clrit_delta>-kzwi2_24.
                        <lwa_clrit_item>-kzwi3_24 = <lwa_clrit_item>-kzwi3_24 + <lwa_critm_copied>-kzwi3_24 - <lwa_clrit_delta>-kzwi3_24.
                        <lwa_clrit_item>-kzwi4_24 = <lwa_clrit_item>-kzwi4_24 + <lwa_critm_copied>-kzwi4_24 - <lwa_clrit_delta>-kzwi4_24.
                        <lwa_clrit_item>-kzwi5_24 = <lwa_clrit_item>-kzwi5_24 + <lwa_critm_copied>-kzwi5_24 - <lwa_clrit_delta>-kzwi5_24.
                        <lwa_clrit_item>-kzwi6_24 = <lwa_clrit_item>-kzwi6_24 + <lwa_critm_copied>-kzwi6_24 - <lwa_clrit_delta>-kzwi6_24.
                        "++EOC - Decimal precision fields
                        gs_clrqdoc_infocus-x-crhdr-netwr =  gs_clrqdoc_infocus-x-crhdr-netwr  + <lwa_critm_copied>-netwr.
                        "++SOC - Decimal precision fields
                        gs_clrqdoc_infocus-x-crhdr-netwr24 =  gs_clrqdoc_infocus-x-crhdr-netwr24  + <lwa_critm_copied>-netwr24.
                        "++EOC - decimal precision fields
                        gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
                      ENDIF.

                      <lwa_clrit_item>-updkz = gc_updkz_update.
                      UNASSIGN <lwa_clrit_delta>.
                    ENDIF.
                  ENDIF.
                ENDIF.
                UNASSIGN : <lwa_clrit_item>,
                           <lwa_clrit_sub>,
                           <lwa_clrit_delta>,
                           <lwa_clrqit_last_copied>.
                CLEAR : lt_crcon_copied,
                        lt_crcon_copied_c.
              ENDLOOP.
            ENDIF.
            APPEND gs_clrqdoc_infocus TO lt_clrqdoc.
            lwa_return-msgid = gc_rtbp_msg_cls.
            lwa_return-msgty = gc_message_type-succes.
            lwa_return-msgnr = 012.
            lwa_return-msgv1 = gs_clrqdoc_infocus-x-crhdr-clrno.
            lwa_return-msgv2 = gs_clrqdoc_infocus-x-crhdr-vgbel.
            APPEND lwa_return TO et_return.
            CLEAR lwa_return.
          ELSE.
            lwa_return-msgid = gc_rtbp_msg_cls.
            lwa_return-msgty = gc_message_type-error.
            lwa_return-msgnr = 011.
            lwa_return-msgv1 = gs_clrqdoc_infocus-x-crhdr-vgbel.
            APPEND lwa_return TO et_return.
            CLEAR lwa_return.
          ENDIF.
        ENDIF.
      ENDLOOP.
    ENDIF.
  ELSE.
*    CLEAR: lt_coep_ori.
*
*    SELECT b~clrno, b~clrit,
*           a~kokrs, a~belnr,
*           a~buzei, a~bukrs,
*           a~wtgbtr
*      FROM v_coep_acdoca_view AS a INNER JOIN /cgdc/_clrqcost AS b
*       ON  a~belnr = b~cbelnr
*       AND a~buzei = b~cbuzei
*       AND a~bukrs = b~crbukrs
*       AND a~gjahr = b~cgjahr
*    FOR ALL ENTRIES IN @lt_clrno
*    WHERE b~clrno EQ @lt_clrno-clrno
*    INTO TABLE @lt_coep_ori.
*    IF sy-subrc EQ 0.
*      SORT lt_coep_ori.
*    ENDIF. "CLRQIT-KBETR1 is going used for no price items

    SELECT *
    FROM /cgdc/_clrqit
    INTO CORRESPONDING FIELDS OF TABLE lt_clrqpit_key
    FOR ALL ENTRIES IN lt_clrno
    WHERE clrno = lt_clrno-clrno.
    IF sy-subrc = 0.
      SELECT *
        FROM /cgdc/_clrqpit
        INTO TABLE gt_clrqpit
        FOR ALL ENTRIES IN lt_clrqpit_key
        WHERE clrno = lt_clrqpit_key-clrno AND
              clrit = lt_clrqpit_key-clrit AND
              clrsit = lt_clrqpit_key-clrsit.
      gs_variables-overview_mode = gc_mode_change.
      LOOP AT lt_clrno INTO lwa_clrno.
        CLEAR : gs_clrqdoc_infocus,
                lt_clritkey_t.
        LOOP AT lt_clrqpit_key INTO lwa_clrqpit_key WHERE clrno = lwa_clrno-clrno.
          MOVE-CORRESPONDING lwa_clrqpit_key TO lwa_clritkey.
          APPEND lwa_clritkey TO lt_clritkey_t.
        ENDLOOP.
        PERFORM set_calc_req_item_doc_infocus USING lt_clritkey_t
                                               CHANGING lv_lock.
        IF lv_lock = 0.

          gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
          PERFORM read_contract_details USING gs_clrqdoc_infocus-x-crhdr-vgbel.
          PERFORM select_calc_req_typ USING gs_clrqdoc_infocus-x-crhdr-clrqt.
          PERFORM select_item_catgs USING gs_clrqdoc_infocus-x-crhdr-clrqt.
          SORT gs_clrqdoc_infocus-x-crcon BY clrdit DESCENDING.
          PERFORM select_realtime_billprf_data USING gs_clrqdoc_infocus-x-crhdr-rtbpn.
          CLEAR gt_msg_return.
          DELETE lt_clritkey_t WHERE clrsit = '000000'.
          DELETE lt_clrqpit_key WHERE clrsit = '000000'.
          IF NOT is_parallel_process-parallel IS INITIAL
             AND is_parallel_process-background_job IS INITIAL.

            EXPORT gs_variables TO DATABASE /cgdc/_clrq_indx(cr) ID 'VARIABLES'. ""Memory is not being used,,,, NMOTWANI

            DO.
              gs_parallel_porcess-total_session_count = gs_parallel_porcess-total_session_count + 1.
              CLEAR lv_no_attempt.
              IF lt_clritkey_t IS INITIAL.
                EXIT.
              ENDIF.

              DO.
                CLEAR lv_row_count.
                LOOP AT lt_clritkey_t INTO lwa_clritkey.
                  lv_row_count = lv_row_count + 1.
                  IF lv_row_count  GT gs_variables-cmfrq .
                    EXIT.
                  ENDIF.

                  APPEND lwa_clritkey TO lt_clritkey_temp.

                  CLEAR lwa_clrqpit_new.
                  lwa_clrqpit_new = CORRESPONDING #( lwa_clritkey ).
                  APPEND lwa_clrqpit_new TO lt_clrqpit_temp.

                  DELETE lt_clritkey_t.
                ENDLOOP.


                CALL FUNCTION '/CGDC/CLRQ_RTB_PRL_REPRICE'
                  STARTING NEW TASK gs_parallel_porcess-total_session_count
                  DESTINATION IN GROUP is_parallel_process-server_group
                  PERFORMING post_prl_reprice_calc_item
                  ON END OF TASK
                  EXPORTING
                    i_vbeln               = i_vbeln
                    it_clrqpitkey_t       = lt_clrqpit_temp
                    it_coep_ori           = lt_coep_ori
                    is_rtbp               = gs_rtbp
                  TABLES
                    et_return_tab         = et_return
                  EXCEPTIONS
                    communication_failure = 1
                    system_failure        = 2
                    resource_failure      = 3
                    OTHERS                = 4.
                IF sy-subrc <> 0.

                  CLEAR gs_messages.
                  gs_messages-msgid = gc_rtbp_msg_cls.
                  gs_messages-msgnr = '012'.
                  gs_messages-msgty = gc_message_type-succes.
                  gs_messages-msgv1 = gs_parallel_porcess-total_session_count.
                  gs_messages-msgv2 = lv_no_attempt.
                  APPEND gs_messages TO gt_messages.
                  lv_no_attempt = lv_no_attempt + 1.

                  IF lv_no_attempt GE is_parallel_process-retrie.
                    lv_max_attempt_failure = abap_true.
                    EXIT.
                  ELSE.
                    WAIT UP TO is_parallel_process-max_wait SECONDS.
                  ENDIF.

                ELSE.
                  gs_parallel_porcess-active_session_count = gs_parallel_porcess-active_session_count + 1.
                  CLEAR gs_messages.
                  gs_messages-msgid = gc_rtbp_msg_cls.
                  gs_messages-msgnr = gc_msg_cls_msgnr-013.
                  gs_messages-msgty = gc_message_type-succes.
                  gs_messages-msgv1 = gs_parallel_porcess-total_session_count.
                  APPEND gs_messages TO gt_messages.
                  EXIT.
                ENDIF.
              ENDDO.

              IF NOT lv_max_attempt_failure IS INITIAL.
                CLEAR gs_messages.
                gs_messages-msgid = gc_rtbp_msg_cls.
                gs_messages-msgnr = '011'.
                gs_messages-msgty = gc_message_type-succes.
                APPEND gs_messages TO gt_messages.
                EXIT.
              ENDIF.

              WAIT UNTIL gs_parallel_porcess-active_session_count LT is_parallel_process-max_process.
            ENDDO.
            WAIT UNTIL gs_parallel_porcess-active_session_count EQ 0.
            et_return = gt_msg_return.
          ELSE.
            SORT lt_clrqpit_key BY clrit clrsit.
            DELETE ADJACENT DUPLICATES FROM lt_clrqpit_key COMPARING clrit clrsit.
            LOOP AT lt_clrqpit_key INTO lwa_clrqpit_key.
              CLEAR gs_clrit_org.
              READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item> WITH KEY clrit = lwa_clrqpit_key-clrit
                                                                                        clrsit = '000000'.
              IF sy-subrc = 0.
                READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_sub> WITH KEY clrit = lwa_clrqpit_key-clrit
                                                                                           clrsit = lwa_clrqpit_key-clrsit
                                                                                           clrdit = '000000'.
                IF sy-subrc = 0.
                  READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_delta> WITH KEY clrno = <lwa_clrit_sub>-clrno
                                                                                           clrit = <lwa_clrit_sub>-clrit
                                                                                           clrsit = <lwa_clrit_sub>-clrsit
                                                                                           clrdit = <lwa_clrit_sub>-ldetla.
                  IF <lwa_clrit_delta> IS ASSIGNED.
                    MOVE-CORRESPONDING lwa_clrqpit_key TO lwa_clrqpit.
                    lwa_clrqpit-updkz = gc_updkz_new.
                    APPEND lwa_clrqpit TO lt_clrqpit.
                    IF <lwa_clrit_delta>-istat EQ gc_ibill_stat-copied OR <lwa_clrit_delta>-istat EQ gc_ibill_stat-delta
                      OR <lwa_clrit_delta>-istat EQ gc_ibill_stat-copied_to_subitems OR <lwa_clrit_delta>-reversed IS NOT INITIAL OR
                         <lwa_clrit_delta>-itmty = gc_clrq_itmty-bill_plan_line.
                      CONTINUE.
                    ENDIF.
                    IF <lwa_clrit_item>-no_price EQ abap_false.
                      READ TABLE gs_clrqdoc_infocus-x-crcon INTO lwa_crcon WITH KEY clrit = <lwa_clrit_delta>-clrit
                                                                clrsit = <lwa_clrit_delta>-clrsit
                                                                clrdit = <lwa_clrit_delta>-clrdit
                                                                kschl = gs_rtbp-ccond.
                      IF sy-subrc <> 0.
                        CLEAR lwa_crcon.
                      ENDIF.
                    ENDIF.

*                    READ TABLE gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WITH KEY clrno = <lwa_clrit_delta>-clrno
*                                                                                     bill_item = <lwa_clrit_delta>-rtbbinr
*                                                                                     bitype = <lwa_clrit_delta>-bityp .
*                    IF sy-subrc = 0 AND lwa_crbinr-bstat IS NOT INITIAL.
*                      gs_variables-billed_item = abap_true.
*                    ELSE.
*                      CLEAR gs_variables-billed_item.
*                    ENDIF.
                    CLEAR gs_variables-billed_item.
                    LOOP AT gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WHERE bstat IS NOT INITIAL.
                      READ TABLE gs_clrqdoc_infocus-x-critm TRANSPORTING NO FIELDS WITH KEY clrno = <lwa_clrit_delta>-clrno
                                                                                            clrit = <lwa_clrit_delta>-clrit
                                                                                            rtbbinr = lwa_crbinr-bill_item.
                      IF sy-subrc = 0.
                        gs_variables-billed_item = 'X'.
                        EXIT.
                      ENDIF.
                    ENDLOOP.
                    CLEAR:lwa_clrq_itm_new.
                    PERFORM move_itm_to_itm_fcat USING <lwa_clrit_delta>
                                    CHANGING lwa_clrq_itm_new.
                    lwa_clrq_itm_new-duepos = <lwa_clrit_delta>-clrdit.
                    gs_variables-process_type = gc_updkz_update.

                    <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla + 1.
                    CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                      EXPORTING
                        input  = <lwa_clrit_sub>-ldetla
                      IMPORTING
                        output = <lwa_clrit_sub>-ldetla.
                    IF gs_variables-billed_item IS NOT INITIAL.
                      lwa_clrq_itm_new-istat = gc_ibill_stat-copied.
                    ENDIF.

                    gs_clrit_org-clrno = <lwa_clrit_delta>-clrno.
                    gs_clrit_org-clrit = <lwa_clrit_delta>-clrit.
                    gs_clrit_org-clrsit = <lwa_clrit_delta>-clrsit.
                    gs_clrit_org-item_delta = <lwa_clrit_sub>-ldetla.
                    gs_variables-process_type = gc_updkz_update.

                    IF <lwa_clrit_item>-no_price EQ abap_true.
                      lwa_clrq_itm_new-kbetr1 = <lwa_clrit_item>-kbetr1.
                      <lwa_clrit_item>-no_price = abap_false.
                      gs_clrit_org-istat = gc_ibill_stat-open.

                    ELSE.
                      IF gs_variables-billed_item IS NOT INITIAL.
                        "last billed status
                        LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WHERE clrno = <lwa_clrit_delta>-clrno
                                                                                      AND clrit = <lwa_clrit_delta>-clrit
*                                                                                      AND clrsit = <lwa_clrit_delta>-clrsit
                                                                                      AND istat = gc_ibill_stat-copied.
*                                                                                      AND rtbbinr IS NOT INITIAL.
                        ENDLOOP.

                        IF <lwa_clrqit_last_copied> IS ASSIGNED.
*                          READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = lwa_last_billed-clrno
*                                                                                                          clrit = lwa_last_billed-clrit
*                                                                                                          clrsit = lwa_last_billed-cuepos
*                                                                                                          clrdit = lwa_last_billed-duepos.
*                          IF sy-subrc <> 0.

                          IF lwa_last_billed-cuepos IS NOT INITIAL AND lwa_last_billed-duepos IS NOT INITIAL.
                            READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = lwa_last_billed-clrno
                                                                                                            clrit = lwa_last_billed-clrit
                                                                                                            clrsit = lwa_last_billed-cuepos
                                                                                                            clrdit = lwa_last_billed-duepos.
                          ENDIF.
                          IF <lwa_clrqit_last_copied> IS ASSIGNED.
                            READ TABLE gs_clrqdoc_infocus-x-crcon INTO lwa_crcon WITH KEY clrit = <lwa_clrqit_last_copied>-clrit
                                                              clrsit = <lwa_clrqit_last_copied>-clrsit
                                                              clrdit = <lwa_clrqit_last_copied>-clrdit
                                                              kschl = gs_rtbp-ccond.
                            IF sy-subrc <> 0.
                              CLEAR lwa_crcon.
                            ENDIF.
                          ENDIF.
*                        ENDIF.
*                          ENDIF.
                        ENDIF.
                      ENDIF.
                      IF lwa_crcon-kbetr IS NOT INITIAL.

                        ls_src_wbs = VALUE #( gt_add_cost_collector[ vbeln =  lwa_clrq_itm_new-vgbel
                                                                            wbs_cost_col = lwa_clrq_itm_new-cc_pspnr
                                                                            wbsel = lwa_clrq_itm_new-ps_psp_pnr ]
                                                                            OPTIONAL ).
                        IF ls_src_wbs-multi_payer_ind = abap_false.
                          lwa_clrq_itm_new-kbetr1 = lwa_crcon-kbetr.
                        ELSE.
                          lwa_clrq_itm_new-kbetr1 = <lwa_clrit_item>-kbetr1.
                        ENDIF.
*                        ELSE.
*                          lwa_clrq_itm_new-kbetr1 = lwa_crcon-kbetr.
*                        ENDIF.
                      ELSE.
                        lwa_clrq_itm_new-kbetr1 = <lwa_clrit_delta>-netwr.
                      ENDIF.
                    ENDIF.
                    IF gs_variables-billed_item IS NOT INITIAL AND <lwa_clrqit_last_copied> IS ASSIGNED.
                      lwa_clrq_itm_new-cuepos = <lwa_clrqit_last_copied>-clrsit.
                      lwa_clrq_itm_new-duepos = <lwa_clrqit_last_copied>-clrdit.
                    ELSE.
                      lwa_clrq_itm_new-cuepos = <lwa_clrit_delta>-clrsit.
                      lwa_clrq_itm_new-duepos = <lwa_clrit_delta>-clrdit.
                    ENDIF.
                    gs_variables-bit_num_gen = abap_true.

                    CLEAR : lwa_clrq_itm_new-rtbbinr.
                    IF it_rtbclnms IS NOT INITIAL OR it_rtbwbsmcs IS NOT INITIAL.
                      LOOP AT it_rtbclnms INTO lwa_clnmcs WHERE ( begdat LE lwa_clrq_itm_new-budat
                                                            AND enddat GE lwa_clrq_itm_new-budat )
                                                            AND posnr = lwa_clrq_itm_new-/cgdc/orgi.
                        lv_action_cd = lwa_clnmcs-action_cd.
                        EXIT.
                      ENDLOOP.
                      "PRPS NITIN 19.01.2023
                      IF it_rtbwbsmcs IS NOT INITIAL AND lv_action_cd IS INITIAL.
                        READ TABLE lt_prps INTO lwa_prps WITH KEY pspnr = lwa_clrq_itm_new-cc_pspnr.
                        IF sy-subrc = 0.
                          LOOP AT it_rtbwbsmcs INTO lwa_wbsmcs WHERE ( begdat LE lwa_clrq_itm_new-budat
                                                                    AND enddat GE lwa_clrq_itm_new-budat )
                                                                  AND objnr = lwa_prps-objnr.
                            lv_action_cd = lwa_wbsmcs-action_cd.
                          ENDLOOP.
                        ENDIF.
                      ENDIF.
                    ELSE.
                      lv_action_cd = lwa_clrqpit-action_cd.
                    ENDIF.
                    PERFORM assign_reprice_code USING lv_action_cd
                                                CHANGING lwa_clrq_itm_new.
                    PERFORM repricing USING  lwa_item_old
                                                   CHANGING lwa_clrq_itm_new.
                    IF gs_clrit_org-istat IS INITIAL.

                      <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla - 1.
                      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                        EXPORTING
                          input  = <lwa_clrit_sub>-ldetla
                        IMPORTING
                          output = <lwa_clrit_sub>-ldetla.
                      CONTINUE.
*                    ELSEIF gs_clrit_org-istat <> gc_ibill_stat-copied.
*                      CONTINUE.
                    ENDIF.
                    <lwa_clrit_delta>-istat = gc_ibill_stat-delta.
*                    IF gs_variables-billed_item IS INITIAL.
                    READ TABLE gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WITH KEY bill_item = <lwa_clrit_delta>-rtbbinr.
                    IF sy-subrc = 0 AND lwa_crbinr-bstat IS INITIAL.
                      CLEAR <lwa_clrit_delta>-rtbbinr.
                    ENDIF.
*                    ENDIF.
                    <lwa_clrit_delta>-updkz = gc_updkz_update.
                    <lwa_clrit_sub>-updkz = gc_updkz_update.
                    IF <lwa_clrit_delta>-cuepos IS INITIAL .
                      <lwa_clrit_delta>-cuepos = <lwa_clrit_delta>-clrsit.
                    ENDIF.
                    gs_clrqdoc_infocus-x-crhdr-netwr = <lwa_clrit_delta>-netwr.
                    "++SOC - decimal precision field
                    gs_clrqdoc_infocus-x-crhdr-netwr24 = <lwa_clrit_delta>-netwr24.
                    "++EOC - decimal precision field

                    IF gs_variables-billed_item IS NOT INITIAL..

                      IF <lwa_clrqit_last_copied> IS NOT ASSIGNED.

                        READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = <lwa_clrit_delta>-clrno
                                                                                                        clrit = <lwa_clrit_delta>-clrit
                                                                                                        clrsit = <lwa_clrit_delta>-clrsit
                                                                                                        istat = gc_ibill_stat-copied.
                        IF <lwa_clrqit_last_copied> IS ASSIGNED.
                        ELSE.
                          CONTINUE.
                        ENDIF.
                      ENDIF.
                      IF <lwa_clrqit_last_copied> IS ASSIGNED.
                        IF <lwa_clrqit_last_copied>-updkz <> gc_updkz_new.
                          <lwa_clrqit_last_copied>-istat = gc_ibill_stat-delta.
                          <lwa_clrqit_last_copied>-updkz = gc_updkz_update.
                        ENDIF.
                      ENDIF.

                      APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_critm_copied>.

                      MOVE-CORRESPONDING lwa_clrq_itm_new TO <lwa_critm_copied>.
                      <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla + 1.
                      CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
                        EXPORTING
                          input  = <lwa_clrit_sub>-ldetla
                        IMPORTING
                          output = <lwa_clrit_sub>-ldetla.
                      <lwa_critm_copied>-clrsit = <lwa_clrit_sub>-clrsit.
                      <lwa_critm_copied>-clrit = <lwa_clrit_item>-clrit.
                      <lwa_critm_copied>-clrdit = <lwa_clrit_sub>-ldetla.
                      <lwa_critm_copied>-ldetla = '000000'.
                      <lwa_critm_copied>-cuepos = lwa_clrq_itm_new-clrsit.
                      <lwa_critm_copied>-duepos = lwa_clrq_itm_new-clrdit.
                      <lwa_critm_copied>-rtbbinr = lwa_clrq_itm_new-rtbbinr.
                      IF  <lwa_clrqit_last_copied> IS ASSIGNED AND <lwa_clrqit_last_copied>-clrdit <> lwa_clrq_itm_new-clrdit.
*                        <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - <lwa_clrqit_last_copied>-netwr .
                        <lwa_critm_copied>-netwr =  lwa_clrq_itm_new-netwr - ( <lwa_clrqit_last_copied>-netwr - <lwa_clrit_delta>-netwr )   .""
                        "++SOC - decimal precision field
*                      <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - <lwa_clrqit_last_copied>-netwr24 .
                        <lwa_critm_copied>-netwr24 =  lwa_clrq_itm_new-netwr24 - ( <lwa_clrqit_last_copied>-netwr24 - <lwa_clrit_delta>-netwr24 )   .""20.09.24
                        "++EOC - decimal precision field
                      ELSE.
                        <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - <lwa_clrit_delta>-netwr .
                        "++SOC - decimal precision field
                        <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - <lwa_clrit_delta>-netwr24 .
                        "++EOC - decimal precision field
                      ENDIF.
                      gs_clrqdoc_infocus-x-crhdr-netwr = gs_clrqdoc_infocus-x-crhdr-netwr + <lwa_critm_copied>-netwr.
                      "++SOC - decimal precision field
                      gs_clrqdoc_infocus-x-crhdr-netwr24 = gs_clrqdoc_infocus-x-crhdr-netwr24 + <lwa_critm_copied>-netwr24.
                      "++EOC - decimal precision field
                      <lwa_critm_copied>-updkz = gc_updkz_new.
                      <lwa_critm_copied>-istat = gc_ibill_stat-open.
                      PERFORM create_billing_item CHANGING <lwa_critm_copied>.
                      CLEAR <lwa_critm_copied>-bstat.
                      lt_crcon_copied = gs_clrqdoc_infocus-x-crcon.
                      lt_clrqcs_copied = gs_clrqdoc_infocus-x-cscon.

                      IF <lwa_clrqit_last_copied> IS ASSIGNED AND <lwa_clrqit_last_copied>-clrdit <> lwa_clrq_itm_new-clrdit.
                        lt_crcon_copied_c = gs_clrqdoc_infocus-x-crcon.
                        lt_clrqcs_copied_c = gs_clrqdoc_infocus-x-cscon.
                        DELETE lt_crcon_copied_c WHERE clrit <> <lwa_clrqit_last_copied>-clrit OR
                                                     clrsit <> <lwa_clrqit_last_copied>-clrsit OR
                                                     clrdit <> <lwa_clrqit_last_copied>-clrdit.

                        DELETE lt_clrqcs_copied_c WHERE clrit <> <lwa_clrqit_last_copied>-clrit OR
                                                     clrsit <> <lwa_clrqit_last_copied>-clrsit OR
                                                     clrdit <> <lwa_clrqit_last_copied>-clrdit.
                      ENDIF.
                      DELETE lt_crcon_copied WHERE clrit <> <lwa_clrit_delta>-clrit OR
                                                   clrsit <> <lwa_clrit_delta>-clrsit OR
                                                   clrdit  <> <lwa_clrit_delta>-clrdit.
                      DELETE lt_clrqcs_copied WHERE clrit <> <lwa_clrit_delta>-clrit OR
                                                   clrsit <> <lwa_clrit_delta>-clrsit OR
                                                   clrdit  <> <lwa_clrit_delta>-clrdit.
*                        ENDIF.
                      lt_crcon_copied_t = lt_crcon_copied[].
                      lt_clrqcs_copied_t = lt_clrqcs_copied[].

                      READ TABLE gs_clrqdoc_infocus-x-crcon TRANSPORTING NO FIELDS WITH KEY clrit = lwa_clrq_itm_new-clrit
                                                                                      clrsit = lwa_clrq_itm_new-clrsit
                                                                                      clrdit = lwa_clrq_itm_new-clrdit.
                      IF sy-subrc = 0.
                        LOOP AT gs_clrqdoc_infocus-x-crcon INTO lwa_crcon_new FROM sy-tabix.
                          IF lwa_crcon_new-clrno <> lwa_clrq_itm_new-clrno
                            OR lwa_crcon_new-clrit <> lwa_clrq_itm_new-clrit
                            OR lwa_crcon_new-clrsit <> lwa_clrq_itm_new-clrsit
                            OR lwa_crcon_new-clrdit <> lwa_clrq_itm_new-clrdit.
                            EXIT.
                          ELSE.
                            lwa_crcon_new_t = lwa_crcon_new.
                            READ TABLE lt_crcon_copied INTO lwa_crcon_delta WITH KEY kschl = lwa_crcon_new-kschl.
                            IF sy-subrc = 0.
                              DELETE lt_crcon_copied_t WHERE kschl = lwa_crcon_new-kschl.
                              CLEAR : lwa_crcon_delta-clrit,
                                      lwa_crcon_delta-clrdit,
                                      lwa_crcon_delta-clrsit,
                                      lwa_crcon_delta-stunr,
                                      lwa_crcon_delta-zaehk,
                                      lwa_crcon_new-clrit,
                                      lwa_crcon_new-clrdit,
                                      lwa_crcon_new-clrsit,
                                      lwa_crcon_new-stunr,
                                      lwa_crcon_new-zaehk.
                              IF lwa_crcon_delta <> lwa_crcon_new.
                                APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                                MOVE-CORRESPONDING lwa_crcon_new_t TO <lwa_crcon_copied>.
                                READ TABLE lt_crcon_copied_c INTO lwa_crcon_c WITH KEY kschl = lwa_crcon_delta-kschl.
                                IF sy-subrc <> 0.
                                  <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                  <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                  <lwa_crcon_copied>-kbetr =  lwa_crcon_new-kbetr - lwa_crcon_delta-kbetr .
                                  <lwa_crcon_copied>-kawrt =  lwa_crcon_new-kawrt - lwa_crcon_delta-kawrt.
                                  <lwa_crcon_copied>-kwert =  lwa_crcon_new-kwert - lwa_crcon_delta-kwert.

                                  <lwa_crcon_copied>-kbetr24 =  lwa_crcon_new-kbetr24 - lwa_crcon_delta-kbetr24 .
                                  <lwa_crcon_copied>-kawrt24 =  lwa_crcon_new-kawrt24 - lwa_crcon_delta-kawrt24.
                                  <lwa_crcon_copied>-kwert24 =  lwa_crcon_new-kwert24 - lwa_crcon_delta-kwert24.
                                  <lwa_crcon_copied>-updkz = gc_updkz_new.
                                ELSE.
                                  <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                  <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                  <lwa_crcon_copied>-kbetr =  lwa_crcon_new-kbetr + lwa_crcon_delta-kbetr - lwa_crcon_c-kbetr .
                                  <lwa_crcon_copied>-kawrt =  lwa_crcon_new-kawrt + lwa_crcon_delta-kawrt - lwa_crcon_c-kawrt.
                                  <lwa_crcon_copied>-kwert =  lwa_crcon_new-kwert + lwa_crcon_delta-kwert - lwa_crcon_c-kwert.

                                  <lwa_crcon_copied>-kbetr24 =  lwa_crcon_new-kbetr24 + lwa_crcon_delta-kbetr24  - lwa_crcon_c-kbetr24.
                                  <lwa_crcon_copied>-kawrt24 =  lwa_crcon_new-kawrt24 + lwa_crcon_delta-kawrt24 - lwa_crcon_c-kawrt24.
                                  <lwa_crcon_copied>-kwert24 =  lwa_crcon_new-kwert24 + lwa_crcon_delta-kwert24 - lwa_crcon_c-kwert24.
                                  <lwa_crcon_copied>-updkz = gc_updkz_new.
                                ENDIF.
                              ENDIF.
                            ELSE.
                              APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                              MOVE-CORRESPONDING lwa_crcon_new_t TO <lwa_crcon_copied>.
                              <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                              <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                              <lwa_crcon_copied>-updkz = gc_updkz_new.
                            ENDIF.
                          ENDIF.
                        ENDLOOP.
                        IF lt_crcon_copied_t IS NOT INITIAL.
                          LOOP AT lt_crcon_copied_t INTO lwa_crcon_delta.
                            APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                            MOVE-CORRESPONDING lwa_crcon_delta TO <lwa_crcon_copied>.
                            <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                            <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                            <lwa_crcon_copied>-kbetr =  0 - lwa_crcon_delta-kbetr .
                            <lwa_crcon_copied>-kawrt =  0 - lwa_crcon_delta-kawrt.
                            <lwa_crcon_copied>-kwert =  0 - lwa_crcon_delta-kwert.

                            <lwa_crcon_copied>-kbetr24 =  0 - lwa_crcon_delta-kbetr24 .
                            <lwa_crcon_copied>-kawrt24 =  0 - lwa_crcon_delta-kawrt24.
                            <lwa_crcon_copied>-kwert24 =  0 - lwa_crcon_delta-kwert24.
                            <lwa_crcon_copied>-updkz = gc_updkz_new.
                          ENDLOOP.
                        ENDIF.

                      ENDIF.
                      ""COSTING SHEET 7142
                      READ TABLE gs_clrqdoc_infocus-x-cscon TRANSPORTING NO FIELDS WITH KEY clrit = lwa_clrq_itm_new-clrit
                                                              clrsit = lwa_clrq_itm_new-clrsit
                                                              clrdit = lwa_clrq_itm_new-clrdit.
                      IF sy-subrc = 0.
                        LOOP AT gs_clrqdoc_infocus-x-cscon INTO lwa_crconcs_new FROM sy-tabix.
                          IF lwa_crconcs_new-clrno <> lwa_clrq_itm_new-clrno
                            OR lwa_crconcs_new-clrit <> lwa_clrq_itm_new-clrit
                            OR lwa_crconcs_new-clrsit <> lwa_clrq_itm_new-clrsit
                            OR lwa_crconcs_new-clrdit <> lwa_clrq_itm_new-clrdit.
                            EXIT.
                          ELSE.
                            lwa_crconcs_new_t = lwa_crconcs_new.
                            READ TABLE lt_clrqcs_copied INTO lwa_crconcs_delta WITH KEY kschl = lwa_crconcs_new-kschl.
                            IF sy-subrc = 0.
                              DELETE lt_clrqcs_copied_t WHERE kschl = lwa_crconcs_new-kschl.
                              CLEAR : lwa_crconcs_delta-clrit,
                                      lwa_crconcs_delta-clrdit,
                                      lwa_crconcs_delta-clrsit,
                                      lwa_crconcs_delta-stunr,
                                      lwa_crconcs_delta-zaehk,
                                      lwa_crconcs_new-clrit,
                                      lwa_crconcs_new-clrdit,
                                      lwa_crconcs_new-clrsit,
                                      lwa_crconcs_new-stunr,
                                      lwa_crconcs_new-zaehk.
                              IF lwa_crconcs_delta <> lwa_crconcs_new.
                                APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-cscon ASSIGNING <lwa_crconcs_copied>.

                                MOVE-CORRESPONDING lwa_crconcs_new_t TO <lwa_crconcs_copied>.
                                READ TABLE lt_clrqcs_copied_c INTO lwa_crconcs_c WITH KEY kschl = lwa_crcon_delta-kschl.
                                IF sy-subrc <> 0.
                                  <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                  <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                  <lwa_crconcs_copied>-kbetr =  lwa_crconcs_new-kbetr - lwa_crconcs_delta-kbetr .
                                  <lwa_crconcs_copied>-kawrt =  lwa_crconcs_new-kawrt - lwa_crconcs_delta-kawrt.
                                  <lwa_crconcs_copied>-kwert =  lwa_crconcs_new-kwert - lwa_crconcs_delta-kwert.

                                  <lwa_crconcs_copied>-kbetr24 =  lwa_crconcs_new-kbetr24 - lwa_crconcs_delta-kbetr24 .
                                  <lwa_crconcs_copied>-kawrt24 =  lwa_crconcs_new-kawrt24 - lwa_crconcs_delta-kawrt24.
                                  <lwa_crconcs_copied>-kwert24 =  lwa_crconcs_new-kwert24 - lwa_crconcs_delta-kwert24.
                                  <lwa_crconcs_copied>-updkz = gc_updkz_new.
                                ELSE.
                                  <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                                  <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                                  <lwa_crconcs_copied>-kbetr =  lwa_crconcs_new-kbetr + lwa_crconcs_delta-kbetr - lwa_crconcs_c-kbetr .
                                  <lwa_crconcs_copied>-kawrt =  lwa_crconcs_new-kawrt + lwa_crconcs_delta-kawrt - lwa_crconcs_c-kawrt.
                                  <lwa_crconcs_copied>-kwert =  lwa_crconcs_new-kwert + lwa_crconcs_delta-kwert - lwa_crconcs_c-kwert.

                                  <lwa_crconcs_copied>-kbetr24 =  lwa_crconcs_new-kbetr24 + lwa_crconcs_delta-kbetr24  - lwa_crconcs_c-kbetr24.
                                  <lwa_crconcs_copied>-kawrt24 =  lwa_crconcs_new-kawrt24 + lwa_crconcs_delta-kawrt24 - lwa_crconcs_c-kawrt24.
                                  <lwa_crconcs_copied>-kwert24 =  lwa_crconcs_new-kwert24 + lwa_crconcs_delta-kwert24 - lwa_crconcs_c-kwert24.
                                  <lwa_crconcs_copied>-updkz = gc_updkz_new.
                                ENDIF.

                              ENDIF.
                            ELSE.
                              APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-cscon ASSIGNING <lwa_crconcs_copied>.
                              MOVE-CORRESPONDING lwa_crconcs_new_t TO <lwa_crconcs_copied>.
                              <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                              <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                              <lwa_crconcs_copied>-updkz = gc_updkz_new.
                            ENDIF.
                          ENDIF.
                        ENDLOOP.
                        IF lt_clrqcs_copied_t IS NOT INITIAL.
                          LOOP AT lt_clrqcs_copied_t INTO lwa_crconcs_delta.
                            APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-cscon ASSIGNING <lwa_crconcs_copied>.
                            MOVE-CORRESPONDING lwa_crcon_delta TO <lwa_crconcs_copied>.
                            <lwa_crconcs_copied>-clrsit = <lwa_critm_copied>-clrsit.
                            <lwa_crconcs_copied>-clrdit = <lwa_critm_copied>-clrdit.
                            <lwa_crconcs_copied>-kbetr =  0 - lwa_crconcs_delta-kbetr .
                            <lwa_crconcs_copied>-kawrt =  0 - lwa_crconcs_delta-kawrt.
                            <lwa_crconcs_copied>-kwert =  0 - lwa_crconcs_delta-kwert.

                            <lwa_crconcs_copied>-kbetr24 =  0 - lwa_crconcs_delta-kbetr24 .
                            <lwa_crconcs_copied>-kawrt24 =  0 - lwa_crconcs_delta-kawrt24.
                            <lwa_crconcs_copied>-kwert24 =  0 - lwa_crconcs_delta-kwert24.
                            <lwa_crconcs_copied>-updkz = gc_updkz_new.
                          ENDLOOP.
                        ENDIF.
                      ENDIF.
                    ENDIF.

                    IF gs_clrit_org-istat <> gc_ibill_stat-copied.
                      <lwa_clrit_item>-netwr = ( <lwa_clrit_item>-netwr - <lwa_clrit_delta>-netwr ) + lwa_clrq_itm_new-netwr.

                      "++SOC - DCLM 6423 subtotal not populated
                      <lwa_clrit_item>-kzwi1 = ( <lwa_clrit_item>-kzwi1 - <lwa_clrit_delta>-kzwi1 ) + lwa_clrq_itm_new-kzwi1.
                      <lwa_clrit_item>-kzwi2 = ( <lwa_clrit_item>-kzwi2 - <lwa_clrit_delta>-kzwi2 ) + lwa_clrq_itm_new-kzwi2.
                      <lwa_clrit_item>-kzwi3 = ( <lwa_clrit_item>-kzwi3 - <lwa_clrit_delta>-kzwi3 ) + lwa_clrq_itm_new-kzwi3.
                      <lwa_clrit_item>-kzwi4 = ( <lwa_clrit_item>-kzwi4 - <lwa_clrit_delta>-kzwi4 ) + lwa_clrq_itm_new-kzwi4.
                      <lwa_clrit_item>-kzwi5 = ( <lwa_clrit_item>-kzwi5 - <lwa_clrit_delta>-kzwi5 ) + lwa_clrq_itm_new-kzwi5.
                      <lwa_clrit_item>-kzwi6 = ( <lwa_clrit_item>-kzwi6 - <lwa_clrit_delta>-kzwi6 ) + lwa_clrq_itm_new-kzwi6.
                      "++EOC - DCLM 6423 subtotal not populated
                      <lwa_clrit_item>-wbs_allocation = lwa_clrq_itm_new-wbs_allocation.

                      "++SOC - Decimal precision fields
                      <lwa_clrit_item>-netwr24  = ( <lwa_clrit_item>-netwr24 - <lwa_clrit_delta>-netwr24 ) + lwa_clrq_itm_new-netwr24.
                      <lwa_clrit_item>-kzwi1_24 = ( <lwa_clrit_item>-kzwi1_24 - <lwa_clrit_delta>-kzwi1_24 ) + lwa_clrq_itm_new-kzwi1_24.
                      <lwa_clrit_item>-kzwi2_24 = ( <lwa_clrit_item>-kzwi2_24 - <lwa_clrit_delta>-kzwi2_24 ) + lwa_clrq_itm_new-kzwi2_24.
                      <lwa_clrit_item>-kzwi3_24 = ( <lwa_clrit_item>-kzwi3_24 - <lwa_clrit_delta>-kzwi3_24 ) + lwa_clrq_itm_new-kzwi3_24.
                      <lwa_clrit_item>-kzwi4_24 = ( <lwa_clrit_item>-kzwi4_24 - <lwa_clrit_delta>-kzwi4_24 ) + lwa_clrq_itm_new-kzwi4_24.
                      <lwa_clrit_item>-kzwi5_24 = ( <lwa_clrit_item>-kzwi5_24 - <lwa_clrit_delta>-kzwi5_24 ) + lwa_clrq_itm_new-kzwi5_24.
                      <lwa_clrit_item>-kzwi6_24 = ( <lwa_clrit_item>-kzwi6_24 - <lwa_clrit_delta>-kzwi6_24 ) + lwa_clrq_itm_new-kzwi6_24.
                      "++EOC - Decimal precision fields
                      gs_clrqdoc_infocus-x-crhdr-netwr = ( gs_clrqdoc_infocus-x-crhdr-netwr - <lwa_clrit_delta>-netwr ) + lwa_clrq_itm_new-netwr.
                      "++SOC - decimal precision field
                      gs_clrqdoc_infocus-x-crhdr-netwr24 = ( gs_clrqdoc_infocus-x-crhdr-netwr24 - <lwa_clrit_delta>-netwr24 ) + lwa_clrq_itm_new-netwr24.
                      "++EOC - decimal precision field
                      gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
                    ELSE.
                      <lwa_clrit_item>-netwr = <lwa_clrit_item>-netwr  + <lwa_critm_copied>-netwr - <lwa_clrit_delta>-netwr.
                      "++SOC - DCLM 6423 subtotal not populated
                      <lwa_clrit_item>-kzwi1 = <lwa_clrit_item>-kzwi1 + <lwa_critm_copied>-kzwi1  - <lwa_clrit_delta>-kzwi1.
                      <lwa_clrit_item>-kzwi2 = <lwa_clrit_item>-kzwi2 + <lwa_critm_copied>-kzwi2 - <lwa_clrit_delta>-kzwi2.
                      <lwa_clrit_item>-kzwi3 = <lwa_clrit_item>-kzwi3 + <lwa_critm_copied>-kzwi3 - <lwa_clrit_delta>-kzwi3.
                      <lwa_clrit_item>-kzwi4 = <lwa_clrit_item>-kzwi4 + <lwa_critm_copied>-kzwi4 - <lwa_clrit_delta>-kzwi4.
                      <lwa_clrit_item>-kzwi5 = <lwa_clrit_item>-kzwi5 + <lwa_critm_copied>-kzwi5 - <lwa_clrit_delta>-kzwi5.
                      <lwa_clrit_item>-kzwi6 = <lwa_clrit_item>-kzwi6 + <lwa_critm_copied>-kzwi6 - <lwa_clrit_delta>-kzwi6.
                      "++EOC - DCLM 6423 subtotal not populated

                      "++SOC - Decimal precision fields
                      <lwa_clrit_item>-netwr24  = <lwa_clrit_item>-netwr24  + <lwa_critm_copied>-netwr24 - <lwa_clrit_delta>-netwr24.
                      <lwa_clrit_item>-kzwi1_24 = <lwa_clrit_item>-kzwi1_24 + <lwa_critm_copied>-kzwi1_24 - <lwa_clrit_delta>-kzwi1_24.
                      <lwa_clrit_item>-kzwi2_24 = <lwa_clrit_item>-kzwi2_24 + <lwa_critm_copied>-kzwi2_24 - <lwa_clrit_delta>-kzwi2_24.
                      <lwa_clrit_item>-kzwi3_24 = <lwa_clrit_item>-kzwi3_24 + <lwa_critm_copied>-kzwi3_24 - <lwa_clrit_delta>-kzwi3_24.
                      <lwa_clrit_item>-kzwi4_24 = <lwa_clrit_item>-kzwi4_24 + <lwa_critm_copied>-kzwi4_24 - <lwa_clrit_delta>-kzwi4_24.
                      <lwa_clrit_item>-kzwi5_24 = <lwa_clrit_item>-kzwi5_24 + <lwa_critm_copied>-kzwi5_24 - <lwa_clrit_delta>-kzwi5_24.
                      <lwa_clrit_item>-kzwi6_24 = <lwa_clrit_item>-kzwi6_24 + <lwa_critm_copied>-kzwi6_24 - <lwa_clrit_delta>-kzwi6_24.
                      "++EOC - Decimal precision fields
                      gs_clrqdoc_infocus-x-crhdr-netwr =  gs_clrqdoc_infocus-x-crhdr-netwr  + <lwa_critm_copied>-netwr.
                      "++SOC - decimal precision field
                      gs_clrqdoc_infocus-x-crhdr-netwr24 =  gs_clrqdoc_infocus-x-crhdr-netwr24  + <lwa_critm_copied>-netwr24.
                      "++EOC - decimal precision field

                      gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
                    ENDIF.
                    <lwa_clrit_item>-updkz = gc_updkz_update.
                    UNASSIGN <lwa_clrit_delta>.
                  ENDIF.
                ENDIF.
                UNASSIGN : <lwa_clrit_item>,
                           <lwa_clrit_sub>,
                           <lwa_clrit_delta>.
                CLEAR : lt_crcon_copied,
                        lt_crcon_copied_c.
                CLEAR : lt_clrqcs_copied,
                        lt_clrqcs_copied_c.

              ENDIF.
              IF <lwa_clrqit_last_copied> IS ASSIGNED.
                UNASSIGN <lwa_clrqit_last_copied>.
              ENDIF.
            ENDLOOP.

            APPEND gs_clrqdoc_infocus TO lt_clrqdoc.
            lwa_return-msgid = gc_clrq_msg_cls.
            lwa_return-msgty = gc_message_type-succes.
            lwa_return-msgnr = 012.
            lwa_return-msgv1 = gs_clrqdoc_infocus-x-crhdr-clrno.
            lwa_return-msgv2 = gs_clrqdoc_infocus-x-crhdr-vgbel.
            APPEND lwa_return TO et_return.
            CLEAR lwa_return.
          ENDIF.
        ENDIF.
        UNASSIGN <lwa_clrqit_last_copied>.
      ENDLOOP.
    ENDIF.
  ENDIF.
  IF lt_clrqdoc IS NOT INITIAL AND is_parallel_process-parallel IS INITIAL.

    IF gt_clrqpit IS INITIAL.
      PERFORM save_mass_documents USING lt_clrqdoc
                                        ''.
    ENDIF.

    CALL FUNCTION '/CGDC/CLRQ_CLRQPRS_UPDATE_DB' IN UPDATE TASK
      EXPORTING
        it_clrqpit = lt_clrqpit.
  ENDIF.

  IF gt_clrqpit IS INITIAL.
    CLEAR gs_clrqdoc_infocus.
  ENDIF.
  FREE gt_clrqpit.
ENDFUNCTION.

FUNCTION /cgdc/clrq_rtbc_process.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(I_VBELN) TYPE  VBELN_VA OPTIONAL
*"     REFERENCE(IT_SRC_TABLE) TYPE  TABLE OPTIONAL
*"     REFERENCE(I_PROCESS) TYPE  /CGDC/CLRQ_PROCESS OPTIONAL
*"     REFERENCE(I_CMFRQ) TYPE  NUMC10 OPTIONAL
*"     REFERENCE(I_COMMIT_WORK) TYPE  C DEFAULT 'X'
*"     REFERENCE(I_UPDATE_TASK) TYPE  C DEFAULT 'X'
*"     REFERENCE(IS_VBAK) TYPE  VBAK OPTIONAL
*"     REFERENCE(IT_VBAP) TYPE  /CGDC/TT_VBAP OPTIONAL
*"     REFERENCE(IT_VBKD) TYPE  VA_VBKDVB_T OPTIONAL
*"     REFERENCE(IS_CLRQHD) TYPE  /CGDC/S_CLRQHD OPTIONAL
*"     REFERENCE(IT_CLRNO) TYPE  /CGDC/TT_CLRQNO OPTIONAL
*"     REFERENCE(IS_PARALLEL_PROCESS) TYPE  /CGDC/S_PARALLEL_PROCESS
*"       OPTIONAL
*"     REFERENCE(I_NO_PRICING) TYPE  FLAG DEFAULT ABAP_FALSE
*"     REFERENCE(I_MEMORY_ID) TYPE  CHAR22 OPTIONAL
*"     REFERENCE(I_RTB_SRC) TYPE  /CGDC/RTBSOURCE OPTIONAL
*"     REFERENCE(I_RTBPN) TYPE  /CGDC/RTBPN OPTIONAL
*"     REFERENCE(IT_REALTIME_BILLELEM) TYPE  /CGDC/TT_BILLELEM OPTIONAL
*"     REFERENCE(IT_REALTIME_PRPS) TYPE  TT_PRPS OPTIONAL
*"     REFERENCE(IT_REALTIME_CONTR) TYPE  /CGDC/TT_CONTR_KEY OPTIONAL
*"     REFERENCE(I_REALTIME_PRIMTAB) TYPE  VIEWNAME OPTIONAL
*"     REFERENCE(IT_REALTIME_SOURCES) TYPE  /CGDC/TT_SOURCE_DATA
*"       OPTIONAL
*"     REFERENCE(IT_IFLOWDN) TYPE  /CGDC/TT_IFLOWDN OPTIONAL
*"  EXPORTING
*"     REFERENCE(ET_MESSAGE) TYPE  /CGDC/T_MESSAGE
*"  EXCEPTIONS
*"      CALC_REQ_LOCKED
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Real Time Billing Cockpit Process
**********************************************************

  DATA: ls_clrhqd  TYPE /cgdc/_clrqhd,
        lwa_clrno  TYPE /cgdc/s_clrqno,
        lv_clrno   TYPE /cgdc/_clrqhd-clrno,
        lv_cmfrq   TYPE numc10,
        lv_subrc   TYPE syst_subrc,
        lv_rp_flag TYPE c.

  DATA: lt_clrq_doc TYPE TABLE OF /cgdc/s_clrq_doc.

  DATA : lt_item_key      TYPE TABLE OF /cgdc/s_clrqit_key.

  DATA: lv_index_from  TYPE i,
        lv_index_to    TYPE i,
        lv_length      TYPE i,
        lv_exit_do     TYPE flag,
        lt_clrit_key_t TYPE /cgdc/tt_clrqit_key.
  DATA: lwa_clrit_key TYPE /cgdc/s_clrqit_key.
  CLEAR gt_srcdata.
  gs_variables-cmfrq = i_cmfrq.


  CLEAR: gs_variables-exit_loop,
         gs_variables-loop_count,
         gs_variables-rtbc_process,
         gs_variables-objnr_index,
         lv_subrc.
  FIELD-SYMBOLS: <lwa_bgwp_list> LIKE LINE OF gt_bgwp_list.
  gs_variables-no_pricing = i_no_pricing.
  gs_variables-rtbc_process = i_process.
  WHILE gs_variables-exit_loop IS INITIAL.

    PERFORM initialize_document_data. "Clear Global Data.

****subroutine to select contract datat in contract doc structure
    CASE i_process.
      WHEN gc_process_type-background. "Report
        gs_variables-bit_num_gen     = abap_true.
        gs_variables-collect_message = abap_true.
        PERFORM read_contract_details USING i_vbeln. "Read Contract Details

        "SOC ++14.03.24 - Check critical block on Contract before proceeding.
        CALL METHOD /cgdc/cl_rtb_src_db=>read_critical_blocks
          IMPORTING
            et_rng_block = DATA(lt_rng_block).
        IF lt_rng_block IS NOT INITIAL.
          LOOP AT gt_contract_itm ASSIGNING FIELD-SYMBOL(<lfs_vbap>).
            IF <lfs_vbap>-faksp IN lt_rng_block.          "critical block found on one of the items
              gs_variables-exit_loop = abap_true.
              DATA(lv_no_proc) = abap_true.
              MESSAGE i149(/cgdc/clrq) WITH <lfs_vbap>-vbeln <lfs_vbap>-posnr INTO DATA(lv_dummy). "dummy
              APPEND INITIAL LINE TO gt_messages ASSIGNING FIELD-SYMBOL(<lfs_msg>).
              <lfs_msg>-msgid = gc_clrq_msg_cls.
              <lfs_msg>-msgty = gc_message_type-error.
              <lfs_msg>-msgnr = 149.
              <lfs_msg>-msgv1 = <lfs_vbap>-vbeln.
              <lfs_msg>-msgv2 = <lfs_vbap>-posnr.
              EXIT.
            ENDIF.
          ENDLOOP.
*          IF gs_variables-exit_loop = abap_true.    "skip update.
*            CONTINUE.
*          ENDIF.
        ENDIF.
        IF lv_no_proc <> abap_true.
          "EOC ++14.03.24 - Check critical block on Contract before proceeding.

          PERFORM prepare_calreqhdr USING i_vbeln
                                            ''
                                            ''. "prepare Calculation Request Header.
          IF gs_clrqdoc_infocus-x-crhdr IS INITIAL..
            gs_variables-exit_loop = abap_true.
          ENDIF.
          IF i_memory_id IS INITIAL.
            PERFORM enqueue_calc_request USING gs_clrqdoc_infocus-x-crhdr-clrno
                                               gc_enq_mode-write
                                         CHANGING lv_subrc.

          ENDIF.
          IF lv_subrc IS INITIAL.
            IF  is_parallel_process-parallel IS NOT INITIAL
              AND is_parallel_process-background_job IS INITIAL
              AND gs_clrqdoc_infocus-x-crhdr-updkz NE gc_updkz_new.

              PERFORM create_lines_bcg_job_schd USING is_parallel_process i_vbeln abap_false.

              gs_variables-exit_loop = abap_true.
            ELSEIF is_parallel_process-parallel IS NOT INITIAL
              AND is_parallel_process-background_job IS NOT INITIAL
              AND gs_clrqdoc_infocus-x-crhdr-updkz NE gc_updkz_new.
              IF i_memory_id IS INITIAL.

                PERFORM create_lines_bcg_job_schd USING is_parallel_process i_vbeln abap_true.

                gs_variables-exit_loop = abap_true.
              ELSE.

                PERFORM update_cost_line_prl_bcg01 USING i_memory_id i_rtb_src i_rtbpn i_vbeln .

                gs_variables-exit_loop = abap_true.

              ENDIF.
              gs_variables-exit_loop = abap_true.
            ELSE.

              PERFORM read_dyn_source_data USING is_vbak-vbeln it_vbap.
              PERFORM prepare_calc_req_item_01.
              PERFORM update_billing_plan_item USING i_vbeln "is_vbak-vbeln
                                                     it_vbap
                                                     i_process.
            ENDIF.
          ELSE.
            gs_variables-exit_loop = abap_true.

          ENDIF.
        ENDIF.
****New calc group related changes
****
      WHEN gc_process_type-realtime. "KB21N/FB50
        gs_variables-exit_loop = abap_true.
        CLEAR gs_variables-bit_num_gen.
        gs_variables-bit_num_gen = abap_true.
        gs_variables-process_type = gc_process_type-realtime.

        "lock check
        LOOP AT it_realtime_contr ASSIGNING FIELD-SYMBOL(<lfs_contr>) .
          PERFORM select_clrqhd USING <lfs_contr>-vbeln lv_clrno.
          PERFORM enqueue_calc_request USING gs_clrqdoc_infocus-x-crhdr-clrno
                                           gc_enq_mode-shared
                                     CHANGING lv_subrc.
          IF lv_subrc IS NOT INITIAL.
            EXIT.
          ENDIF.
        ENDLOOP.

        IF lv_subrc IS INITIAL.
          PERFORM read_source_data_02 USING it_src_table it_realtime_billelem
                                            it_realtime_prps it_realtime_contr
                                            i_realtime_primtab it_realtime_sources.

        ENDIF.

      WHEN gc_process_type-calc_req_hdr_crt. "VA41/42
        gs_variables-process_type = gc_process_type-calc_req_hdr_crt.
        gs_variables-exit_loop = abap_true.
        gs_variables-collect_message = abap_true.

        CHECK is_vbak IS NOT INITIAL.
        PERFORM select_clrqhd USING is_vbak-vbeln ''. "Select CLRQ HDR Details
        PERFORM read_contract_details USING is_vbak-vbeln.
        IF gs_clrqdoc_infocus-x-crhdr IS INITIAL
          AND is_vbak-uvall = gc_process_type-calc_req_hdr_crt
          AND is_vbak-uvals = gc_process_type-calc_req_hdr_crt
          AND is_vbak-/cgdc/rtbpn IS NOT INITIAL.

          "SOC ++14.03.24 - Check critical block on Contract before proceeding.
          CALL METHOD /cgdc/cl_rtb_src_db=>read_critical_blocks
            IMPORTING
              et_rng_block = lt_rng_block.
          IF lt_rng_block IS NOT INITIAL.
            LOOP AT it_vbap ASSIGNING FIELD-SYMBOL(<lfs_vbap1>).
              IF <lfs_vbap1>-faksp IN lt_rng_block.          "critical block found on one of the items
                gs_variables-exit_loop = abap_true.
                lv_no_proc = abap_true.
                MESSAGE i149(/cgdc/clrq) WITH <lfs_vbap1>-vbeln <lfs_vbap1>-posnr INTO lv_dummy. "dummy
                APPEND INITIAL LINE TO gt_messages ASSIGNING <lfs_msg>.
                <lfs_msg>-msgid = gc_clrq_msg_cls.
                <lfs_msg>-msgty = gc_message_type-error.
                <lfs_msg>-msgnr = 149.
                <lfs_msg>-msgv1 = <lfs_vbap1>-vbeln.
                <lfs_msg>-msgv2 = <lfs_vbap1>-posnr.
              ENDIF.
            ENDLOOP.
            IF lv_no_proc = abap_true.    "skip update.
              CONTINUE.
            ENDIF.
          ENDIF.
          "EOC ++14.03.24 - Check critical block on Contract before proceeding.

          PERFORM prepare_dtls_for_cont USING is_vbak
                                                it_vbap
                                                it_vbkd. "Read Contract Details
          PERFORM prepare_calreqhdr USING is_vbak-vbeln
                                          ''
                                          ''. "prepare Calculation Request Header..
          CHECK gs_clrqdoc_infocus-x-crhdr IS NOT INITIAL.
          gs_clrqdoc_infocus-x-crhdr-waerk = is_vbak-waerk.

          PERFORM read_dyn_source_data USING is_vbak-vbeln it_vbap.
          PERFORM prepare_calc_req_item_01.
          PERFORM update_billing_plan_item USING is_vbak-vbeln"i_vbeln
                                                 it_vbap
                                                 i_process.
          "NITIN CODE for Recreate
        ELSEIF gs_clrqdoc_infocus-x-crhdr IS NOT INITIAL.
          ""COmpare DB WBS with Current WBS if Change give error
          ""Check If any Line Contract line is deleted
          PERFORM validate_existing_lines USING is_vbak-vbeln it_vbap it_iflowdn.                  " DCLM 6686
          IF gs_contract_hdr-/cgdc/rtbpn <> is_vbak-/cgdc/rtbpn.
            "SOC ++14.03.24 - Check critical block on Contract before proceeding.
            CALL METHOD /cgdc/cl_rtb_src_db=>read_critical_blocks
              IMPORTING
                et_rng_block = lt_rng_block.
            IF lt_rng_block IS NOT INITIAL.
              LOOP AT it_vbap ASSIGNING <lfs_vbap1>.
                IF <lfs_vbap1>-faksp IN lt_rng_block.          "critical block found on one of the items
                  gs_variables-exit_loop = abap_true.
                  lv_no_proc = abap_true.
                  MESSAGE i149(/cgdc/clrq) WITH <lfs_vbap1>-vbeln <lfs_vbap1>-posnr INTO lv_dummy. "dummy
                  APPEND INITIAL LINE TO gt_messages ASSIGNING <lfs_msg>.
                  <lfs_msg>-msgid = gc_clrq_msg_cls.
                  <lfs_msg>-msgty = gc_message_type-error.
                  <lfs_msg>-msgnr = 149.
                  <lfs_msg>-msgv1 = <lfs_vbap1>-vbeln.
                  <lfs_msg>-msgv2 = <lfs_vbap1>-posnr.
                ENDIF.
              ENDLOOP.
              IF lv_no_proc = abap_true.    "skip update.
                CONTINUE.
              ENDIF.
            ENDIF.
            "EOC ++14.03.24 - Check critical block on Contract before proceeding.

            PERFORM prepare_dtls_for_cont USING is_vbak
                                                it_vbap
                                                it_vbkd.
            PERFORM enqueue_calc_request USING gs_clrqdoc_infocus-x-crhdr-clrno
                                                       gc_enq_mode-write
                                                 CHANGING lv_subrc.
            IF lv_subrc = 0.
              PERFORM delete_rtb_sched_prof_data USING is_vbak-vbeln.

              PERFORM recreate_calc_req01.

            ELSE.
              "Message Locked By User
            ENDIF.
          ELSE.
            PERFORM update_billing_plan_item USING is_vbak-vbeln
                                                   it_vbap
                                                   i_process.
          ENDIF.


        ELSE.
          "SOC ++14.03.24 - Check critical block on Contract before proceeding.
          CALL METHOD /cgdc/cl_rtb_src_db=>read_critical_blocks
            IMPORTING
              et_rng_block = lt_rng_block.
          IF lt_rng_block IS NOT INITIAL.
            LOOP AT it_vbap ASSIGNING <lfs_vbap1>.
              IF <lfs_vbap1>-faksp IN lt_rng_block.          "critical block found on one of the items
                gs_variables-exit_loop = abap_true.
                lv_no_proc = abap_true.
                MESSAGE i149(/cgdc/clrq) WITH <lfs_vbap1>-vbeln <lfs_vbap1>-posnr INTO lv_dummy. "dummy
                APPEND INITIAL LINE TO gt_messages ASSIGNING <lfs_msg>.
                <lfs_msg>-msgid = gc_clrq_msg_cls.
                <lfs_msg>-msgty = gc_message_type-error.
                <lfs_msg>-msgnr = 149.
                <lfs_msg>-msgv1 = <lfs_vbap1>-vbeln.
                <lfs_msg>-msgv2 = <lfs_vbap1>-posnr.
              ENDIF.
            ENDLOOP.
            IF lv_no_proc = abap_true.   "skip update.
              CONTINUE.
            ENDIF.
          ENDIF.
          "EOC ++14.03.24 - Check critical block on Contract before proceeding.
          PERFORM prepare_calreqhdr USING is_vbak-vbeln
                                          ''
                                          ''.
          PERFORM update_billing_plan_item USING is_vbak-vbeln
                                                 it_vbap
                                                 i_process.
        ENDIF.

        gs_variables-process_type = gc_process_type-calc_req_hdr_crt.

      WHEN gc_process_type-update OR gc_process_type-full_update.

        IF i_process = gc_process_type-full_update.
          lv_rp_flag = gc_process_type-full_update.
        ENDIF.
        IF is_parallel_process-background_job IS INITIAL.
          gs_variables-exit_loop = abap_true.
          gs_variables-process_type = gc_process_type-update.

          CALL FUNCTION '/CGDC/CLRQ_REPRICE_UPDATE'
            EXPORTING
              i_vbeln             = i_vbeln
              iv_rp_flag          = lv_rp_flag
              is_parallel_process = is_parallel_process
            IMPORTING
              et_return           = et_message.
          IF sy-subrc <> 0.
          ENDIF.
        ELSEIF is_parallel_process-background_job IS NOT INITIAL AND i_memory_id IS INITIAL.
          PERFORM crt_bg_job_repricing USING  is_parallel_process
                                               i_vbeln
                                               lv_rp_flag.
        ELSEIF is_parallel_process-background_job IS NOT INITIAL AND i_memory_id IS NOT INITIAL.
          PERFORM updt_bg_repricing USING  i_memory_id
                                               i_vbeln
                                               lv_rp_flag.
        ENDIF.
        PERFORM update_billing_plan_item USING is_vbak-vbeln
                                               it_vbap
                                                           i_process. "need to create bg parallel processing
      WHEN gc_process_type-scheduler.

        PERFORM read_contract_details USING i_vbeln.
        PERFORM prepare_calreqhdr USING i_vbeln
                                       ''
                                       ''.
        gs_variables-scheduler = abap_true.
        PERFORM  create_ebdr USING abap_true.
        gs_variables-exit_loop = abap_true.

      WHEN gc_process_type-validate_clrqno.
        IF is_parallel_process-parallel IS INITIAL.
          PERFORM validate_calc_req_01 USING i_vbeln.
        ELSEIF i_memory_id IS INITIAL.
          CALL FUNCTION '/CGDC/RTB_PRL_VALIDATE_CLRQ'
            EXPORTING
              i_vbeln = i_vbeln
              is_prl  = is_parallel_process.
        ELSEIF is_parallel_process-background_job IS NOT INITIAL.
          PERFORM updt_validate_bg USING i_memory_id
                                         i_vbeln.
        ENDIF.

      WHEN gc_process_type-reval_bill_blocks.
        PERFORM reval_bill_blocks USING i_vbeln.

      WHEN gc_process_type-upd_cont_data.
        PERFORM update_contract_data USING i_vbeln.
        gs_variables-exit_loop = abap_true.

      WHEN OTHERS.
        gs_variables-exit_loop = abap_true.

    ENDCASE.

    IF i_process NE gc_process_type-realtime..
      APPEND LINES OF gt_messages TO et_message.
    ENDIF.

    IF gs_clrqdoc_infocus-x-crhdr-updkz EQ gc_updkz_new.
      PERFORM complete_calc_request_tables CHANGING gs_clrqdoc_infocus.
    ENDIF.
    IF gs_clrqdoc_infocus IS NOT INITIAL.
      APPEND gs_clrqdoc_infocus TO lt_clrq_doc.
      IF gt_clrqdoc_infocus IS NOT INITIAL.
        APPEND LINES OF gt_clrqdoc_infocus TO lt_clrq_doc.
      ENDIF.
      CALL FUNCTION '/CGDC/CLRQ_SAVE'
        EXPORTING
          i_set_update_task = i_update_task
          i_commit_work     = i_commit_work
        CHANGING
          ct_clrq_doc       = lt_clrq_doc
        EXCEPTIONS
          no_change         = 1
          OTHERS            = 2.
      IF sy-subrc <> 0.
        "error handling
      ENDIF.
      CLEAR lt_clrq_doc.
    ENDIF.
    CLEAR:lt_clrq_doc.
    LOOP AT lt_clrq_doc INTO gs_clrqdoc_infocus.

      PERFORM dequeue_calc_request USING gs_clrqdoc_infocus-clrno
                                         gc_enq_mode-write.
    ENDLOOP.
    CLEAR: gs_clrqdoc_infocus,
           gt_clrqdoc_infocus.

  ENDWHILE.

  """BILLING ITEM ASSIGNEMNT


  IF gt_bg_crt_keys IS NOT INITIAL AND is_parallel_process-parallel IS NOT INITIAL.
    gs_variables-overview_mode = gc_mode_change.
    DESCRIBE TABLE gt_bg_crt_keys LINES lv_length.
    lv_index_from = 0.
    lv_index_to = gs_variables-cmfrq. "set block as to index
    IF lv_index_to >= lv_length OR gs_variables-cmfrq IS INITIAL. "if table length is lesser than block
      lv_index_to = lv_length.
      lv_exit_do = 'X'.
    ENDIF.
    DO.
      CLEAR lt_clrit_key_t.
      LOOP AT gt_bg_crt_keys INTO lwa_clrit_key FROM lv_index_from TO lv_index_to.
        APPEND lwa_clrit_key TO lt_clrit_key_t.
      ENDLOOP.

      PERFORM set_calc_req_item_doc_infocus USING lt_clrit_key_t
                                           CHANGING lv_subrc.
      IF lv_subrc IS INITIAL.
        gs_variables-bit_num_gen = abap_true.
        LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING FIELD-SYMBOL(<lwa_critm>).
          PERFORM create_billing_item CHANGING <lwa_critm>.
          <lwa_critm>-updkz = gc_updkz_update.
        ENDLOOP.
        gs_variables-bit_num_gen = abap_false.
      ENDIF.
      APPEND gs_clrqdoc_infocus TO lt_clrq_doc.
      CALL FUNCTION '/CGDC/CLRQ_SAVE'
        EXPORTING
          i_set_update_task = i_update_task
          i_commit_work     = i_commit_work
        CHANGING
          ct_clrq_doc       = lt_clrq_doc
        EXCEPTIONS
          no_change         = 1
          OTHERS            = 2.
      IF sy-subrc <> 0.
        "error handling
      ENDIF.
      CLEAR: lt_clrq_doc,
             gs_clrqdoc_infocus.
      IF lv_exit_do IS NOT INITIAL.
        EXIT.
      ENDIF.
      lv_index_from = lv_index_to + 1.
      lv_index_to = lv_index_to + gs_variables-cmfrq.
      IF lv_index_to >= lv_length.
        lv_index_to = lv_length.
        lv_exit_do = 'X'.
      ENDIF.
    ENDDO.
  ENDIF.
ENDFUNCTION.

FUNCTION /cgdc/clrq_rtbc_process_update.
*"----------------------------------------------------------------------
*"*"Update Function Module:
*"
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(I_PROCESS) TYPE  /CGDC/CLRQ_PROCESS OPTIONAL
*"     VALUE(I_COMMIT_WORK) TYPE  CHAR1 DEFAULT 'X'
*"  TABLES
*"      ET_MESSAGE STRUCTURE  /CGDC/S_MESSAGE OPTIONAL
*"  EXCEPTIONS
*"      CALC_REQ_LOCKED
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Real Time Billing Cockpit Process - Update mode
**********************************************************

  "--commented - configure sources. hardcoded source structure not to be used.
*  TRY.
*      CALL FUNCTION '/CGDC/CLRQ_RTBC_PROCESS'
*        EXPORTING
**         i_vbeln         =
*          it_src_table    = it_src_table
*          i_process       = i_process
*          i_commit_work   = i_commit_work
*        IMPORTING
*          et_message      = et_message
*        EXCEPTIONS
*          calc_req_locked = 1.
*      IF sy-subrc EQ 1.
*        RAISE calc_req_locked.
*      ENDIF.
*    CATCH cx_sy_dyn_call_illegal_type.
*
*  ENDTRY.





ENDFUNCTION.

FUNCTION /cgdc/clrq_rtb_blk_size.
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Determine Block Size For Cost Line Items Update
**********************************************************


*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IV_TABLE_SIZE) TYPE  I
*"     REFERENCE(IV_MAX_PROCESSES) TYPE  I
*"     REFERENCE(IV_OPT_BLOCK_SIZE) TYPE  NUMC10
*"  EXPORTING
*"     REFERENCE(EV_BLOCK_SIZE) TYPE  NUMC10
*"----------------------------------------------------------------------

  DATA(lv_blk) = iv_table_size / iv_max_processes.

  IF lv_blk LT iv_opt_block_size.
    ev_block_size = lv_blk.
  ELSE.
    ev_block_size = iv_opt_block_size.
  ENDIF.

ENDFUNCTION.
FUNCTION /cgdc/clrq_rtb_prl_process.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(I_VBELN) TYPE  VBELN
*"     VALUE(IT_CLRQSRC) TYPE  /CGDC/TT_CLRQ_COST_KEYS OPTIONAL
*"     VALUE(IT_OBJNR) TYPE  /CGDC/T_OBJNR OPTIONAL
*"     VALUE(I_NO_PRICING) TYPE  FLAG DEFAULT ABAP_FALSE
*"     VALUE(I_COMMIT) TYPE  FLAG
*"     VALUE(I_UPDATE_TASK) TYPE  FLAG
*"     VALUE(I_MEMORY_ID) TYPE  CHAR22 OPTIONAL
*"     VALUE(I_RTB_SRC) TYPE  /CGDC/RTBSOURCE OPTIONAL
*"     VALUE(I_RTBPN) TYPE  /CGDC/RTBPN OPTIONAL
*"  EXPORTING
*"     VALUE(ET_ITEM_KEY) TYPE  /CGDC/TT_CLRQIT_KEY
*"  EXCEPTIONS
*"      COMMUNICATION_FAILURE
*"      SYSTEM_FAILURE
*"      RESOURCE_FAILURE
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Parallel Processing for Costing Key
**********************************************************

  FIELD-SYMBOLS <lt_src_data> TYPE ANY TABLE .
  FIELD-SYMBOLS <lwa_srcdata> TYPE s_srcdata.

  DATA: lwa_objnr   TYPE /cgdc/s_objnr,
        lt_clrq_doc TYPE TABLE OF /cgdc/s_clrq_doc.

  DATA: lv_memory_id_3 TYPE char20,
        lt_source      TYPE REF TO data,
        lv_viewname    TYPE viewname,
        lv_invalid     TYPE flag.

  FIELD-SYMBOLS: <lt_table> TYPE table.

  FIELD-SYMBOLS <lt_src_data1> TYPE ANY TABLE .
  FIELD-SYMBOLS <lwa_srcdata1> TYPE ty_src_data.

  IF i_vbeln IS INITIAL.                  "ACT Check Fix
    PERFORM check_clrq_authorization USING gs_clrqdoc_infocus-x-crhdr-clrqt
                                           gs_clrqdoc_infocus-x-crhdr-vkorg
                                           gs_clrqdoc_infocus-x-crhdr-vtweg
                                           gs_clrqdoc_infocus-x-crhdr-spart
                                           gc_auth_actv-change
                                           space
                                  CHANGING lv_invalid.
  ENDIF.

  gs_variables-no_pricing = i_no_pricing.
  gs_variables-bg_prl_run = abap_true.

  "++SOC import source data from Memory
  "get cds view
  DATA(ls_view) = /cgdc/cl_rtb_src_db=>read_view_by_rtbsrc( i_rtb_src ).
  DATA(lv_cdsview_name) = ls_view-cds_view.
  IF lv_cdsview_name IS NOT INITIAL.
    CREATE DATA lt_source TYPE TABLE OF (lv_cdsview_name).
    ASSIGN lt_source->* TO <lt_table>.
    IF <lt_table> IS ASSIGNED.
      IMPORT <lt_table> FROM DATABASE  /cgdc/_clrq_indx(cr) ID i_memory_id.
    ENDIF.

    APPEND INITIAL LINE TO gt_src_dyn ASSIGNING <lwa_srcdata1>.
    <lwa_srcdata1>-/cgdc/rtbpn = i_rtbpn.
    <lwa_srcdata1>-source      = i_rtb_src.
    CREATE DATA <lwa_srcdata1>-data  TYPE TABLE OF (lv_cdsview_name).
    ASSIGN <lwa_srcdata1>-data->* TO <lt_src_data1>.

    <lt_src_data1> = <lt_table>.
  ENDIF.

  DELETE FROM DATABASE /cgdc/_clrq_indx(cr) ID i_memory_id.
  "++EOC import source data from Memory

  PERFORM modify_source_data CHANGING <lt_src_data1>.
  PERFORM read_contract_details USING i_vbeln. "Read Contract Details
  PERFORM prepare_calreqhdr USING i_vbeln
                                  ' '
                                  ''.
  PERFORM prepare_calc_req_item_01.

  APPEND gs_clrqdoc_infocus TO lt_clrq_doc.

  /cgdc/cl_be_helper=>mv_parallel_process_enabled = abap_true.
  et_item_key = gt_bg_crt_keys.
  CALL FUNCTION '/CGDC/CLRQ_SAVE'
    EXPORTING
      i_set_update_task = i_update_task
      i_commit_work     = i_commit
    CHANGING
      ct_clrq_doc       = lt_clrq_doc
    EXCEPTIONS
      no_change         = 1
      OTHERS            = 2.
  IF sy-subrc <> 0.
* Implement suitable error handling here
  ENDIF.
  CLEAR:lt_clrq_doc.
ENDFUNCTION.

FUNCTION /cgdc/clrq_rtb_prl_reprice.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(I_VBELN) TYPE  VBELN
*"     VALUE(IT_CLRQPITKEY_T) TYPE  /CGDC/TT_CLRQPIT
*"     VALUE(IT_COEP_ORI) TYPE  /CGDC/TT_COEP_ORI
*"     VALUE(IS_RTBP) TYPE  /CGDC/T_RTBP
*"     VALUE(IT_RTBCLNMS) TYPE  /CGDC/TT_RTBCLNMCS OPTIONAL
*"     VALUE(IT_RTBWBSMCS) TYPE  /CGDC/TT_WBSMCS OPTIONAL
*"  EXPORTING
*"     VALUE(ET_RETURN_TAB) TYPE  /CGDC/T_MESSAGE
*"     VALUE(ET_ITEM_KEY) TYPE  /CGDC/TT_CLRQIT_KEY
*"  EXCEPTIONS
*"      COMMUNICATION_FAILURE
*"      SYSTEM_FAILURE
*"      RESOURCE_FAILURE
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Parallel Processing for Repricing Calc. Req. items
**********************************************************

  DATA: lwa_clrqpit_key        TYPE /cgdc/s_clrqpit,
        lwa_crcon              TYPE /cgdc/_clrqcn,
        lwa_crcon_new          TYPE /cgdc/_clrqcn,
        lwa_crcon_new_t        TYPE /cgdc/_clrqcn,
        lwa_crcon_delta        TYPE /cgdc/_clrqcn,
        lwa_clrq_itm_new       TYPE /cgdc/s_clrqit_fcat,
        lwa_coep_ori           TYPE /cgdc/s_coep_ori,
        lwa_item_old           TYPE /cgdc/s_clrqit,
        lwa_clrqpit            TYPE /cgdc/s_clrqpit,
        lwa_return             TYPE /cgdc/s_message,
        lt_clrqpit             TYPE /cgdc/tt_clrqpit,
        lt_clrqit_last_billed  TYPE /cgdc/tt_clrqit,
        lwa_clrqit_last_billed TYPE /cgdc/s_clrqit,
        lv_copied_item_line    TYPE i,
        lv_one_qty_amt         TYPE netwr_ap.

  FIELD-SYMBOLS : <lwa_clrit_sub>    TYPE /cgdc/s_clrqit,
                  <lwa_clrit_item>   TYPE /cgdc/s_clrqit,
                  <lwa_clrit_delta>  TYPE /cgdc/s_clrqit,
                  <lwa_clrcn_old>    TYPE /cgdc/s_clrqcn,
                  <lwa_clrcn_delta>  TYPE /cgdc/s_clrqcn,
                  <lwa_crcon_copied> TYPE /cgdc/s_clrqcn,
                  <lwa_critm_copied> TYPE /cgdc/s_clrqit,
                  <lwa_clrqbi>       TYPE /cgdc/s_clrqbi.
  FIELD-SYMBOLS : <lwa_clrqit_last_copied> TYPE /cgdc/s_clrqit.

  FIELD-SYMBOLS : <lwa_wa1> TYPE any,
                  <lwa_wa2> TYPE any,
                  <lv_val1> TYPE any,
                  <lv_val2> TYPE any,
                  <lv_val3> TYPE any.

  DATA: lwa_clrqpcn TYPE  /cgdc/_clrqpcn.
  DATA: lt_clrno TYPE TABLE OF /cgdc/s_clrqno.
  DATA: lwa_clrno TYPE /cgdc/s_clrqno.
  DATA: lv_lock TYPE sysubrc.
  DATA: lt_clrqdoc TYPE TABLE OF /cgdc/s_clrq_doc.
  DATA lwa_rtbp TYPE /cgdc/t_rtbp.
  DATA: lv_no_attempt          TYPE num4,
        lv_max_attempt_failure TYPE c,
        lv_row_count           TYPE sy-tabix.
  DATA: lt_crcon_copied   TYPE /cgdc/tt_clrqcn,
        lt_crcon_copied_t TYPE /cgdc/tt_clrqcn.
  DATA: lwa_last_billed TYPE /cgdc/s_clrqit.
  DATA: lwa_crbinr TYPE /cgdc/s_clrqbi.
  DATA: lv_invalid TYPE flag.
  DATA : lt_clrqpit_key TYPE TABLE OF /cgdc/_clrqpit.
  DATA : lt_clrqpit_temp TYPE TABLE OF /cgdc/_clrqpit.
  DATA: lwa_clnmcs  TYPE /cgdc/s_rtbclnmcs.
  DATA: lv_action_cd TYPE /cgdc/rtb_rprc_actn_code.
  DATA: lt_prps     TYPE TABLE OF prps,
        lwa_prps    TYPE prps,
        lwa_wbsmcs  TYPE /cgdc/s_wbsmcs,
        ls_coep_ori TYPE  /cgdc/s_coep_ori,
        lt_coep_ori TYPE TABLE OF  /cgdc/s_coep_ori.
  DATA: lt_clritkey TYPE TABLE OF /cgdc/s_clrqit_key.
  DATA: lwa_clritkey TYPE /cgdc/s_clrqit_key.
  DATA lv_subrc TYPE sysubrc.
  DATA: ls_clrqit TYPE  /cgdc/s_clrqit,
        ls_clrqbi TYPE  /cgdc/s_clrqbi.
  DATA: lt_clrq_doc TYPE TABLE OF /cgdc/s_clrq_doc.
*******************************************************

  IF i_vbeln IS INITIAL.  "ACT Check Fix
    PERFORM check_clrq_authorization USING  gs_clrqdoc_infocus-x-crhdr-clrqt
                               gs_clrqdoc_infocus-x-crhdr-vkorg
                               gs_clrqdoc_infocus-x-crhdr-vtweg
                               gs_clrqdoc_infocus-x-crhdr-spart
                               gc_auth_actv-change
                               space
                         CHANGING lv_invalid.
  ENDIF.

  gs_rtbp = is_rtbp.
  PERFORM read_contract_details USING i_vbeln.
  gs_variables-bg_prl_run = abap_true.

  "SOC - Multipayer Scenario - select additional cost collectors for repricing
  PERFORM select_add_cost_collectors.
  "EOC - Multipayer Scenario - select additional cost collectors for repricing

  LOOP AT it_clrqpitkey_t INTO lwa_clrqpit.
    MOVE-CORRESPONDING lwa_clrqpit TO lwa_clritkey.
    APPEND lwa_clritkey TO lt_clritkey.
  ENDLOOP.
  gs_variables-overview_mode = gc_mode_change.
  PERFORM set_calc_req_item_doc_infocus USING  lt_clritkey
                                               CHANGING lv_subrc.

  PERFORM select_calc_req_typ USING gs_clrqdoc_infocus-x-crhdr-clrqt.
  PERFORM select_item_catgs USING gs_clrqdoc_infocus-x-crhdr-clrqt.
  LOOP AT it_clrqpitkey_t INTO lwa_clrqpit_key.
    LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item>
                                                   WHERE clrno = lwa_clrqpit_key-clrno
                                                   AND   clrit = lwa_clrqpit_key-clrit.

      CLEAR ls_clrqit.
      READ TABLE gs_clrqdoc_infocus-x-critm INTO ls_clrqit
      WITH KEY clrno  = <lwa_clrit_item>-clrno
               clrit  = <lwa_clrit_item>-clrit
               clrsit = <lwa_clrit_item>-clrsit
               clrdit = <lwa_clrit_item>-clrdit.
      IF sy-subrc = 0.
        <lwa_clrit_item>-exdat     = ls_clrqit-exdat.
        <lwa_clrit_item>-bldat_bi  = ls_clrqit-bldat_bi.
        <lwa_clrit_item>-pop_stdt  = ls_clrqit-pop_stdt.
        <lwa_clrit_item>-pop_enddt = ls_clrqit-pop_enddt.
        <lwa_clrit_item>-updkz     = ls_clrqit-updkz.
      ENDIF.
    ENDLOOP.

    READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item>
    WITH KEY clrno = lwa_clrqpit_key-clrno
             clrit = lwa_clrqpit_key-clrit.
    IF sy-subrc = 0.
      READ TABLE gs_clrqdoc_infocus-x-crbinr ASSIGNING <lwa_clrqbi>
      WITH KEY clrno     = <lwa_clrit_item>-clrno
               bill_item = <lwa_clrit_item>-rtbbinr.
      IF sy-subrc = 0.
        CLEAR: <lwa_clrqbi>-netwr, <lwa_clrqbi>-wavwr,
               <lwa_clrqbi>-kzwi1, <lwa_clrqbi>-kzwi2,
               <lwa_clrqbi>-kzwi3, <lwa_clrqbi>-kzwi4,
               <lwa_clrqbi>-kzwi5, <lwa_clrqbi>-kzwi6.

        CLEAR ls_clrqbi.
        READ TABLE gs_clrqdoc_infocus-x-crbinr INTO ls_clrqbi
        WITH KEY clrno     = <lwa_clrqbi>-clrno
                 bill_item = <lwa_clrqbi>-bill_item.
        IF sy-subrc = 0.
          <lwa_clrqbi>-exdat = ls_clrqbi-exdat.
          <lwa_clrqbi>-updkz = ls_clrqbi-updkz.
        ENDIF.
      ENDIF.
    ENDIF.

    CLEAR gs_clrit_org.
    READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_item> WITH KEY clrit = lwa_clrqpit_key-clrit
                                                                              clrsit = '000000'.
    IF sy-subrc = 0.
      READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_sub> WITH KEY clrit = lwa_clrqpit_key-clrit
                                                                                 clrsit = lwa_clrqpit_key-clrsit
                                                                                 clrdit = '000000'.
      IF sy-subrc = 0.
        READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrit_delta> WITH KEY clrno = <lwa_clrit_sub>-clrno
                                                                                 clrit = <lwa_clrit_sub>-clrit
                                                                                 clrsit = <lwa_clrit_sub>-clrsit
                                                                                 clrdit = <lwa_clrit_sub>-ldetla.
        IF <lwa_clrit_delta> IS ASSIGNED.
          MOVE-CORRESPONDING lwa_clrqpit_key TO lwa_clrqpit.
          lwa_clrqpit-updkz = gc_updkz_delete.
          APPEND lwa_clrqpit TO lt_clrqpit.
          IF <lwa_clrit_delta>-istat EQ gc_ibill_stat-copied OR <lwa_clrit_delta>-istat EQ gc_ibill_stat-delta
            OR <lwa_clrit_delta>-reversed IS NOT INITIAL.

            CONTINUE.
          ENDIF.
          IF <lwa_clrit_item>-no_price EQ abap_false.
            READ TABLE gs_clrqdoc_infocus-x-crcon INTO lwa_crcon WITH KEY clrit = <lwa_clrit_delta>-clrit
                                                      clrsit = <lwa_clrit_delta>-clrsit
                                                      clrdit = <lwa_clrit_delta>-clrdit
                                                      kschl = gs_rtbp-ccond.
            IF sy-subrc <> 0.
              CLEAR lwa_crcon.
            ENDIF.
          ENDIF.

          READ TABLE gs_clrqdoc_infocus-x-crbinr INTO lwa_crbinr WITH KEY clrno = <lwa_clrit_delta>-clrno
                                                                          bill_item = <lwa_clrit_delta>-rtbbinr
                                                                          bitype = <lwa_clrit_delta>-bityp .
          IF sy-subrc = 0 AND lwa_crbinr-bstat IS NOT INITIAL.
            gs_variables-billed_item = abap_true.
          ELSE.
            CLEAR gs_variables-billed_item.
          ENDIF.

          CLEAR:lwa_clrq_itm_new.
          PERFORM move_itm_to_itm_fcat USING <lwa_clrit_delta>
                          CHANGING lwa_clrq_itm_new.
          lwa_clrq_itm_new-duepos = <lwa_clrit_delta>-clrdit.
          gs_variables-process_type = gc_process_type-update.

          <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla + 1.
          CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
            EXPORTING
              input  = <lwa_clrit_sub>-ldetla
            IMPORTING
              output = <lwa_clrit_sub>-ldetla.
          IF sy-subrc <> 0.
          ENDIF.
          IF gs_variables-billed_item IS NOT INITIAL.
            lwa_clrq_itm_new-istat = gc_ibill_stat-copied.
          ENDIF.

          gs_clrit_org-clrno = <lwa_clrit_delta>-clrno.
          gs_clrit_org-clrit = <lwa_clrit_delta>-clrit.
          gs_clrit_org-clrsit = <lwa_clrit_delta>-clrsit.
          gs_clrit_org-item_delta = <lwa_clrit_sub>-ldetla.
          gs_variables-process_type = gc_process_type-update.

          IF <lwa_clrit_item>-no_price EQ abap_true.

            lwa_clrq_itm_new-kbetr1 = <lwa_clrit_item>-kbetr1.
            <lwa_clrit_item>-no_price = abap_false.
            gs_clrit_org-istat = gc_ibill_stat-open.
          ELSE.
            IF gs_variables-billed_item IS NOT INITIAL.
              "last billed status
              LOOP AT gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WHERE clrno = <lwa_clrit_delta>-clrno
                                                                            AND clrit = <lwa_clrit_delta>-clrit
                                                                            AND clrsit = <lwa_clrit_delta>-clrsit
                                                                            AND istat = gc_ibill_stat-copied
                                                                            AND rtbbinr IS NOT INITIAL.
              ENDLOOP.

              IF <lwa_clrqit_last_copied> IS ASSIGNED.
                READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = lwa_last_billed-clrno
                                                                                                clrit = lwa_last_billed-clrit
                                                                                                clrsit = lwa_last_billed-cuepos
                                                                                                clrdit = lwa_last_billed-duepos.
                IF sy-subrc <> 0.

                  IF lwa_last_billed-cuepos IS NOT INITIAL AND lwa_last_billed-duepos IS NOT INITIAL.
                    READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = lwa_last_billed-clrno
                                                                                                    clrit = lwa_last_billed-clrit
                                                                                                    clrsit = lwa_last_billed-cuepos
                                                                                                    clrdit = lwa_last_billed-duepos.
                    IF <lwa_clrqit_last_copied> IS ASSIGNED.
                      READ TABLE gs_clrqdoc_infocus-x-crcon INTO lwa_crcon WITH KEY clrit = <lwa_clrqit_last_copied>-clrit
                                                        clrsit = <lwa_clrqit_last_copied>-clrsit
                                                        clrdit = <lwa_clrqit_last_copied>-clrdit
                                                        kschl = gs_rtbp-ccond.
                      IF sy-subrc <> 0.
                        CLEAR lwa_crcon.
                      ENDIF.
                    ENDIF.
                  ENDIF.
                ENDIF.
              ENDIF.
            ENDIF.
            IF lwa_crcon-kbetr IS NOT INITIAL.
              lwa_clrq_itm_new-kbetr1 = lwa_crcon-kbetr.
            ELSE.
              lwa_clrq_itm_new-kbetr1 = <lwa_clrit_delta>-netwr.
            ENDIF.
          ENDIF.
          lwa_clrq_itm_new-cuepos = <lwa_clrit_delta>-clrsit.
          lwa_clrq_itm_new-duepos = <lwa_clrit_delta>-clrdit.
          gs_variables-bit_num_gen = abap_true.

          CLEAR : lwa_clrq_itm_new-rtbbinr.

          IF it_rtbclnms IS NOT INITIAL OR it_rtbwbsmcs IS NOT INITIAL.
            LOOP AT it_rtbclnms INTO lwa_clnmcs WHERE ( begdat LE lwa_clrq_itm_new-budat
                                                  AND enddat GE lwa_clrq_itm_new-budat )
                                                  AND posnr = lwa_clrq_itm_new-/cgdc/orgi.
              lv_action_cd = lwa_clnmcs-action_cd.
              EXIT.
            ENDLOOP.

            IF it_rtbwbsmcs IS NOT INITIAL AND lv_action_cd IS INITIAL.
              READ TABLE lt_prps INTO lwa_prps WITH KEY pspnr = lwa_clrq_itm_new-cc_pspnr.
              IF sy-subrc = 0.
                LOOP AT it_rtbwbsmcs INTO lwa_wbsmcs WHERE ( begdat LE lwa_clrq_itm_new-budat
                                                          AND enddat GE lwa_clrq_itm_new-budat )
                                                        AND objnr = lwa_prps-objnr.
                  lv_action_cd = lwa_wbsmcs-action_cd.
                ENDLOOP.
              ENDIF.
            ENDIF.
          ELSE.
            lv_action_cd = lwa_clrqpit-action_cd.
          ENDIF.
          PERFORM assign_reprice_code USING lv_action_cd
                                      CHANGING lwa_clrq_itm_new.
          PERFORM repricing USING  lwa_item_old
                                         CHANGING lwa_clrq_itm_new.
          IF gs_clrit_org-istat IS INITIAL.

            <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla - 1.
            CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
              EXPORTING
                input  = <lwa_clrit_sub>-ldetla
              IMPORTING
                output = <lwa_clrit_sub>-ldetla.
            CONTINUE.
          ENDIF.
          <lwa_clrit_delta>-istat = gc_ibill_stat-delta.
          IF gs_variables-billed_item IS INITIAL.
            CLEAR <lwa_clrit_delta>-rtbbinr.
          ENDIF.
          <lwa_clrit_delta>-updkz = gc_updkz_update.
          <lwa_clrit_sub>-updkz = gc_updkz_update.
          IF <lwa_clrit_delta>-cuepos IS INITIAL .
            <lwa_clrit_delta>-cuepos = <lwa_clrit_delta>-clrsit.
          ENDIF.
          gs_clrqdoc_infocus-x-crhdr-netwr = <lwa_clrit_delta>-netwr.
          "++SOC - decimal precision field
          gs_clrqdoc_infocus-x-crhdr-netwr24 = <lwa_clrit_delta>-netwr24.
          "++EOC - decimal precision field

          IF gs_variables-billed_item IS NOT INITIAL..

            IF <lwa_clrqit_last_copied> IS NOT ASSIGNED.

              READ TABLE gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_clrqit_last_copied> WITH KEY clrno = <lwa_clrit_delta>-clrno
                                                                                              clrit = <lwa_clrit_delta>-clrit
                                                                                              clrsit = <lwa_clrit_delta>-clrsit
                                                                                              istat = gc_ibill_stat-copied.
              IF <lwa_clrqit_last_copied> IS ASSIGNED.
              ELSE.
                CONTINUE.
              ENDIF.
            ENDIF.


            APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-critm ASSIGNING <lwa_critm_copied>.

            MOVE-CORRESPONDING lwa_clrq_itm_new TO <lwa_critm_copied>.
            <lwa_clrit_sub>-ldetla = <lwa_clrit_sub>-ldetla + 1.
            CALL FUNCTION 'CONVERSION_EXIT_ALPHA_INPUT'
              EXPORTING
                input  = <lwa_clrit_sub>-ldetla
              IMPORTING
                output = <lwa_clrit_sub>-ldetla.
            <lwa_critm_copied>-clrsit = <lwa_clrit_sub>-clrsit.
            <lwa_critm_copied>-clrit = <lwa_clrit_item>-clrit.
            <lwa_critm_copied>-clrdit = <lwa_clrit_sub>-ldetla.
            <lwa_critm_copied>-ldetla = '000000'.
            <lwa_critm_copied>-rtbbinr = lwa_clrq_itm_new-rtbbinr.
            <lwa_critm_copied>-cuepos = lwa_clrq_itm_new-clrsit.
            <lwa_critm_copied>-duepos = lwa_clrq_itm_new-clrdit.
            IF  <lwa_clrqit_last_copied> IS ASSIGNED AND <lwa_clrqit_last_copied>-clrdit <> lwa_clrq_itm_new-clrdit.
              <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - <lwa_clrqit_last_copied>-netwr .
              "++SOC - decimal precision field
              <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - <lwa_clrqit_last_copied>-netwr24 .
              "++EOC - decimal precision field
            ELSE.
              <lwa_critm_copied>-netwr = lwa_clrq_itm_new-netwr - <lwa_clrit_delta>-netwr .
              "++SOC - decimal precision field
              <lwa_critm_copied>-netwr24 = lwa_clrq_itm_new-netwr24 - <lwa_clrit_delta>-netwr24 .
              "++EOC - decimal precision field
            ENDIF.
            gs_clrqdoc_infocus-x-crhdr-netwr = gs_clrqdoc_infocus-x-crhdr-netwr + <lwa_critm_copied>-netwr.
            "++SOC decimal precision fields
            gs_clrqdoc_infocus-x-crhdr-netwr24 = gs_clrqdoc_infocus-x-crhdr-netwr24 + <lwa_critm_copied>-netwr24.
            "++EOC decimal precision fields
            <lwa_critm_copied>-updkz = gc_updkz_new.
            <lwa_critm_copied>-istat = gc_ibill_stat-open.
            CLEAR <lwa_critm_copied>-bstat.
            lt_crcon_copied = gs_clrqdoc_infocus-x-crcon.
            IF <lwa_clrqit_last_copied> IS ASSIGNED AND <lwa_clrqit_last_copied>-clrdit <> lwa_clrq_itm_new-clrdit.
              DELETE lt_crcon_copied WHERE clrit <> <lwa_clrqit_last_copied>-clrit OR
                                           clrsit <> <lwa_clrqit_last_copied>-clrsit OR
                                           clrdit <> <lwa_clrqit_last_copied>-clrdit.
            ELSE.
              DELETE lt_crcon_copied WHERE clrit <> <lwa_clrit_delta>-clrit OR
                                           clrsit <> <lwa_clrit_delta>-clrsit OR
                                           clrdit  <> <lwa_clrit_delta>-clrdit.
            ENDIF.
            lt_crcon_copied_t = lt_crcon_copied[].

            READ TABLE gs_clrqdoc_infocus-x-crcon TRANSPORTING NO FIELDS WITH KEY clrit = lwa_clrq_itm_new-clrit
                                                                            clrsit = lwa_clrq_itm_new-clrsit
                                                                            clrdit = lwa_clrq_itm_new-clrdit.
            IF sy-subrc = 0.
              LOOP AT gs_clrqdoc_infocus-x-crcon INTO lwa_crcon_new FROM sy-tabix.
                IF lwa_crcon_new-clrno <> lwa_clrq_itm_new-clrno
                  OR lwa_crcon_new-clrit <> lwa_clrq_itm_new-clrit
                  OR lwa_crcon_new-clrsit <> lwa_clrq_itm_new-clrsit
                  OR lwa_crcon_new-clrdit <> lwa_clrq_itm_new-clrdit.
                  EXIT.
                ELSE.
                  lwa_crcon_new_t = lwa_crcon_new.
                  READ TABLE lt_crcon_copied INTO lwa_crcon_delta WITH KEY kschl = lwa_crcon_new-kschl.
                  IF sy-subrc = 0.
                    DELETE lt_crcon_copied_t WHERE kschl = lwa_crcon_new-kschl.
                    CLEAR : lwa_crcon_delta-clrit,
                            lwa_crcon_delta-clrdit,
                            lwa_crcon_delta-clrsit,
                            lwa_crcon_delta-stunr,
                            lwa_crcon_delta-zaehk,
                            lwa_crcon_new-clrit,
                            lwa_crcon_new-clrdit,
                            lwa_crcon_new-clrsit,
                            lwa_crcon_new-stunr,
                            lwa_crcon_new-zaehk.
                    IF lwa_crcon_delta <> lwa_crcon_new.
                      APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                      MOVE-CORRESPONDING lwa_crcon_new_t TO <lwa_crcon_copied>.
                      <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                      <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                      <lwa_crcon_copied>-kbetr =  lwa_crcon_new-kbetr - lwa_crcon_delta-kbetr .
                      <lwa_crcon_copied>-kawrt =  lwa_crcon_new-kawrt - lwa_crcon_delta-kawrt.
                      <lwa_crcon_copied>-kwert =  lwa_crcon_new-kwert - lwa_crcon_delta-kwert.
                      <lwa_crcon_copied>-updkz = gc_updkz_new.
                    ENDIF.
                  ELSE.
                    APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                    MOVE-CORRESPONDING lwa_crcon_new_t TO <lwa_crcon_copied>.
                    <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                    <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                    <lwa_crcon_copied>-updkz = gc_updkz_new.
                  ENDIF.
                ENDIF.
              ENDLOOP.
              IF lt_crcon_copied_t IS NOT INITIAL.
                LOOP AT lt_crcon_copied_t INTO lwa_crcon_delta.
                  APPEND INITIAL LINE TO gs_clrqdoc_infocus-x-crcon ASSIGNING <lwa_crcon_copied>.
                  MOVE-CORRESPONDING lwa_crcon_delta TO <lwa_crcon_copied>.
                  <lwa_crcon_copied>-clrsit = <lwa_critm_copied>-clrsit.
                  <lwa_crcon_copied>-clrdit = <lwa_critm_copied>-clrdit.
                  <lwa_crcon_copied>-kbetr =  0 - lwa_crcon_delta-kbetr .
                  <lwa_crcon_copied>-kawrt =  0 - lwa_crcon_delta-kawrt.
                  <lwa_crcon_copied>-kwert =  0 - lwa_crcon_delta-kwert.
                  <lwa_crcon_copied>-updkz = gc_updkz_new.
                ENDLOOP.
              ENDIF.

            ENDIF.
          ENDIF.

          IF gs_clrit_org-istat <> gc_ibill_stat-copied.
            <lwa_clrit_item>-netwr = ( <lwa_clrit_item>-netwr - <lwa_clrit_delta>-netwr ) + lwa_clrq_itm_new-netwr.
            "++SOC - DCLM 6423 subtotal not populated
            <lwa_clrit_item>-kzwi1 = ( <lwa_clrit_item>-kzwi1 - <lwa_clrit_delta>-kzwi1 ) + lwa_clrq_itm_new-kzwi1.
            <lwa_clrit_item>-kzwi2 = ( <lwa_clrit_item>-kzwi2 - <lwa_clrit_delta>-kzwi2 ) + lwa_clrq_itm_new-kzwi2.
            <lwa_clrit_item>-kzwi3 = ( <lwa_clrit_item>-kzwi3 - <lwa_clrit_delta>-kzwi3 ) + lwa_clrq_itm_new-kzwi3.
            <lwa_clrit_item>-kzwi4 = ( <lwa_clrit_item>-kzwi4 - <lwa_clrit_delta>-kzwi4 ) + lwa_clrq_itm_new-kzwi4.
            <lwa_clrit_item>-kzwi5 = ( <lwa_clrit_item>-kzwi5 - <lwa_clrit_delta>-kzwi5 ) + lwa_clrq_itm_new-kzwi5.
            <lwa_clrit_item>-kzwi6 = ( <lwa_clrit_item>-kzwi6 - <lwa_clrit_delta>-kzwi6 ) + lwa_clrq_itm_new-kzwi6.
            "++EOC - DCLM 6423 subtotal not populated
            <lwa_clrit_item>-wbs_allocation = lwa_clrq_itm_new-wbs_allocation.

            "++SOC - Decimal precision fields
            <lwa_clrit_item>-netwr24  = ( <lwa_clrit_item>-netwr24 - <lwa_clrit_delta>-netwr24 ) + lwa_clrq_itm_new-netwr24.
            <lwa_clrit_item>-kzwi1_24 = ( <lwa_clrit_item>-kzwi1_24 - <lwa_clrit_delta>-kzwi1_24 ) + lwa_clrq_itm_new-kzwi1_24.
            <lwa_clrit_item>-kzwi2_24 = ( <lwa_clrit_item>-kzwi2_24 - <lwa_clrit_delta>-kzwi2_24 ) + lwa_clrq_itm_new-kzwi2_24.
            <lwa_clrit_item>-kzwi3_24 = ( <lwa_clrit_item>-kzwi3_24 - <lwa_clrit_delta>-kzwi3_24 ) + lwa_clrq_itm_new-kzwi3_24.
            <lwa_clrit_item>-kzwi4_24 = ( <lwa_clrit_item>-kzwi4_24 - <lwa_clrit_delta>-kzwi4_24 ) + lwa_clrq_itm_new-kzwi4_24.
            <lwa_clrit_item>-kzwi5_24 = ( <lwa_clrit_item>-kzwi5_24 - <lwa_clrit_delta>-kzwi5_24 ) + lwa_clrq_itm_new-kzwi5_24.
            <lwa_clrit_item>-kzwi6_24 = ( <lwa_clrit_item>-kzwi6_24 - <lwa_clrit_delta>-kzwi6_24 ) + lwa_clrq_itm_new-kzwi6_24.
            "++EOC - Decimal precision fields
            gs_clrqdoc_infocus-x-crhdr-netwr = ( gs_clrqdoc_infocus-x-crhdr-netwr - <lwa_clrit_delta>-netwr ) + lwa_clrq_itm_new-netwr.
            "++SOC - decimal precision fields
            gs_clrqdoc_infocus-x-crhdr-netwr24 = ( gs_clrqdoc_infocus-x-crhdr-netwr24 - <lwa_clrit_delta>-netwr24 ) + lwa_clrq_itm_new-netwr24.
            "++EOC - decimal precision fields
            gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
          ELSE.
            <lwa_clrit_item>-netwr = <lwa_clrit_item>-netwr  + <lwa_critm_copied>-netwr.
            "++SOC - DCLM 6423 subtotal not populated
            <lwa_clrit_item>-kzwi1 = <lwa_clrit_item>-kzwi1 + <lwa_critm_copied>-kzwi1.
            <lwa_clrit_item>-kzwi2 = <lwa_clrit_item>-kzwi2 + <lwa_critm_copied>-kzwi2.
            <lwa_clrit_item>-kzwi3 = <lwa_clrit_item>-kzwi3 + <lwa_critm_copied>-kzwi3.
            <lwa_clrit_item>-kzwi4 = <lwa_clrit_item>-kzwi4 + <lwa_critm_copied>-kzwi4.
            <lwa_clrit_item>-kzwi5 = <lwa_clrit_item>-kzwi5 + <lwa_critm_copied>-kzwi5.
            <lwa_clrit_item>-kzwi6 = <lwa_clrit_item>-kzwi6 + <lwa_critm_copied>-kzwi6.
            "++EOC - DCLM 6423 subtotal not populated
            "++SOC - Decimal precision fields
            <lwa_clrit_item>-netwr24  = <lwa_clrit_item>-netwr24  + <lwa_critm_copied>-netwr24.
            <lwa_clrit_item>-kzwi1_24 = <lwa_clrit_item>-kzwi1_24 + <lwa_critm_copied>-kzwi1_24.
            <lwa_clrit_item>-kzwi2_24 = <lwa_clrit_item>-kzwi2_24 + <lwa_critm_copied>-kzwi2_24.
            <lwa_clrit_item>-kzwi3_24 = <lwa_clrit_item>-kzwi3_24 + <lwa_critm_copied>-kzwi3_24.
            <lwa_clrit_item>-kzwi4_24 = <lwa_clrit_item>-kzwi4_24 + <lwa_critm_copied>-kzwi4_24.
            <lwa_clrit_item>-kzwi5_24 = <lwa_clrit_item>-kzwi5_24 + <lwa_critm_copied>-kzwi5_24.
            <lwa_clrit_item>-kzwi6_24 = <lwa_clrit_item>-kzwi6_24 + <lwa_critm_copied>-kzwi6_24.
            "++EOC - Decimal precision fields
            gs_clrqdoc_infocus-x-crhdr-netwr =  gs_clrqdoc_infocus-x-crhdr-netwr  + <lwa_critm_copied>-netwr.
            "++SOC - decimal precision field
            gs_clrqdoc_infocus-x-crhdr-netwr24 =  gs_clrqdoc_infocus-x-crhdr-netwr24  + <lwa_critm_copied>-netwr24.
            "++EOC - decimal precision field
            gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
          ENDIF.
          <lwa_clrit_item>-updkz = gc_updkz_update.
          UNASSIGN <lwa_clrit_delta>.
        ENDIF.
      ENDIF.
    ENDIF.
    UNASSIGN : <lwa_clrit_item>,
                <lwa_clrit_sub>,
                <lwa_clrit_delta>.
    IF <lwa_clrqit_last_copied> IS ASSIGNED.
      UNASSIGN <lwa_clrqit_last_copied>.
    ENDIF.
  ENDLOOP.

  IF NOT gs_clrqdoc_infocus IS INITIAL.

    APPEND gs_clrqdoc_infocus TO lt_clrqdoc.
    CLEAR gs_clrqdoc_infocus.
    PERFORM save_mass_documents USING lt_clrqdoc
                                      'X'.
    CALL FUNCTION '/CGDC/CLRQ_CLRQPRS_UPDATE_DB' IN UPDATE TASK
      EXPORTING
        it_clrqpit = lt_clrqpit.
    IF sy-subrc <> 0.
    ENDIF.
  ENDIF.

  lwa_return-msgid = gc_clrq_msg_cls.
  lwa_return-msgty = gc_message_type-succes.
  lwa_return-msgnr = 012.
  lwa_return-msgv1 = gs_clrqdoc_infocus-x-crhdr-clrno.
  lwa_return-msgv2 = gs_clrqdoc_infocus-x-crhdr-vgbel.
  APPEND lwa_return TO et_return_tab.
  CLEAR lwa_return.
  et_item_key = gt_bg_crt_keys.
ENDFUNCTION.

FUNCTION /cgdc/clrq_show_messages.
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Message Pop Up
**********************************************************

*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(IT_MESSAGES) TYPE  /CGDC/T_MESSAGE
*"     REFERENCE(IM_CALL_FROM_UI) TYPE  FLAG OPTIONAL
*"----------------------------------------------------------------------

* Local Constants
  CONSTANTS: lc_icon_5c TYPE icon_d VALUE '@5C@',
             lc_icon_35 TYPE icon_d VALUE '@35@',
             lc_icon_5b TYPE icon_d VALUE '@5B@',
             lc_icon_09 TYPE icon_d VALUE '@09@'.

  DATA: lwa_message_fcat TYPE lty_message,
        lwa_message      TYPE /cgdc/s_message. .

  CLEAR gt_messages_fcat.
  IF it_messages IS NOT INITIAL.
    LOOP AT it_messages INTO lwa_message.
      IF lwa_message-msgty IS INITIAL.
        lwa_message-msgty = gc_message_type-succes.
      ENDIF.
      MESSAGE ID lwa_message-msgid
              TYPE lwa_message-msgty
              NUMBER lwa_message-msgnr
              WITH lwa_message-msgv1
              lwa_message-msgv2
              lwa_message-msgv3
              lwa_message-msgv4
              INTO lwa_message_fcat-message.

      lwa_message_fcat-msgid = lwa_message-msgid.
      lwa_message_fcat-msgnr = lwa_message-msgnr.
      CASE lwa_message-msgty.
        WHEN gc_message_type-error.
          lwa_message_fcat-icon = lc_icon_5c.
          lwa_message_fcat-icon1 = lc_icon_35.
        WHEN gc_message_type-succes.
          lwa_message_fcat-icon = lc_icon_5b.
        WHEN gc_message_type-warning.
          lwa_message_fcat-icon = lc_icon_09.
        WHEN gc_message_type-abort.
        WHEN gc_message_type-information.
          lwa_message_fcat-icon = lc_icon_09.
      ENDCASE.
      APPEND lwa_message_fcat TO gt_messages_fcat.
      CLEAR lwa_message_fcat.
    ENDLOOP.
    SORT gt_messages_fcat BY icon message.
    DELETE ADJACENT DUPLICATES FROM gt_messages_fcat COMPARING icon message.
*    Flag to check if it from UI
    IF im_call_from_ui IS INITIAL.
      CALL SCREEN 0901 STARTING AT 30 2
                       ENDING AT 140 10.
    ENDIF.

  ENDIF.
ENDFUNCTION.

**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2025] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-231COINCGDC (CIS-AD S/4 Hana 2023)
*
* DESCRIPTION: Trigger Real Time Process
**********************************************************
 FUNCTION /cgdc/clrq_trgr_real_time_prcs.
*"----------------------------------------------------------------------
*"*"Update Function Module:
*"
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(IT_ACDOCA) TYPE  FINST_ACDOCA OPTIONAL
*"     VALUE(IT_COEP) TYPE  TT_COEP OPTIONAL
*"     VALUE(IT_COEPR) TYPE  TT_COEPR OPTIONAL
*"     VALUE(IT_COBK) TYPE  TTCOBK OPTIONAL
*"     VALUE(IT_MSEG) TYPE  TY_T_MSEG OPTIONAL
*"----------------------------------------------------------------------
   TYPES : lty_src_del_r TYPE RANGE OF /cgdc/t_rtbrel-/cgdc/rtbsource.
   DATA : lt_src_del_r  TYPE lty_src_del_r,
          lwa_src_del_r LIKE LINE OF lt_src_del_r.

   TYPES : BEGIN OF lty_rtb_trgr,
             source    TYPE /cgdc/rtbsource,
             tabname   TYPE tabname,
             fieldname TYPE fieldname,
             flag      TYPE flag,
           END OF lty_rtb_trgr.


   TYPES : BEGIN OF lty_src_tab.
             INCLUDE TYPE /cgdc/t_rtbrel.
   TYPES :   delete TYPE flag,
           END OF lty_src_tab.

   TYPES : BEGIN OF lty_tabname,
             tabname TYPE tabname,
           END OF lty_tabname.

   DATA: lv_check_tab TYPE string,
         lv_tab_where TYPE string.
   DATA : lv_setid         TYPE setid,
          lt_set_line_val  TYPE TABLE OF rgsbv,
          lwa_set_line_val TYPE rgsbv.
   DATA: lwa_clrqsrc_data TYPE /cgdc/s_clrqsrc_data,
         lt_clrqsrc_data  TYPE TABLE OF /cgdc/s_clrqsrc_data.
   DATA : lt_src_table  TYPE TABLE OF lty_src_tab,
          lwa_src_table TYPE lty_src_tab.
   DATA : lo_tab_ref TYPE REF TO data.
   DATA : lt_rtb_trgr  TYPE TABLE OF lty_rtb_trgr,
          lwa_rtb_trgr TYPE lty_rtb_trgr.
   DATA : lt_bf_tabname  TYPE TABLE  OF lty_tabname,
          lwa_bf_tabname TYPE lty_tabname.
   DATA : lv_call_rtbc TYPE flag.
   DATA : lv_bukrs TYPE bukrs.
   FIELD-SYMBOLS : <lt_table> TYPE STANDARD TABLE.

   CONSTANTS: lc_rtb_event_fi01 TYPE /cgdc/rtb_event VALUE 'FI01'.


   IF it_acdoca IS NOT INITIAL.
     lwa_bf_tabname-tabname = 'ACDOCA'.
     APPEND lwa_bf_tabname TO lt_bf_tabname.
   ENDIF.
   IF it_coep IS NOT INITIAL.
     lwa_bf_tabname-tabname = 'COEP'.
     APPEND lwa_bf_tabname TO lt_bf_tabname.
   ENDIF.
   IF it_cobk IS NOT INITIAL.
     lwa_bf_tabname-tabname = 'COBK'.
     APPEND lwa_bf_tabname TO lt_bf_tabname.
   ENDIF.
   IF it_coepr IS NOT INITIAL.
     lwa_bf_tabname-tabname = 'COEPR'.
     APPEND lwa_bf_tabname TO lt_bf_tabname.
   ENDIF.
   IF it_mseg IS NOT INITIAL.
     lwa_bf_tabname-tabname = 'MSEG'.
     APPEND lwa_bf_tabname TO lt_bf_tabname.
   ENDIF.

   CHECK lt_bf_tabname IS NOT INITIAL. "No Buffer Filled

   SELECT *
     FROM /cgdc/t_rtbrel
     INTO CORRESPONDING FIELDS OF TABLE lt_src_table.
*     FOR ALL ENTRIES IN lt_bf_tabname
*     WHERE /cgdc/tab_name = lt_bf_tabname-tabname.
   IF lt_src_table IS NOT INITIAL.
     "Keep Source who has all buffer tables


     LOOP AT lt_src_table ASSIGNING FIELD-SYMBOL(<lwa_src_tb>).
       READ TABLE lt_src_del_r TRANSPORTING NO FIELDS WITH KEY low = <lwa_src_tb>-/cgdc/rtbsource.
       IF sy-subrc <> 0.
         READ TABLE lt_bf_tabname TRANSPORTING NO FIELDS WITH KEY tabname = <lwa_src_tb>-/cgdc/tab_name.
         IF sy-subrc <> 0.
           lwa_src_del_r-low = <lwa_src_tb>-/cgdc/rtbsource.
           lwa_src_del_r-option = 'EQ'.
           lwa_src_del_r-sign = 'I'.
           APPEND lwa_src_del_r TO lt_src_del_r.
         ENDIF.
       ENDIF.
     ENDLOOP.
     DELETE lt_src_table WHERE /cgdc/rtbsource IN lt_src_del_r.
     LOOP AT lt_src_table ASSIGNING <lwa_src_tb>.
       LOOP AT lt_bf_tabname INTO lwa_bf_tabname.
         READ TABLE lt_src_table TRANSPORTING NO FIELDS WITH KEY /cgdc/rtbsource = <lwa_src_tb>-/cgdc/rtbsource
                                                                 /cgdc/tab_name = lwa_bf_tabname-tabname.
         IF sy-subrc <> 0.
           <lwa_src_tb>-delete = 'X'.
           EXIT.
         ENDIF.
       ENDLOOP.
     ENDLOOP.
     DELETE lt_src_table WHERE delete = 'X'.
   ENDIF.




   IF lt_src_table IS NOT INITIAL.

     "Select Selection Cretiria
     SELECT *
     FROM /cgdc/t_rtbsrcs
     INTO TABLE @DATA(lt_rtb_trgr_sts)
     FOR ALL ENTRIES IN @lt_src_table
     WHERE /cgdc/rtbsource = @lt_src_table-/cgdc/rtbsource. "Source Trigger Active or Not

     SELECT *
     FROM /cgdc/t_rtbrelsl
     INTO TABLE @DATA(lt_rtbrelsl)
     FOR ALL ENTRIES IN @lt_src_table
     WHERE /cgdc/rtbsource = @lt_src_table-/cgdc/rtbsource.
     IF sy-subrc = 0. "IF SELECTION CRITERIA is maintained
       "FIND BUKRS
       IF lv_bukrs IS INITIAL.
         LOOP AT it_acdoca INTO DATA(lwa_acdoca).
           IF lwa_acdoca-bukrs_sender IS NOT INITIAL.
             lv_bukrs = lwa_acdoca-bukrs_sender.
             EXIT.
           ENDIF.
         ENDLOOP.
       ENDIF.

       IF lv_bukrs IS INITIAL.
         LOOP AT it_coep INTO DATA(lwa_coep).
           IF lwa_coep-bukrs IS NOT INITIAL.
             lv_bukrs = lwa_coep-bukrs.
             EXIT.
           ENDIF.
         ENDLOOP.
       ENDIF.


       IF lv_bukrs IS INITIAL.
         LOOP AT it_mseg INTO DATA(lwa_mseg).
           IF lwa_mseg-bukrs IS NOT INITIAL.
             lv_bukrs = lwa_mseg-bukrs.
             EXIT.
           ENDIF.
         ENDLOOP.
       ENDIF.


       SELECT SINGLE *
          FROM t001
          INTO @DATA(ls_t001)
          WHERE bukrs = @lv_bukrs. "BUKRK Is Pending.



       LOOP AT lt_rtbrelsl INTO DATA(lwa_rtbresl).
         READ TABLE lt_rtb_trgr_sts TRANSPORTING NO FIELDS WITH KEY /cgdc/rtbsource = lwa_rtbresl-/cgdc/rtbsource
                                                                    trigger_active = 'R'.
         IF sy-subrc = 0. """ IF SOURCE IS ACTIVE then only consider for  selection criteria
           READ TABLE lt_rtb_trgr ASSIGNING FIELD-SYMBOL(<lwa_rtb_trgr>) WITH KEY  source = lwa_rtbresl-/cgdc/rtbsource
                                                                                   tabname = lwa_rtbresl-tabname
                                                                                   fieldname = lwa_rtbresl-fieldname.
           IF sy-subrc = 0. "IF TABNAME and Fieldname Condition Satisfied before
             IF <lwa_rtb_trgr>-flag = abap_true.
               CONTINUE.
             ENDIF.
           ELSE.
             APPEND INITIAL LINE TO lt_rtb_trgr ASSIGNING <lwa_rtb_trgr>.
             <lwa_rtb_trgr>-source = lwa_rtbresl-/cgdc/rtbsource.
             <lwa_rtb_trgr>-tabname = lwa_rtbresl-tabname.
             <lwa_rtb_trgr>-fieldname = lwa_rtbresl-fieldname.
           ENDIF.

           CASE lwa_rtbresl-tabname.
             WHEN 'ACDOCA'.
               ASSIGN it_acdoca TO <lt_table>.
             WHEN 'COEP'.
               ASSIGN it_coep TO <lt_table>.
             WHEN 'COBK'.
               ASSIGN it_cobk TO <lt_table>.
             WHEN 'COEPR'.
               ASSIGN it_coepr TO <lt_table>.
             WHEN 'MSEG'.
               ASSIGN it_mseg TO <lt_table>.
             WHEN OTHERS.
               CONTINUE.
           ENDCASE.
           LOOP AT <lt_table> ASSIGNING FIELD-SYMBOL(<lwa_wa>).
             ASSIGN COMPONENT lwa_rtbresl-fieldname OF STRUCTURE <lwa_wa> TO FIELD-SYMBOL(<lv_value>).
             IF <lv_value> IS ASSIGNED.
               SHIFT <lv_value> LEFT DELETING LEADING '0'.
               SHIFT  lwa_rtbresl-val_from LEFT DELETING LEADING '0'.
               IF lwa_rtbresl-val_from IS NOT INITIAL AND <lv_value> = lwa_rtbresl-val_from.
                 <lwa_rtb_trgr>-flag = abap_true.
               ELSEIF lwa_rtbresl-setclass IS NOT INITIAL AND lwa_rtbresl-setname IS NOT INITIAL.
                 CONCATENATE  ls_t001-ktopl lwa_rtbresl-setname  INTO lv_setid. "GET SET CLASS DATA
                 CALL FUNCTION 'G_SET_FETCH'
                   EXPORTING
                     class           = lwa_rtbresl-setclass
                     setnr           = lv_setid
                   TABLES
                     set_lines_basic = lt_set_line_val
                   EXCEPTIONS
                     no_authority    = 1
                     set_is_broken   = 2
                     set_not_found   = 3
                     OTHERS          = 4.
                 IF sy-subrc = 0.
                   LOOP AT lt_set_line_val INTO lwa_set_line_val.
                     IF lwa_set_line_val-to IS INITIAL.
                       IF <lv_value> EQ lwa_set_line_val-from.
                         <lwa_rtb_trgr>-flag = abap_true.
                         EXIT.
                       ENDIF.
                     ELSE.
                       IF <lv_value> GE lwa_set_line_val-from AND <lv_value> LE lwa_set_line_val-to.
                         <lwa_rtb_trgr>-flag = abap_true.
                         EXIT.
                       ENDIF.
                     ENDIF.
                   ENDLOOP.
                 ELSE.
                   "* Implement suitable error handling here
                 ENDIF.
                 IF <lwa_rtb_trgr>-flag = abap_true.
                   EXIT.
                 ENDIF.
               ENDIF.
             ENDIF.
           ENDLOOP.
         ENDIF.
       ENDLOOP.

       SORT lt_rtb_trgr BY source.
       LOOP AT lt_rtb_trgr INTO lwa_rtb_trgr.
         AT NEW source.
           READ TABLE lt_rtb_trgr TRANSPORTING NO FIELDS WITH KEY flag = ''. "ANY SOURCE with condition satisfic
           IF sy-subrc <> 0.
             lv_call_rtbc = abap_true.
           ENDIF.
         ENDAT.
       ENDLOOP.
     ELSE. "IF NO SELECTION CRITERIA is not maintained
       READ TABLE lt_rtb_trgr_sts TRANSPORTING NO FIELDS WITH KEY trigger_active = 'R'.
       IF sy-subrc = 0.
         lv_call_rtbc = abap_true.
       ENDIF.
     ENDIF.
     IF lv_call_rtbc IS NOT INITIAL.
       IF it_coep IS NOT INITIAL.
         lwa_clrqsrc_data-tabname = 'COEP'.
         CREATE DATA lwa_clrqsrc_data-data TYPE TABLE OF coep.
         lwa_clrqsrc_data-data->* = it_coep.
         APPEND lwa_clrqsrc_data TO lt_clrqsrc_data.
       ENDIF.
       IF it_acdoca IS NOT INITIAL.
         lwa_clrqsrc_data-tabname = 'ACDOCA'.
         CREATE DATA lwa_clrqsrc_data-data TYPE TABLE OF acdoca.
         lwa_clrqsrc_data-data->* = it_acdoca.
         APPEND lwa_clrqsrc_data TO lt_clrqsrc_data.
       ENDIF.
       IF it_cobk IS NOT INITIAL.
         lwa_clrqsrc_data-tabname = 'COBK'.
         CREATE DATA lwa_clrqsrc_data-data TYPE TABLE OF cobk.
         lwa_clrqsrc_data-data->* = it_cobk.
         APPEND lwa_clrqsrc_data TO lt_clrqsrc_data.
       ENDIF.
       IF it_coepr IS NOT INITIAL.
         lwa_clrqsrc_data-tabname = 'COEPR'.
         CREATE DATA lwa_clrqsrc_data-data TYPE TABLE OF coepr.
         lwa_clrqsrc_data-data->* = it_coepr.
         APPEND lwa_clrqsrc_data TO lt_clrqsrc_data.
       ENDIF.
       IF it_mseg IS NOT INITIAL.
         lwa_clrqsrc_data-tabname = 'MSEG'.
         CREATE DATA lwa_clrqsrc_data-data TYPE TABLE OF mseg.
         lwa_clrqsrc_data-data->* = it_mseg.
         APPEND lwa_clrqsrc_data TO lt_clrqsrc_data.
       ENDIF.
       CALL METHOD /cgdc/cl_clrq_process=>process_realtime_data
         EXPORTING
           it_clrqsrc_data = lt_clrqsrc_data
           iv_rtb_event    = lc_rtb_event_fi01.
     ENDIF.
   ENDIF.

   /cgdc/cl_clrq_set_buffer=>clear_buffers( ).
 ENDFUNCTION.

FUNCTION /cgdc/clrq_update_costlines.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(IM_CLRNO) TYPE  /CGDC/CLRQNO
*"     VALUE(IM_MODE) TYPE  CHAR1
*"     VALUE(IM_PRICING) TYPE  CHAR1
*"  EXCEPTIONS
*"      COMMUNICATION_FAILURE
*"      SYSTEM_FAILURE
*"      RESOURCE_FAILURE
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2022] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-211COINCGDC (CIS-AD S/4 Hana 2021)
*
* DESCRIPTION: Update Costlines
**********************************************************

  TYPES: lty_params    TYPE RANGE OF vbeln_va.
  DATA: lv_ques(100) TYPE c,
        lv_msg       TYPE string,
        lv_params    TYPE lty_params,
        lv_flag      TYPE c,
        lv_invalid   TYPE flag.

  CONSTANTS: lc_foreground TYPE char1 VALUE 'F',
             lc_background TYPE char1 VALUE 'B'.

  IF im_clrno IS INITIAL.                                         "ACT Check Fix
    PERFORM check_clrq_authorization USING  gs_clrqdoc_infocus-x-crhdr-clrqt
                                 gs_clrqdoc_infocus-x-crhdr-vkorg
                                 gs_clrqdoc_infocus-x-crhdr-vtweg
                                 gs_clrqdoc_infocus-x-crhdr-spart
                                 gc_auth_actv-change
                                 space
                           CHANGING lv_invalid.
  ENDIF.

  SELECT SINGLE vgbel FROM /cgdc/_clrqhd INTO @DATA(lv_vbeln) WHERE clrno = @im_clrno.
  IF sy-subrc IS INITIAL.
    CASE im_mode.

      WHEN lc_foreground.
        IF im_pricing IS INITIAL.
          lv_params = VALUE lty_params( ( sign = gc_range_tbl_sign-include option = gc_operator-equal low = lv_vbeln ) ).
          SUBMIT /cgdc/clrq_process WITH so_vbeln IN lv_params
                                    WITH r_crt    = abap_true
                                  WITH p_noprc  = abap_true
                                     AND RETURN .

        ELSE.
          lv_params = VALUE lty_params( ( sign = gc_range_tbl_sign-include option = gc_operator-equal low = lv_vbeln ) ).
          SUBMIT /cgdc/clrq_process WITH so_vbeln IN lv_params
                      WITH r_crt   = ''
                      WITH r_reprc = ''
                      WITH r_repfl = abap_true
                      AND RETURN.
        ENDIF.

      WHEN lc_background.
        IF im_pricing IS INITIAL.
          PERFORM update_calc_req_background_ui USING lv_vbeln lv_flag.
        ELSE.
          lv_flag = abap_true.
          PERFORM update_calc_req_background_ui USING lv_vbeln lv_flag.
        ENDIF.
    ENDCASE.
  ENDIF.
ENDFUNCTION.

FUNCTION /cgdc/rtb_prl_validate_clrq.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     REFERENCE(I_VBELN) TYPE  VBELN_VA
*"     REFERENCE(IS_PRL) TYPE  /CGDC/S_PARALLEL_PROCESS
*"  EXPORTING
*"     REFERENCE(ES_CLRQ_DOC) TYPE  /CGDC/S_CLRQ_DOC
*"----------------------------------------------------------------------
**********************************************************
* Cognitus Technologies Confidential
**********************************************************
*
*  [2019] - [2025] Cognitus Technologies LLC
*  All Rights Reserved.
*
* NOTICE:  All information contained herein is, and remains
* the property of Cognitus Technologies LLC and its suppliers,
* if any. The intellectual and technical concepts contained
* herein are proprietary to Cognitus Technologies LLC and its
* suppliers and may be covered by U.S. and Foreign Patents,
* patents in process, and are protected by trade secret or
* copyright law. Dissemination of this information or
* reproduction of this material is strictly forbidden unless
* prior written permission is obtained from Cognitus
* Consulting LLC.
**********************************************************
* VERSION CONTROL (Most recent on top):
*
* RELEASE: SAPK-231COINCGDC (CIS-AD S/4 Hana 2023)
*
* DESCRIPTION: CIS-AD: Validate Calculation Request
**********************************************************


  DATA:
    lv_no_attempt          TYPE num4,
    lv_max_attempts        TYPE num4,
    lv_max_attempt_failure TYPE c,
    lv_row_count           TYPE sy-tabix,
    lv_job_name            TYPE btcjob,
    lv_job_number          TYPE btcjobcnt,
    lv_report_name         TYPE programm VALUE '/CGDC/CLRQ_PROCESS',
    lv_memory_id           TYPE char20,
    lv_blk                 TYPE sy-tabix,
    lv_memory_id_1         TYPE char20,
    lv_memory_id_2         TYPE char20,
    lwa_bgwp_list          LIKE LINE OF gt_bgwp_list,
    lt_wpinfo              TYPE TABLE OF wpinfo,
    lt_final_proc          TYPE TABLE OF wpinfo.

  DATA lv_subrc TYPE sysubrc.
  DATA lwa_clrit_key TYPE /cgdc/s_clrqit_key.
  DATA lt_clrit_key TYPE TABLE OF /cgdc/s_clrqit_key.
  DATA lt_clrit_key_t TYPE TABLE OF /cgdc/s_clrqit_key.

  DATA : lv_rows     TYPE i,
         lv_index    TYPE i,
         lv_tot_rows TYPE i.


  SELECT DISTINCT applserver
                  FROM rzllitab
                  INTO TABLE @DATA(lt_server)
                  WHERE classname =  @is_prl-server_group.
*- get number of background processess available
  LOOP AT lt_server INTO DATA(ls_server).
    CLEAR lt_wpinfo[].
    CALL FUNCTION 'TH_GET_WPINFO'
      EXPORTING
        srvname    = ls_server-applserver
*       WITH_CPU   =
      TABLES
        wplist     = lt_wpinfo
      EXCEPTIONS
        send_error = 1
        OTHERS     = 2.
    IF sy-subrc <> 0.
    ENDIF.
*- get all work processes in the server
    APPEND LINES OF lt_wpinfo TO lt_final_proc.
  ENDLOOP.

*- get open work processes
  IF is_prl-background_job EQ abap_true.
    DELETE lt_final_proc WHERE wp_typ NE 'BGD' .
    DELETE lt_final_proc WHERE wp_status NE 'Waiting'.
  ELSE.
    DELETE lt_final_proc WHERE wp_typ NE 'DIA' AND wp_status NE 'Waiting'.
  ENDIF.
  DESCRIBE TABLE lt_final_proc LINES DATA(lv_times).
*- get optimal block size
  DESCRIBE TABLE gt_clrqsrc LINES DATA(lv_data).

*  DATA(lv_blk) = ceil( lv_data DIV lv_times ).

  IF lv_times IS NOT INITIAL   .
    lv_blk = ceil( lv_data DIV lv_times ).
  ENDIF.

  IF lv_blk EQ '0'.
    lv_blk = 1.
  ENDIF.

  IF lv_blk LT gs_variables-cmfrq.
    gs_variables-cmfrq = lv_blk.
  ENDIF.


  PERFORM select_clrqhd USING i_vbeln ''. "Select CLRQ HDR Details
  PERFORM read_contract_details USING i_vbeln.
*  PERFORM enqueue_calc_request USING gs_clrqdoc_infocus-x-crhdr-clrno
*                                                       gc_enq_mode-write
*                                                 CHANGING lv_subrc.
  IF lv_subrc = 0.
    gs_variables-key_only = 'X'.
    PERFORM read_calc_request_document USING gs_clrqdoc_infocus-x-crhdr-clrno
                                       CHANGING gs_clrqdoc_infocus.
    lt_clrit_key = gs_clrqdoc_infocus-x-critm_key.
    DESCRIBE TABLE lt_clrit_key LINES lv_tot_rows.


    DO.
      CLEAR lv_rows.
      CLEAR lt_clrit_key_t.
      gs_parallel_porcess-active_session_count = gs_parallel_porcess-active_session_count + 1.
      LOOP AT lt_clrit_key INTO lwa_clrit_key FROM lv_index.
        IF lv_rows = gs_variables-cmfrq. "Size of block
          lv_index = sy-tabix - 1.
          EXIT.
        ELSE.
          APPEND lwa_clrit_key TO lt_clrit_key_t.
          lv_rows = lv_rows + 1.
        ENDIF.
        AT LAST.
          lv_index = lv_tot_rows.
        ENDAT.
      ENDLOOP.

      "FM CODE
      IF is_prl-background_job IS INITIAL.
        EXPORT gs_variables TO DATABASE /cgdc/_clrq_indx(cr) ID 'VARIABLES'.
        CALL FUNCTION '/CGDC/RTB_VALIDATE_CLRQ'
          STARTING NEW TASK gs_parallel_porcess-active_session_count
          DESTINATION IN GROUP is_prl-server_group
          PERFORMING post_prl_validate_clrq ON END OF TASK
          EXPORTING
            it_clritkey = lt_clrit_key_t.
      ELSE.
        CONCATENATE '/CGDC/CLRQ_PROC_' i_vbeln '_' gs_parallel_porcess-total_session_count INTO lv_job_name.
        CONDENSE lv_job_name NO-GAPS.

        CALL FUNCTION 'JOB_OPEN'
          EXPORTING
*           DELANFREP        = ' '
*           JOBGROUP         = ' '
            jobname          = lv_job_name
*           SDLSTRTDT        = NO_DATE
*           SDLSTRTTM        = NO_TIME
*           JOBCLASS         =
          IMPORTING
            jobcount         = lv_job_number
*     CHANGING
*           RET              =
          EXCEPTIONS
            cant_create_job  = 1
            invalid_job_data = 2
            jobname_missing  = 3
            OTHERS           = 4.
        IF sy-subrc NE 0.
          EXIT.
        ENDIF.
*        CONCATENATE '/CGDC/CLRQ' gs_parallel_porcess-total_session_count INTO lv_memory_id.
        "replace with guid
        TRY.
            cl_system_uuid=>if_system_uuid_static~create_uuid_c22( RECEIVING uuid = DATA(lv_guid) ).
            lv_memory_id = lv_guid.
          CATCH cx_uuid_error INTO DATA(lo_expn).
        ENDTRY.


        CONCATENATE lv_memory_id '_1' INTO lv_memory_id_1.
*        CONCATENATE lv_memory_id '_2' INTO lv_memory_id_2.
        EXPORT lt_clrit_key_t TO DATABASE /cgdc/_clrq_indx(cr) ID lv_memory_id_1.
*        EXPORT gs_variables TO DATABASE /cgdc/_clrq_indx(cr) ID lv_memory_id_2.

        SUBMIT (lv_report_name) USING SELECTION-SCREEN '1000'
            WITH p_memid   = lv_memory_id
            WITH r_crt  = abap_false
            WITH r_rvldi  = abap_true
            WITH p_parall = abap_true
            WITH p_bcg = abap_true
            WITH p_noprc = gs_variables-no_pricing
            WITH so_vbeln  = i_vbeln
            VIA JOB lv_job_name
            NUMBER lv_job_number
            AND RETURN.


        DO.
****Job CLOSE (Send the job to background processing system)
          CALL FUNCTION 'JOB_CLOSE'
            EXPORTING
              jobcount             = lv_job_number
              jobname              = lv_job_name
              strtimmed            = abap_true
*             targetgroup          = is_prl-server_group
            EXCEPTIONS
              cant_start_immediate = 1
              invalid_startdate    = 2
              jobname_missing      = 3
              job_close_failed     = 4
              job_nosteps          = 5
              job_notex            = 6
              lock_failed          = 7
              invalid_target       = 8
              OTHERS               = 9.


          IF sy-subrc NE 0.
            lv_no_attempt = lv_no_attempt + 1.
            IF lv_no_attempt GE is_prl-retrie.
              lv_max_attempt_failure = abap_true.
              EXIT.
            ELSE.
              WAIT UP TO is_prl-max_wait SECONDS.
            ENDIF.

          ELSE.
            CLEAR lwa_bgwp_list.
            lwa_bgwp_list-task_name = lv_job_name.
            lwa_bgwp_list-task_number = lv_job_number.
            APPEND lwa_bgwp_list TO gt_bgwp_list.

            gs_parallel_porcess-active_session_count = gs_parallel_porcess-active_session_count + 1.
*            IF gs_parallel_porcess-active_session_count GE lv_times. "T ls_parallel_process-max_process.
*              PERFORM active_less_than_max_wait USING gs_parallel_porcess
*                                                      lv_times
*                                             CHANGING gs_parallel_porcess-active_session_count.
*            ENDIF.
            EXIT.
          ENDIF.
        ENDDO.

*    ENDDO.

        IF NOT lv_max_attempt_failure IS INITIAL.
          EXIT.
        ENDIF.
      ENDIF.
      "Exception Code is pending
      IF lv_index = lv_tot_rows.
        EXIT.
      ELSE.
        lv_index = lv_index + 1.
      ENDIF.
      WAIT UNTIL gs_parallel_porcess-active_session_count LT is_prl-max_process. "wait till some active session get completed

    ENDDO.
    WAIT UNTIL gs_parallel_porcess-active_session_count EQ 0. "wait till all active session get completed
  ENDIF.
  gs_variables-exit_loop = abap_true.
  PERFORM initialize_document_data.

ENDFUNCTION.

 FUNCTION /cgdc/rtb_validate_clrq.
*"----------------------------------------------------------------------
*"*"Local Interface:
*"  IMPORTING
*"     VALUE(IT_CLRITKEY) TYPE  /CGDC/TT_CLRQIT_KEY
*"----------------------------------------------------------------------
   DATA lt_kstar_range TYPE ty_kstar_range.
   DATA lv_kstar TYPE kstar.
   DATA lwa_critm TYPE /cgdc/s_clrqit.
   DATA lv_subrc TYPE sysubrc.
   DATA lv_valid TYPE flag.
   DATA lv_billed TYPE flag.
   DATA lwa_clrit_key TYPE /cgdc/s_clrqit_key.
   DATA lt_clrit_key TYPE TABLE OF /cgdc/s_clrqit_key.
   DATA lt_clrit_key_delete TYPE TABLE OF /cgdc/s_clrqit_key.
   DATA lt_clrit_key_del_billed TYPE TABLE OF /cgdc/s_clrqit_key.
   DATA: lt_clrq_doc TYPE /cgdc/tt_clrq_doc,
         lv_invalid  TYPE flag.

   FIELD-SYMBOLS: <lt_src_tmp>  TYPE table,
                  <lwa_src_tmp> TYPE data.

   IF it_clritkey IS INITIAL.                             "ACT Check Fix
     PERFORM check_clrq_authorization USING  gs_clrqdoc_infocus-x-crhdr-clrqt
                             gs_clrqdoc_infocus-x-crhdr-vkorg
                             gs_clrqdoc_infocus-x-crhdr-vtweg
                             gs_clrqdoc_infocus-x-crhdr-spart
                             gc_auth_actv-change
                             space
                       CHANGING lv_invalid.
   ENDIF.

*   IMPORT gs_variables FROM DATABASE indx(cr) ID 'VARIABLES'.

   gs_variables-overview_mode = gc_mode_change.
   PERFORM set_calc_req_item_doc_infocus USING  it_clritkey
                                                CHANGING lv_subrc.

   "++ SOC - Read Source Data for all selected items.
    PERFORM get_src_data_by_link USING    gs_clrqdoc_infocus-x-critm
                                 CHANGING gs_clrqdoc_infocus-x-clrit_link.
    "++ EOC - Read Source Data for all selected items.

   IF lv_subrc = 0 OR gs_parallel_porcess-active_session_count <> 0.
     LOOP AT gs_clrqdoc_infocus-x-critm INTO lwa_critm.
       CLEAR : lv_billed,
               lv_valid,
               lv_kstar.
       lv_kstar = lwa_critm-kstar.
       DATA(lwa_critm_tmp) = lwa_critm.      "AT NEW will overwrite all fields with * in lwa_critm
       AT NEW clrit.
         PERFORM check_item_billed USING lwa_critm-clrno
                                         lwa_critm-clrit
                                CHANGING lv_billed.

         "++SOC - validate source records based on configured sources
*         PERFORM check_cost_element_group_v2
*                                                     TABLES
*                                                         lt_kstar_range
*                                                     USING
*                                                         gs_contract_hdr-bukrs_vf
*                                                         gs_contract_hdr-kokrs
*                                                         gs_clrqdoc_infocus-x-crhdr-rtbpn
*                                                         lv_kstar
*                                                         space
*                                                      CHANGING
*                                                         lv_valid.
         READ TABLE gs_clrqdoc_infocus-x-clrit_link ASSIGNING FIELD-SYMBOL(<lfs_clrit_link>)
                                                     WITH KEY clrno = lwa_critm_tmp-clrno
                                                              clrit = lwa_critm_tmp-clrit.
          IF sy-subrc = 0.

            ASSIGN <lfs_clrit_link>-data->* TO <lt_src_tmp>.
*              APPEND <lwa_src_tmp> TO <lt_src_tmp>.
            IF <lt_src_tmp> IS ASSIGNED.
              CALL METHOD /cgdc/cl_rtb_source_util=>check_src_cond
                EXPORTING
                  iv_rtbpn      = gs_contract_hdr-/cgdc/rtbpn "RTB profile
                  iv_rtb_source = lwa_critm_tmp-rtb_source
                  iv_vbeln      = lwa_critm_tmp-vgbel
                IMPORTING
                  et_return     = DATA(lt_return)
                CHANGING
                  ct_src_data   = <lt_src_tmp>.

              IF <lt_src_tmp> IS NOT INITIAL.
                lv_valid = abap_true.
              ENDIF.
            ENDIF.
          ENDIF.
          "++EOC - validate source records based on configured sources

         IF lv_billed IS INITIAL AND lv_valid IS INITIAL.
           lwa_clrit_key-clrno = lwa_critm-clrno.
           lwa_clrit_key-clrit = lwa_critm-clrit.
           APPEND lwa_clrit_key TO lt_clrit_key_delete. "delete
           CLEAR lwa_clrit_key.
         ELSEIF lv_valid IS INITIAL.
           lwa_clrit_key-clrno = lwa_critm-clrno.
           lwa_clrit_key-clrit = lwa_critm-clrit.
           APPEND lwa_clrit_key TO lt_clrit_key_del_billed. "delete
           CLEAR lwa_clrit_key.
         ENDIF.
       ENDAT.
     ENDLOOP.
     IF lt_clrit_key_delete IS NOT INITIAL.
       PERFORM delete_calc_req USING gs_clrqdoc_infocus-x-crhdr-clrno
                                     lt_clrit_key_delete
                                     '1'.
     ENDIF.
     IF lt_clrit_key_del_billed IS NOT INITIAL.
       PERFORM upd_inv_billed_item USING lt_clrit_key_del_billed.
     ENDIF.
     IF gs_clrqdoc_infocus-x-crhdr-msgcode CA 'V'.
       REPLACE 'V' INTO gs_clrqdoc_infocus-x-crhdr-msgcode WITH space.
       CONDENSE gs_clrqdoc_infocus-x-crhdr-msgcode NO-GAPS.
       gs_clrqdoc_infocus-x-crhdr-updkz = gc_updkz_update.
*       es_clrq_doc = gs_clrqdoc_infocus.
     ENDIF.
   ENDIF.

   IF NOT gs_clrqdoc_infocus IS INITIAL.
     CLEAR gs_clrqdoc_infocus.
     APPEND gs_clrqdoc_infocus TO lt_clrq_doc.

     PERFORM save_mass_documents USING lt_clrq_doc
                                       ''.
   ENDIF.

 ENDFUNCTION.
